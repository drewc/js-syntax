#+TITLE: Statements and Declarations
#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)


Ulimately, all ECMAScript code compiles down to a list of [[StatementListItem][StatementListItem]]s.
So, if a token cannot be parsed to one of those, it is an error.

#+begin_src gerbil :noweb-ref syntax-error
  (def (js-syntax-error . args)
    (.let* (t (item))
      (apply error "Invalid Syntax at " (token-start t) (token-value t) args)))

#+end_src

#+begin_src gerbil :noweb-ref statements-and-declarations
  (defstruct statement-or-declaration ())
  (defstruct (statement statement-or-declaration) ())
  (defstruct (declaration statement-or-declaration) ())

  ;;(defstruct (expression-statement statement) (expression) transparent: #t)
  ;;(def ExpressionStatement (.let* (e Expression) (return (expression-statement e))))

#+end_src

#+begin_src gerbil :tangle statements-and-declarations.ss :noweb yes
  ;;; -*- Gerbil -*-
  ;;; (C) me at drewc.ca
  (import :drewc/smug :drewc/js-syntax/lexical
          :drewc/js-syntax/custom :drewc/js-syntax/expressions
          :std/misc/list)
  (export #t)
  <<all-s-and-ds>>
#+end_src

#+begin_src gerbil :noweb-ref all-s-and-ds :noweb yes :comments noweb
<<statements-and-declarations>>
<<syntax-error>>
<<empty-statement-exp>>
<<single-name-binding>>
<<binding-element>>
<<return-statement>>
<<statement>>
<<declaration>>
<<statement-list>>
<<statement-list-item>>
#+end_src


* ECMAScript Language: Statements and Declarations
  :PROPERTIES:
  :CUSTOM_ID: ecmascript-language-statements-and-declarations
  :END:

** Syntax
   :PROPERTIES:
   :CUSTOM_ID: syntax-37
   :END:

   #+NAME:  Statement
   #+begin_quote
   [[https://tc39.es/ecma262/#prod-Statement][Statement]][Yield, Await, Return]:
     [[BlockStatement][BlockStatement]][?Yield, ?Await, ?Return]
     [[VariableStatement][VariableStatement]][?Yield, ?Await]
     [[EmptyStatement][EmptyStatement]]
     [[ExpressionStatement][ExpressionStatement]][?Yield, ?Await]
     [[IfStatement][IfStatement]][?Yield, ?Await, ?Return]
     [[BreakableStatement][BreakableStatement]][?Yield, ?Await, ?Return]
     [[ContinueStatement][ContinueStatement]][?Yield, ?Await]
     [[BreakStatement][BreakStatement]][?Yield, ?Await]
     [+Return][[ReturnStatement][ReturnStatement]][?Yield, ?Await]
     [[WithStatement][WithStatement]][?Yield, ?Await, ?Return]
     [[LabelledStatement][LabelledStatement]][?Yield, ?Await, ?Return]
     [[ThrowStatement][ThrowStatement]][?Yield, ?Await]
     [[TryStatement][TryStatement]][?Yield, ?Await, ?Return]
     [[DebuggerStatement][DebuggerStatement]]
   #+end_quote

   #+begin_src gerbil :noweb-ref statement
     (def statements []) 
     (def (add-statement! p) (push! p statements)) 
     (def (parse-statements) (.begin #t (apply .or CustomStatement statements)))
     (defsyntax (Statement stx)
       (syntax-case stx ()
         ((macro arg) #'((parse-statements) arg))
         (sym #'(parse-statements))))
   #+end_src


   #+NAME: Declaration
   #+begin_quote
   [[Declaration][Declaration]][Yield, Await]:
     [[HoistableDeclaration][HoistableDeclaration]][?Yield, ?Await, ~Default]
     [[ClassDeclaration][ClassDeclaration]][?Yield, ?Await, ~Default]
     [[LexicalDeclaration][LexicalDeclaration]][+In, ?Yield, ?Await]
   #+end_quote

   #+begin_src gerbil :noweb-ref declaration
     (def declarations [FAIL]) 
     (def (add-declaration! p) (push! p declarations)) 
     (def (parse-declarations) (.begin #t (apply .or CustomDeclaration declarations)))
     (defsyntax (Declaration stx)
       (syntax-case stx ()
         ((macro arg) #'((parse-declarations) arg))
         (sym #'(parse-declarations))))


   #+end_src

   #+NAME: HoistableDeclaration
   #+begin_quote
    [[HoistableDeclaration][HoistableDeclaration]][Yield, Await, Default]:
      [[FunctionDeclaration][FunctionDeclaration]][?Yield, ?Await, ?Default]
      [[GeneratorDeclaration][GeneratorDeclaration]][?Yield, ?Await, ?Default]
      [[AsyncFunctionDeclaration][AsyncFunctionDeclaration]][?Yield, ?Await, ?Default]
      [[AsyncGeneratorDeclaration][AsyncGeneratorDeclaration]][?Yield, ?Await, ?Default]
   #+end_quote

[[BreakableStatement][BreakableStatement]][Yield, Await, Return]:
[[IterationStatement][IterationStatement]][?Yield, ?Await, ?Return]
[[SwitchStatement][SwitchStatement]][?Yield, ?Await, ?Return]
** Statement Semantics
   :PROPERTIES:
   :CUSTOM_ID: statement-semantics
   :END:

*** Static Semantics: ContainsDuplicateLabels
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsduplicatelabels
    :END:

  With parameter =labelSet=.

  [[Statement][Statement]]:[[VariableStatement][VariableStatement]]
  [[EmptyStatement][EmptyStatement]]
  [[ExpressionStatement][ExpressionStatement]]
  [[ContinueStatement][ContinueStatement]]
  [[BreakStatement][BreakStatement]]
  [[ReturnStatement][ReturnStatement]]
  [[ThrowStatement][ThrowStatement]]
  [[DebuggerStatement][DebuggerStatement]]

  1. Return false.

*** Static Semantics: ContainsUndefinedBreakTarget
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsundefinedbreaktarget
    :END:

  With parameter =labelSet=.

  [[Statement][Statement]]:[[VariableStatement][VariableStatement]]
  [[EmptyStatement][EmptyStatement]]
  [[ExpressionStatement][ExpressionStatement]]
  [[ContinueStatement][ContinueStatement]]
  [[ReturnStatement][ReturnStatement]]
  [[ThrowStatement][ThrowStatement]]
  [[DebuggerStatement][DebuggerStatement]]

  1. Return false.

*** Static Semantics: ContainsUndefinedContinueTarget
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget
    :END:

  With parameters =iterationSet= and =labelSet=.

  [[Statement][Statement]]:[[VariableStatement][VariableStatement]]
  [[EmptyStatement][EmptyStatement]]
  [[ExpressionStatement][ExpressionStatement]]
  [[BreakStatement][BreakStatement]]
  [[ReturnStatement][ReturnStatement]]
  [[ThrowStatement][ThrowStatement]]
  [[DebuggerStatement][DebuggerStatement]]

  1. Return false.

  [[BreakableStatement][BreakableStatement]]:[[IterationStatement][IterationStatement]]

  1. Let =newIterationSet= be a copy of =iterationSet= with all the
     elements of =labelSet= appended.
  2. Return ContainsUndefinedContinueTarget of
     [[IterationStatement][IterationStatement]]
     with arguments =newIterationSet= and « ».

*** Static Semantics: DeclarationPart
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-declarationpart
    :END:

  [[HoistableDeclaration][HoistableDeclaration]]:[[FunctionDeclaration][FunctionDeclaration]]

  1. Return
     [[FunctionDeclaration][FunctionDeclaration]].

  [[HoistableDeclaration][HoistableDeclaration]]:[[GeneratorDeclaration][GeneratorDeclaration]]

  1. Return
     [[GeneratorDeclaration][GeneratorDeclaration]].

  [[HoistableDeclaration][HoistableDeclaration]]:[[AsyncFunctionDeclaration][AsyncFunctionDeclaration]]

  1. Return
     [[AsyncFunctionDeclaration][AsyncFunctionDeclaration]].

  [[HoistableDeclaration][HoistableDeclaration]]:[[AsyncGeneratorDeclaration][AsyncGeneratorDeclaration]]

  1. Return
     [[AsyncGeneratorDeclaration][AsyncGeneratorDeclaration]].

  [[Declaration][Declaration]]:[[ClassDeclaration][ClassDeclaration]]

  1. Return
     [[ClassDeclaration][ClassDeclaration]].

  [[Declaration][Declaration]]:[[LexicalDeclaration][LexicalDeclaration]]

  1. Return
     [[LexicalDeclaration][LexicalDeclaration]].

*** Static Semantics: VarDeclaredNames
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-vardeclarednames
    :END:

  [[Statement][Statement]]:[[EmptyStatement][EmptyStatement]]
  [[ExpressionStatement][ExpressionStatement]]
  [[ContinueStatement][ContinueStatement]]
  [[BreakStatement][BreakStatement]]
  [[ReturnStatement][ReturnStatement]]
  [[ThrowStatement][ThrowStatement]]
  [[DebuggerStatement][DebuggerStatement]]

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

*** Static Semantics: VarScopedDeclarations
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-varscopeddeclarations
    :END:

  [[Statement][Statement]]:[[EmptyStatement][EmptyStatement]]
  [[ExpressionStatement][ExpressionStatement]]
  [[ContinueStatement][ContinueStatement]]
  [[BreakStatement][BreakStatement]]
  [[ReturnStatement][ReturnStatement]]
  [[ThrowStatement][ThrowStatement]]
  [[DebuggerStatement][DebuggerStatement]]

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

*** Runtime Semantics: LabelledEvaluation
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-labelledevaluation
    :END:

  With parameter =labelSet=.

  [[BreakableStatement][BreakableStatement]]:[[IterationStatement][IterationStatement]]

  1. Let =stmtResult= be LabelledEvaluation of
     [[IterationStatement][IterationStatement]]
     with argument =labelSet=.
  2. If =stmtResult=.[[Type]] is break, then

     1. If =stmtResult=.[[Target]] is empty, then

        1. If =stmtResult=.[[Value]] is empty, set =stmtResult= to
           [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](undefined).
        2. Else, set =stmtResult= to
           [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=stmtResult=.[[Value]]).

  3. Return
     [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=stmtResult=).

  [[BreakableStatement][BreakableStatement]]:[[SwitchStatement][SwitchStatement]]

  1. Let =stmtResult= be the result of evaluating
     [[SwitchStatement][SwitchStatement]].
  2. If =stmtResult=.[[Type]] is break, then

     1. If =stmtResult=.[[Target]] is empty, then

        1. If =stmtResult=.[[Value]] is empty, set =stmtResult= to
           [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](undefined).
        2. Else, set =stmtResult= to
           [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=stmtResult=.[[Value]]).

  3. Return
     [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=stmtResult=).

  Note

  A
  [[BreakableStatement][BreakableStatement]]
  is one that can be exited via an unlabelled
  [[BreakStatement][BreakStatement]].

*** Runtime Semantics: Evaluation
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-evaluation-40
    :END:

  [[HoistableDeclaration][HoistableDeclaration]]:[[GeneratorDeclaration][GeneratorDeclaration]]
  [[AsyncFunctionDeclaration][AsyncFunctionDeclaration]]
  [[AsyncGeneratorDeclaration][AsyncGeneratorDeclaration]]

  1. Return
     [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

  [[HoistableDeclaration][HoistableDeclaration]]:[[FunctionDeclaration][FunctionDeclaration]]

  1. Return the result of evaluating
     [[FunctionDeclaration][FunctionDeclaration]].

  [[BreakableStatement][BreakableStatement]]:[[IterationStatement][IterationStatement]]
  [[SwitchStatement][SwitchStatement]]

  1. Let =newLabelSet= be a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
  2. Return the result of performing LabelledEvaluation of this
     [[BreakableStatement][BreakableStatement]]
     with argument =newLabelSet=.

** Block
   :PROPERTIES:
   :CUSTOM_ID: block
   :END:

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-38
    :END:

 [[BlockStatement][BlockStatement]][Yield,
 Await, Return]:[[Block][Block]][?Yield,
 ?Await, ?Return] [[Block][Block]][Yield,
 Await,
 Return]:{[[StatementList][StatementList]][?Yield,
 ?Await, ?Return]opt}

****  StatementList
     :PROPERTIES:
     :CUSTOM_ID: StatementList
     :END:

    #+begin_quote
    [[StatementList][StatementList]][Yield, Await, Return]:
      [[StatementListItem][StatementListItem]][?Yield, ?Await, ?Return]
      [[StatementList][StatementList]][?Yield, ?Await, ?Return][[StatementListItem][StatementListItem]][?Yield, ?Await, ?Return]
    #+end_quote
    #+begin_src gerbil :noweb-ref statement-list
      (def StatementList (many1 StatementListItem))
    #+end_src

    #+NAME: StatementListItem
    #+begin_quote
     [[StatementListItem][StatementListItem]][Yield, Await, Return]:
      [[Statement][Statement]][?Yield, ?Await, ?Return]
      [[Declaration][Declaration]][?Yield, ?Await]
    #+end_quote
    
    #+begin_src gerbil :noweb-ref statement-list-item
      (def StatementListItem (.begin #!void (.or Declaration Statement (js-syntax-error))))
    #+end_src

*** Static Semantics: Early Errors
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-early-errors-11
    :END:

  [[Block][Block]]:{[[StatementList][StatementList]]}

  - It is a Syntax Error if the LexicallyDeclaredNames of
    [[StatementList][StatementList]]
    contains any duplicate entries.
  - It is a Syntax Error if any element of the LexicallyDeclaredNames of
    [[StatementList][StatementList]] also
    occurs in the VarDeclaredNames of
    [[StatementList][StatementList]].

*** Static Semantics: ContainsDuplicateLabels
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsduplicatelabels-1
    :END:

  With parameter =labelSet=.

  [[Block][Block]]:{}

  1. Return false.

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =hasDuplicates= be ContainsDuplicateLabels of
     [[StatementList][StatementList]] with
     argument =labelSet=.
  2. If =hasDuplicates= is true, return true.
  3. Return ContainsDuplicateLabels of
     [[StatementListItem][StatementListItem]]
     with argument =labelSet=.

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. Return false.

*** Static Semantics: ContainsUndefinedBreakTarget
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-1
    :END:

  With parameter =labelSet=.

  [[Block][Block]]:{}

  1. Return false.

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of
     [[StatementList][StatementList]] with
     argument =labelSet=.
  2. If =hasUndefinedLabels= is true, return true.
  3. Return ContainsUndefinedBreakTarget of
     [[StatementListItem][StatementListItem]]
     with argument =labelSet=.

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. Return false.

*** Static Semantics: ContainsUndefinedContinueTarget
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-1
    :END:

  With parameters =iterationSet= and =labelSet=.

  [[Block][Block]]:{}

  1. Return false.

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of
     [[StatementList][StatementList]] with
     arguments =iterationSet= and « ».
  2. If =hasUndefinedLabels= is true, return true.
  3. Return ContainsUndefinedContinueTarget of
     [[StatementListItem][StatementListItem]]
     with arguments =iterationSet= and « ».

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. Return false.

*** Static Semantics: LexicallyDeclaredNames
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-lexicallydeclarednames
    :END:

  [[Block][Block]]:{}

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =names= be LexicallyDeclaredNames of
     [[StatementList][StatementList]].
  2. Append to =names= the elements of the LexicallyDeclaredNames of
     [[StatementListItem][StatementListItem]].
  3. Return =names=.

  [[StatementListItem][StatementListItem]]:[[Statement][Statement]]

  1. If [[Statement][Statement]] is
     [[Statement][Statement]]:[[LabelledStatement][LabelledStatement]]
     , return LexicallyDeclaredNames of
     [[LabelledStatement][LabelledStatement]].
  2. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. Return the BoundNames of
     [[Declaration][Declaration]].

*** Static Semantics: LexicallyScopedDeclarations
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-lexicallyscopeddeclarations
    :END:

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =declarations= be LexicallyScopedDeclarations of
     [[StatementList][StatementList]].
  2. Append to =declarations= the elements of the
     LexicallyScopedDeclarations of
     [[StatementListItem][StatementListItem]].
  3. Return =declarations=.

  [[StatementListItem][StatementListItem]]:[[Statement][Statement]]

  1. If [[Statement][Statement]] is
     [[Statement][Statement]]:[[LabelledStatement][LabelledStatement]]
     , return LexicallyScopedDeclarations of
     [[LabelledStatement][LabelledStatement]].
  2. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. Return a new
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
     containing DeclarationPart of
     [[Declaration][Declaration]].

*** Static Semantics: TopLevelLexicallyDeclaredNames
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-toplevellexicallydeclarednames
    :END:

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =names= be TopLevelLexicallyDeclaredNames of
     [[StatementList][StatementList]].
  2. Append to =names= the elements of the TopLevelLexicallyDeclaredNames
     of
     [[StatementListItem][StatementListItem]].
  3. Return =names=.

  [[StatementListItem][StatementListItem]]:[[Statement][Statement]]

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. If [[Declaration][Declaration]] is
     [[Declaration][Declaration]]:[[HoistableDeclaration][HoistableDeclaration]]
     , then

     1. Return « ».

  2. Return the BoundNames of
     [[Declaration][Declaration]].

  Note

  At the top level of a function, or script, function declarations are
  treated like var declarations rather than like lexical declarations.

*** Static Semantics: TopLevelLexicallyScopedDeclarations
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-toplevellexicallyscopeddeclarations
    :END:

  [[Block][Block]]:{}

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =declarations= be TopLevelLexicallyScopedDeclarations of
     [[StatementList][StatementList]].
  2. Append to =declarations= the elements of the
     TopLevelLexicallyScopedDeclarations of
     [[StatementListItem][StatementListItem]].
  3. Return =declarations=.

  [[StatementListItem][StatementListItem]]:[[Statement][Statement]]

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. If [[Declaration][Declaration]] is
     [[Declaration][Declaration]]:[[HoistableDeclaration][HoistableDeclaration]]
     , then

     1. Return « ».

  2. Return a new
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
     containing
     [[Declaration][Declaration]].

*** Static Semantics: TopLevelVarDeclaredNames
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-toplevelvardeclarednames
    :END:

  [[Block][Block]]:{}

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =names= be TopLevelVarDeclaredNames of
     [[StatementList][StatementList]].
  2. Append to =names= the elements of the TopLevelVarDeclaredNames of
     [[StatementListItem][StatementListItem]].
  3. Return =names=.

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. If [[Declaration][Declaration]] is
     [[Declaration][Declaration]]:[[HoistableDeclaration][HoistableDeclaration]]
     , then

     1. Return the BoundNames of
        [[HoistableDeclaration][HoistableDeclaration]].

  2. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementListItem][StatementListItem]]:[[Statement][Statement]]

  1. If [[Statement][Statement]] is
     [[Statement][Statement]]:[[LabelledStatement][LabelledStatement]]
     , return TopLevelVarDeclaredNames of
     [[Statement][Statement]].
  2. Return VarDeclaredNames of
     [[Statement][Statement]].

  Note

  At the top level of a function or script, inner function declarations
  are treated like var declarations.

*** Static Semantics: TopLevelVarScopedDeclarations
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-toplevelvarscopeddeclarations
    :END:

  [[Block][Block]]:{}

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =declarations= be TopLevelVarScopedDeclarations of
     [[StatementList][StatementList]].
  2. Append to =declarations= the elements of the
     TopLevelVarScopedDeclarations of
     [[StatementListItem][StatementListItem]].
  3. Return =declarations=.

  [[StatementListItem][StatementListItem]]:[[Statement][Statement]]

  1. If [[Statement][Statement]] is
     [[Statement][Statement]]:[[LabelledStatement][LabelledStatement]]
     , return TopLevelVarScopedDeclarations of
     [[Statement][Statement]].
  2. Return VarScopedDeclarations of
     [[Statement][Statement]].

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. If [[Declaration][Declaration]] is
     [[Declaration][Declaration]]:[[HoistableDeclaration][HoistableDeclaration]]
     , then

     1. Let =declaration= be DeclarationPart of
        [[HoistableDeclaration][HoistableDeclaration]].
     2. Return « =declaration= ».

  2. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

*** Static Semantics: VarDeclaredNames
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-vardeclarednames-1
    :END:

  [[Block][Block]]:{}

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =names= be VarDeclaredNames of
     [[StatementList][StatementList]].
  2. Append to =names= the elements of the VarDeclaredNames of
     [[StatementListItem][StatementListItem]].
  3. Return =names=.

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

*** Static Semantics: VarScopedDeclarations
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-varscopeddeclarations-1
    :END:

  [[Block][Block]]:{}

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =declarations= be VarScopedDeclarations of
     [[StatementList][StatementList]].
  2. Append to =declarations= the elements of the VarScopedDeclarations of
     [[StatementListItem][StatementListItem]].
  3. Return =declarations=.

  [[StatementListItem][StatementListItem]]:[[Declaration][Declaration]]

  1. Return a new empty
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

*** Runtime Semantics: Evaluation
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-evaluation-41
    :END:

  [[Block][Block]]:{}

  1. Return
     [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

  [[Block][Block]]:{[[StatementList][StatementList]]}

  1. Let =oldEnv= be the
     [[https://tc39.es/ecma262/#running-execution-context][running
     execution context]]'s LexicalEnvironment.
  2. Let =blockEnv= be
     [[https://tc39.es/ecma262/#sec-newdeclarativeenvironment][NewDeclarativeEnvironment]](=oldEnv=).
  3. Perform
     [[https://tc39.es/ecma262/#sec-blockdeclarationinstantiation][BlockDeclarationInstantiation]]([[StatementList][StatementList]],
     =blockEnv=).
  4. Set the [[https://tc39.es/ecma262/#running-execution-context][running
     execution context]]'s LexicalEnvironment to =blockEnv=.
  5. Let =blockValue= be the result of evaluating
     [[StatementList][StatementList]].
  6. Set the [[https://tc39.es/ecma262/#running-execution-context][running
     execution context]]'s LexicalEnvironment to =oldEnv=.
  7. Return =blockValue=.

  Note 1

  No matter how control leaves the
  [[Block][Block]] the LexicalEnvironment is
  always restored to its former state.

  [[StatementList][StatementList]]:[[StatementList][StatementList]][[StatementListItem][StatementListItem]]

  1. Let =sl= be the result of evaluating
     [[StatementList][StatementList]].
  2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=sl=).
  3. Let =s= be the result of evaluating
     [[StatementListItem][StatementListItem]].
  4. Return
     [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=s=,
     =sl=)).

  Note 2

  The value of a
  [[StatementList][StatementList]] is the
  value of the last value-producing item in the
  [[StatementList][StatementList]]. For
  example, the following calls to the =eval= function all return the value
  1:

  #+BEGIN_EXAMPLE
    eval("1;;;;;")
    eval("1;{}")
    eval("1;var a;")
  #+END_EXAMPLE

*** Runtime Semantics: BlockDeclarationInstantiation ( =code=,
  =env= )
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-blockdeclarationinstantiation-code-env
    :END:

  Note

  When a [[Block][Block]] or
  [[CaseBlock][CaseBlock]] is evaluated a
  new declarative
  [[https://tc39.es/ecma262/#sec-environment-records][Environment Record]]
  is created and bindings for each block scoped variable, constant,
  function, or class declared in the block are instantiated in the
  [[https://tc39.es/ecma262/#sec-environment-records][Environment
  Record]].

  BlockDeclarationInstantiation is performed as follows using arguments
  =code= and =env=. =code= is the
  [[https://tc39.es/ecma262/#sec-syntactic-grammar][Parse Node]]
  corresponding to the body of the block. =env= is the
  [[https://tc39.es/ecma262/#sec-lexical-environments][Lexical
  Environment]] in which bindings are to be created.

  1. Let =envRec= be =env='s
     [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]].
  2. [[https://tc39.es/ecma262/#assert][Assert]]: =envRec= is a
     declarative
     [[https://tc39.es/ecma262/#sec-environment-records][Environment
     Record]].
  3. Let =declarations= be the LexicallyScopedDeclarations of =code=.
  4. For each element =d= in =declarations=, do

     1. For each element =dn= of the BoundNames of =d=, do

        1. If IsConstantDeclaration of =d= is true, then

           1. Perform ! =envRec=.CreateImmutableBinding(=dn=, true).

        2. Else,

           1. Perform ! =envRec=.CreateMutableBinding(=dn=, false).

     2. If =d= is a
        [[FunctionDeclaration][FunctionDeclaration]],
        a
        [[GeneratorDeclaration][GeneratorDeclaration]],
        an
        [[AsyncFunctionDeclaration][AsyncFunctionDeclaration]],
        or an
        [[AsyncGeneratorDeclaration][AsyncGeneratorDeclaration]],
        then

        1. Let =fn= be the sole element of the BoundNames of =d=.
        2. Let =fo= be InstantiateFunctionObject of =d= with argument
           =env=.
        3. Perform =envRec=.InitializeBinding(=fn=, =fo=).

** Declarations and the Variable Statement
   :PROPERTIES:
   :CUSTOM_ID: declarations-and-the-variable-statement
   :END:

*** Let and Const Declarations
    :PROPERTIES:
    :CUSTOM_ID: let-and-const-declarations
    :END:

  Note

  =let= and =const= declarations define variables that are scoped to the
  [[https://tc39.es/ecma262/#running-execution-context][running execution
  context]]'s LexicalEnvironment. The variables are created when their
  containing [[https://tc39.es/ecma262/#sec-lexical-environments][Lexical
  Environment]] is instantiated but may not be accessed in any way until
  the variable's
  [[LexicalBinding][LexicalBinding]] is
  evaluated. A variable defined by a
  [[LexicalBinding][LexicalBinding]] with an
  [[Initializer][Initializer]] is assigned
  the value of its
  [[Initializer][Initializer]]'s
  [[AssignmentExpression][AssignmentExpression]]
  when the
  [[LexicalBinding][LexicalBinding]] is
  evaluated, not when the variable is created. If a
  [[LexicalBinding][LexicalBinding]] in a
  =let= declaration does not have an
  [[Initializer][Initializer]] the variable
  is assigned the value undefined when the
  [[LexicalBinding][LexicalBinding]] is
  evaluated.

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-39
     :END:

  [[LexicalDeclaration][LexicalDeclaration]][In,
  Yield,
  Await]:[[LetOrConst][LetOrConst]][[BindingList][BindingList]][?In,
  ?Yield, ?Await];
  [[LetOrConst][LetOrConst]]:let const
  [[BindingList][BindingList]][In, Yield,
  Await]:[[LexicalBinding][LexicalBinding]][?In,
  ?Yield, ?Await]
  [[BindingList][BindingList]][?In, ?Yield,
  ?Await],[[LexicalBinding][LexicalBinding]][?In,
  ?Yield, ?Await]
  [[LexicalBinding][LexicalBinding]][In,
  Yield,
  Await]:[[BindingIdentifier][BindingIdentifier]][?Yield,
  ?Await][[Initializer][Initializer]][?In,
  ?Yield, ?Await]opt
  [[BindingPattern][BindingPattern]][?Yield,
  ?Await][[Initializer][Initializer]][?In,
  ?Yield, ?Await]
**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-12
     :END:

   [[LexicalDeclaration][LexicalDeclaration]]:[[LetOrConst][LetOrConst]][[BindingList][BindingList]];

   - It is a Syntax Error if the BoundNames of
     [[BindingList][BindingList]] contains
     "let".
   - It is a Syntax Error if the BoundNames of
     [[BindingList][BindingList]] contains
     any duplicate entries.

   [[LexicalBinding][LexicalBinding]]:[[BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]opt

   - It is a Syntax Error if
     [[Initializer][Initializer]] is not
     present and IsConstantDeclaration of the
     [[LexicalDeclaration][LexicalDeclaration]]
     containing this
     [[LexicalBinding][LexicalBinding]] is
     true.

**** Static Semantics: BoundNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-boundnames-1
     :END:

   [[LexicalDeclaration][LexicalDeclaration]]:[[LetOrConst][LetOrConst]][[BindingList][BindingList]];

   1. Return the BoundNames of
      [[BindingList][BindingList]].

   [[BindingList][BindingList]]:[[BindingList][BindingList]],[[LexicalBinding][LexicalBinding]]

   1. Let =names= be the BoundNames of
      [[BindingList][BindingList]].
   2. Append to =names= the elements of the BoundNames of
      [[LexicalBinding][LexicalBinding]].
   3. Return =names=.

   [[LexicalBinding][LexicalBinding]]:[[BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]opt

   1. Return the BoundNames of
      [[BindingIdentifier][BindingIdentifier]].

   [[LexicalBinding][LexicalBinding]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]

   1. Return the BoundNames of
      [[BindingPattern][BindingPattern]].

**** Static Semantics: IsConstantDeclaration
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isconstantdeclaration
     :END:

   [[LexicalDeclaration][LexicalDeclaration]]:[[LetOrConst][LetOrConst]][[BindingList][BindingList]];

   1. Return IsConstantDeclaration of
      [[LetOrConst][LetOrConst]].

   [[LetOrConst][LetOrConst]]:let

   1. Return false.

   [[LetOrConst][LetOrConst]]:const

   1. Return true.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-42
     :END:

   [[LexicalDeclaration][LexicalDeclaration]]:[[LetOrConst][LetOrConst]][[BindingList][BindingList]];

   1. Let =next= be the result of evaluating
      [[BindingList][BindingList]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
   3. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[BindingList][BindingList]]:[[BindingList][BindingList]],[[LexicalBinding][LexicalBinding]]

   1. Let =next= be the result of evaluating
      [[BindingList][BindingList]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
   3. Return the result of evaluating
      [[LexicalBinding][LexicalBinding]].

   [[LexicalBinding][LexicalBinding]]:[[BindingIdentifier][BindingIdentifier]]

   1. Let =lhs= be
      [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](StringValue
      of
      [[BindingIdentifier][BindingIdentifier]]).
   2. Return
      [[https://tc39.es/ecma262/#sec-initializereferencedbinding][InitializeReferencedBinding]](=lhs=,
      undefined).

   Note

   A [[https://tc39.es/ecma262/#sec-static-semantic-rules][static
   semantics]] rule ensures that this form of
   [[LexicalBinding][LexicalBinding]] never
   occurs in a =const= declaration.

   [[LexicalBinding][LexicalBinding]]:[[BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]

   1. Let =bindingId= be StringValue of
      [[BindingIdentifier][BindingIdentifier]].
   2. Let =lhs= be
      [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=bindingId=).
   3. If
      [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Initializer][Initializer]])
      is true, then

      1. Let =value= be NamedEvaluation of
         [[Initializer][Initializer]] with
         argument =bindingId=.

   4. Else,

      1. Let =rhs= be the result of evaluating
         [[Initializer][Initializer]].
      2. Let =value= be
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rhs=).

   5. Return
      [[https://tc39.es/ecma262/#sec-initializereferencedbinding][InitializeReferencedBinding]](=lhs=,
      =value=).

   [[LexicalBinding][LexicalBinding]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]

   1. Let =rhs= be the result of evaluating
      [[Initializer][Initializer]].
   2. Let =value= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rhs=).
   3. Let =env= be the
      [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment.
   4. Return the result of performing BindingInitialization for
      [[BindingPattern][BindingPattern]]
      using =value= and =env= as the arguments.

*** Variable Statement
    :PROPERTIES:
    :CUSTOM_ID: variable-statement
    :END:

  Note

  A =var= statement declares variables that are scoped to the
  [[https://tc39.es/ecma262/#running-execution-context][running execution
  context]]'s VariableEnvironment. Var variables are created when their
  containing [[https://tc39.es/ecma262/#sec-lexical-environments][Lexical
  Environment]] is instantiated and are initialized to undefined when
  created. Within the scope of any VariableEnvironment a common
  [[BindingIdentifier][BindingIdentifier]]
  may appear in more than one
  [[VariableDeclaration][VariableDeclaration]]
  but those declarations collectively define only one variable. A variable
  defined by a
  [[VariableDeclaration][VariableDeclaration]]
  with an [[Initializer][Initializer]] is
  assigned the value of its
  [[Initializer][Initializer]]'s
  [[AssignmentExpression][AssignmentExpression]]
  when the
  [[VariableDeclaration][VariableDeclaration]]
  is executed, not when the variable is created.

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-40
     :END:

  [[VariableStatement][VariableStatement]][Yield,
  Await]:var[[VariableDeclarationList][VariableDeclarationList]][+In,
  ?Yield, ?Await];
  [[VariableDeclarationList][VariableDeclarationList]][In,
  Yield,
  Await]:[[VariableDeclaration][VariableDeclaration]][?In,
  ?Yield, ?Await]
  [[VariableDeclarationList][VariableDeclarationList]][?In,
  ?Yield,
  ?Await],[[VariableDeclaration][VariableDeclaration]][?In,
  ?Yield, ?Await]
  [[VariableDeclaration][VariableDeclaration]][In,
  Yield,
  Await]:[[BindingIdentifier][BindingIdentifier]][?Yield,
  ?Await][[Initializer][Initializer]][?In,
  ?Yield, ?Await]opt
  [[BindingPattern][BindingPattern]][?Yield,
  ?Await][[Initializer][Initializer]][?In,
  ?Yield, ?Await]
**** Static Semantics: BoundNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-boundnames-2
     :END:

   [[VariableDeclarationList][VariableDeclarationList]]:[[VariableDeclarationList][VariableDeclarationList]],[[VariableDeclaration][VariableDeclaration]]

   1. Let =names= be BoundNames of
      [[VariableDeclarationList][VariableDeclarationList]].
   2. Append to =names= the elements of BoundNames of
      [[VariableDeclaration][VariableDeclaration]].
   3. Return =names=.

   [[VariableDeclaration][VariableDeclaration]]:[[BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]opt

   1. Return the BoundNames of
      [[BindingIdentifier][BindingIdentifier]].

   [[VariableDeclaration][VariableDeclaration]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]

   1. Return the BoundNames of
      [[BindingPattern][BindingPattern]].

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-2
     :END:

   [[VariableStatement][VariableStatement]]:var[[VariableDeclarationList][VariableDeclarationList]];

   1. Return BoundNames of
      [[VariableDeclarationList][VariableDeclarationList]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-2
     :END:

   [[VariableDeclarationList][VariableDeclarationList]]:[[VariableDeclaration][VariableDeclaration]]

   1. Return a new
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing
      [[VariableDeclaration][VariableDeclaration]].

   [[VariableDeclarationList][VariableDeclarationList]]:[[VariableDeclarationList][VariableDeclarationList]],[[VariableDeclaration][VariableDeclaration]]

   1. Let =declarations= be VarScopedDeclarations of
      [[VariableDeclarationList][VariableDeclarationList]].
   2. Append
      [[VariableDeclaration][VariableDeclaration]]
      to =declarations=.
   3. Return =declarations=.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-43
     :END:

   [[VariableStatement][VariableStatement]]:var[[VariableDeclarationList][VariableDeclarationList]];

   1. Let =next= be the result of evaluating
      [[VariableDeclarationList][VariableDeclarationList]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
   3. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[VariableDeclarationList][VariableDeclarationList]]:[[VariableDeclarationList][VariableDeclarationList]],[[VariableDeclaration][VariableDeclaration]]

   1. Let =next= be the result of evaluating
      [[VariableDeclarationList][VariableDeclarationList]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
   3. Return the result of evaluating
      [[VariableDeclaration][VariableDeclaration]].

   [[VariableDeclaration][VariableDeclaration]]:[[BindingIdentifier][BindingIdentifier]]

   1. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[VariableDeclaration][VariableDeclaration]]:[[BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]

   1. Let =bindingId= be StringValue of
      [[BindingIdentifier][BindingIdentifier]].
   2. Let =lhs= be
      ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=bindingId=).
   3. If
      [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Initializer][Initializer]])
      is true, then

      1. Let =value= be NamedEvaluation of
         [[Initializer][Initializer]] with
         argument =bindingId=.

   4. Else,

      1. Let =rhs= be the result of evaluating
         [[Initializer][Initializer]].
      2. Let =value= be
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rhs=).

   5. Return ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=,
      =value=).

   Note

   If a
   [[VariableDeclaration][VariableDeclaration]]
   is nested within a with statement and the
   [[BindingIdentifier][BindingIdentifier]]
   in the
   [[VariableDeclaration][VariableDeclaration]]
   is the same as a [[https://tc39.es/ecma262/#property-name][property
   name]] of the binding object of the with statement's object
   [[https://tc39.es/ecma262/#sec-environment-records][Environment
   Record]], then step 6 will assign =value= to the property instead of
   assigning to the VariableEnvironment binding of the
   [[Identifier][Identifier]].

   [[VariableDeclaration][VariableDeclaration]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]

   1. Let =rhs= be the result of evaluating
      [[Initializer][Initializer]].
   2. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rhs=).
   3. Return the result of performing BindingInitialization for
      [[BindingPattern][BindingPattern]]
      passing =rval= and undefined as arguments.

*** Destructuring Binding Patterns
    :PROPERTIES:
    :CUSTOM_ID: destructuring-binding-patterns
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-41
     :END:

  [[BindingPattern][BindingPattern]][Yield,
  Await]:[[ObjectBindingPattern][ObjectBindingPattern]][?Yield,
  ?Await]
  [[ArrayBindingPattern][ArrayBindingPattern]][?Yield,
  ?Await]
  [[ObjectBindingPattern][ObjectBindingPattern]][Yield,
  Await]:{}
  {[[BindingRestProperty][BindingRestProperty]][?Yield,
  ?Await]}
  {[[BindingPropertyList][BindingPropertyList]][?Yield,
  ?Await]}
  {[[BindingPropertyList][BindingPropertyList]][?Yield,
  ?Await],[[BindingRestProperty][BindingRestProperty]][?Yield,
  ?Await]opt}
  [[ArrayBindingPattern][ArrayBindingPattern]][Yield,
  Await]:[[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]][?Yield,
  ?Await]opt]
  [[[BindingElementList][BindingElementList]][?Yield,
  ?Await]]
  [[[BindingElementList][BindingElementList]][?Yield,
  ?Await],[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]][?Yield,
  ?Await]opt]
  [[BindingRestProperty][BindingRestProperty]][Yield,
  Await]:...[[BindingIdentifier][BindingIdentifier]][?Yield,
  ?Await]
  [[BindingPropertyList][BindingPropertyList]][Yield,
  Await]:[[BindingProperty][BindingProperty]][?Yield,
  ?Await]
  [[BindingPropertyList][BindingPropertyList]][?Yield,
  ?Await],[[BindingProperty][BindingProperty]][?Yield,
  ?Await]
  [[BindingElementList][BindingElementList]][Yield,
  Await]:[[BindingElisionElement][BindingElisionElement]][?Yield,
  ?Await]
  [[BindingElementList][BindingElementList]][?Yield,
  ?Await],[[BindingElisionElement][BindingElisionElement]][?Yield,
  ?Await]
  [[BindingElisionElement][BindingElisionElement]][Yield,
  Await]:[[Elision][Elision]]opt[[BindingElement][BindingElement]][?Yield,
  ?Await]
  [[BindingProperty][BindingProperty]][Yield,
  Await]:[[SingleNameBinding][SingleNameBinding]][?Yield,
  ?Await]
  [[PropertyName][PropertyName]][?Yield,
  ?Await]:[[BindingElement][BindingElement]][?Yield,
  ?Await]

***** BindingElement
      :PROPERTIES:
      :CUSTOM_ID: BindingElement
      :END:

   [[BindingElement][BindingElement]][Yield, Await]: 
     [[SingleNameBinding][SingleNameBinding]][?Yield, ?Await]
     [[BindingPattern][BindingPattern]][?Yield, ?Await][[Initializer][Initializer]][+In, ?Yield, ?Await]opt

     #+begin_src gerbil :noweb-ref binding-element
       (defstruct (binding-element statement) (binding) transparent: #t)
       (def binding-elements [SingleNameBinding]) 
       (def (add-binding-element! p) (push! p binding-elements)) 
       (def (parse-binding-elements)
         (.let* (b (.begin #t (apply .or binding-elements)))
          (return (binding-element b))))
       (defsyntax (BindingElement stx)
         (syntax-case stx ()
           ((macro arg) #'((parse-binding-elements) arg))
           (sym #'(parse-binding-elements))))
     #+end_src


***** SingleNameBinding
      :PROPERTIES:
      :CUSTOM_ID: SingleNameBinding
      :END:
      
  #+begin_quote
   [[SingleNameBinding][SingleNameBinding]][Yield, Await]:
     [[file:expressions.org::#BindingIdentifier][BindingIdentifier]][?Yield, ?Await] [[Initializer][Initializer]][+In, ?Yield, ?Await]opt
      #+end_quote

  #+begin_src gerbil :noweb-ref single-name-binding
    (defstruct (single-name-binding statement) (identifier initializer)
      transparent: #t)

    (def SingleNameBinding
      (.let* (id BindingIdentifier) (return (single-name-binding id #f))))
  #+end_src

   [[BindingRestElement][BindingRestElement]][Yield,
   Await]:...[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][?Yield,
   ?Await]
   ...[[BindingPattern][BindingPattern]][?Yield,
   ?Await]
**** Static Semantics: BoundNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-boundnames-3
     :END:

   [[ObjectBindingPattern][ObjectBindingPattern]]:{}

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[Elision][Elision]]opt]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]]]

   1. Return the BoundNames of
      [[BindingRestElement][BindingRestElement]].

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]],[[Elision][Elision]]opt]

   1. Return the BoundNames of
      [[BindingElementList][BindingElementList]].

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]],[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]]]

   1. Let =names= be BoundNames of
      [[BindingElementList][BindingElementList]].
   2. Append to =names= the elements of BoundNames of
      [[BindingRestElement][BindingRestElement]].
   3. Return =names=.

   [[BindingPropertyList][BindingPropertyList]]:[[BindingPropertyList][BindingPropertyList]],[[BindingProperty][BindingProperty]]

   1. Let =names= be BoundNames of
      [[BindingPropertyList][BindingPropertyList]].
   2. Append to =names= the elements of BoundNames of
      [[BindingProperty][BindingProperty]].
   3. Return =names=.

   [[BindingElementList][BindingElementList]]:[[BindingElementList][BindingElementList]],[[BindingElisionElement][BindingElisionElement]]

   1. Let =names= be BoundNames of
      [[BindingElementList][BindingElementList]].
   2. Append to =names= the elements of BoundNames of
      [[BindingElisionElement][BindingElisionElement]].
   3. Return =names=.

   [[BindingElisionElement][BindingElisionElement]]:[[Elision][Elision]]opt[[BindingElement][BindingElement]]

   1. Return BoundNames of
      [[BindingElement][BindingElement]].

   [[BindingProperty][BindingProperty]]:[[PropertyName][PropertyName]]:[[BindingElement][BindingElement]]

   1. Return the BoundNames of
      [[BindingElement][BindingElement]].

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]opt

   1. Return the BoundNames of
      [[file:expressions.org::#BindingIdentifier][BindingIdentifier]].

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]opt

   1. Return the BoundNames of
      [[BindingPattern][BindingPattern]].

**** Static Semantics: ContainsExpression
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsexpression
     :END:

   [[ObjectBindingPattern][ObjectBindingPattern]]:{}

   1. Return false.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[Elision][Elision]]opt]

   1. Return false.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]]]

   1. Return ContainsExpression of
      [[BindingRestElement][BindingRestElement]].

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]],[[Elision][Elision]]opt]

   1. Return ContainsExpression of
      [[BindingElementList][BindingElementList]].

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]],[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]]]

   1. Let =has= be ContainsExpression of
      [[BindingElementList][BindingElementList]].
   2. If =has= is true, return true.
   3. Return ContainsExpression of
      [[BindingRestElement][BindingRestElement]].

   [[BindingPropertyList][BindingPropertyList]]:[[BindingPropertyList][BindingPropertyList]],[[BindingProperty][BindingProperty]]

   1. Let =has= be ContainsExpression of
      [[BindingPropertyList][BindingPropertyList]].
   2. If =has= is true, return true.
   3. Return ContainsExpression of
      [[BindingProperty][BindingProperty]].

   [[BindingElementList][BindingElementList]]:[[BindingElementList][BindingElementList]],[[BindingElisionElement][BindingElisionElement]]

   1. Let =has= be ContainsExpression of
      [[BindingElementList][BindingElementList]].
   2. If =has= is true, return true.
   3. Return ContainsExpression of
      [[BindingElisionElement][BindingElisionElement]].

   [[BindingElisionElement][BindingElisionElement]]:[[Elision][Elision]]opt[[BindingElement][BindingElement]]

   1. Return ContainsExpression of
      [[BindingElement][BindingElement]].

   [[BindingProperty][BindingProperty]]:[[PropertyName][PropertyName]]:[[BindingElement][BindingElement]]

   1. Let =has= be IsComputedPropertyKey of
      [[PropertyName][PropertyName]].
   2. If =has= is true, return true.
   3. Return ContainsExpression of
      [[BindingElement][BindingElement]].

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]

   1. Return true.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Return false.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]

   1. Return true.

   [[BindingRestElement][BindingRestElement]]:...[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Return false.

   [[BindingRestElement][BindingRestElement]]:...[[BindingPattern][BindingPattern]]

   1. Return ContainsExpression of
      [[BindingPattern][BindingPattern]].

**** Static Semantics: HasInitializer
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-hasinitializer
     :END:

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]]

   1. Return false.

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]

   1. Return true.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Return false.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]

   1. Return true.

**** Static Semantics: IsSimpleParameterList
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-issimpleparameterlist
     :END:

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]]

   1. Return false.

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]

   1. Return false.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Return true.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]

   1. Return false.

**** Runtime Semantics: BindingInitialization
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-bindinginitialization-1
     :END:

   With parameters =value= and =environment=.

   Note

   When undefined is passed for =environment= it indicates that a
   [[https://tc39.es/ecma262/#sec-putvalue][PutValue]] operation should be
   used to assign the initialization value. This is the case for formal
   parameter lists of non-strict functions. In that case the formal
   parameter bindings are preinitialized in order to deal with the
   possibility of multiple parameters with the same name.

   [[BindingPattern][BindingPattern]]:[[ObjectBindingPattern][ObjectBindingPattern]]

   1. Perform
      ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=value=).
   2. Return the result of performing BindingInitialization for
      [[ObjectBindingPattern][ObjectBindingPattern]]
      using =value= and =environment= as arguments.

   [[BindingPattern][BindingPattern]]:[[ArrayBindingPattern][ArrayBindingPattern]]

   1. Let =iteratorRecord= be
      ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=value=).
   2. Let =result= be IteratorBindingInitialization of
      [[ArrayBindingPattern][ArrayBindingPattern]]
      with arguments =iteratorRecord= and =environment=.
   3. If =iteratorRecord=.[[Done]] is false, return
      ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
      =result=).
   4. Return =result=.

   [[ObjectBindingPattern][ObjectBindingPattern]]:{}

   1. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[ObjectBindingPattern][ObjectBindingPattern]]:{[[BindingPropertyList][BindingPropertyList]]}
   {[[BindingPropertyList][BindingPropertyList]],}

   1. Perform ? PropertyBindingInitialization for
      [[BindingPropertyList][BindingPropertyList]]
      using =value= and =environment= as the arguments.
   2. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[ObjectBindingPattern][ObjectBindingPattern]]:{[[BindingRestProperty][BindingRestProperty]]}

   1. Let =excludedNames= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   2. Return the result of performing RestBindingInitialization of
      [[BindingRestProperty][BindingRestProperty]]
      with =value=, =environment=, and =excludedNames= as the arguments.

   [[ObjectBindingPattern][ObjectBindingPattern]]:{[[BindingPropertyList][BindingPropertyList]],[[BindingRestProperty][BindingRestProperty]]}

   1. Let =excludedNames= be ? PropertyBindingInitialization of
      [[BindingPropertyList][BindingPropertyList]]
      with arguments =value= and =environment=.
   2. Return the result of performing RestBindingInitialization of
      [[BindingRestProperty][BindingRestProperty]]
      with arguments =value=, =environment=, and =excludedNames=.

**** Runtime Semantics: PropertyBindingInitialization
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-propertybindinginitialization
     :END:

   With parameters =value= and =environment=.

   Note

   These collect a list of all bound property names rather than just empty
   completion.

   [[BindingPropertyList][BindingPropertyList]]:[[BindingPropertyList][BindingPropertyList]],[[BindingProperty][BindingProperty]]

   1. Let =boundNames= be ? PropertyBindingInitialization of
      [[BindingPropertyList][BindingPropertyList]]
      with arguments =value= and =environment=.
   2. Let =nextNames= be ? PropertyBindingInitialization of
      [[BindingProperty][BindingProperty]]
      with arguments =value= and =environment=.
   3. Append each item in =nextNames= to the end of =boundNames=.
   4. Return =boundNames=.

   [[BindingProperty][BindingProperty]]:[[SingleNameBinding][SingleNameBinding]]

   1. Let =name= be the string that is the only element of BoundNames of
      [[SingleNameBinding][SingleNameBinding]].
   2. Perform ? KeyedBindingInitialization for
      [[SingleNameBinding][SingleNameBinding]]
      using =value=, =environment=, and =name= as the arguments.
   3. Return a new
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing =name=.

   [[BindingProperty][BindingProperty]]:[[PropertyName][PropertyName]]:[[BindingElement][BindingElement]]

   1. Let =P= be the result of evaluating
      [[PropertyName][PropertyName]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=P=).
   3. Perform ? KeyedBindingInitialization of
      [[BindingElement][BindingElement]] with
      =value=, =environment=, and =P= as the arguments.
   4. Return a new
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing =P=.

**** Runtime Semantics: RestBindingInitialization
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-restbindinginitialization
     :END:

   With parameters =value=, =environment=, and =excludedNames=.

   [[BindingRestProperty][BindingRestProperty]]:...[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Let =lhs= be
      ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](StringValue
      of
      [[file:expressions.org::#BindingIdentifier][BindingIdentifier]],
      =environment=).
   2. Let =restObj= be
      [[https://tc39.es/ecma262/#sec-objectcreate][ObjectCreate]](%Object.prototype%).
   3. Perform
      ? [[https://tc39.es/ecma262/#sec-copydataproperties][CopyDataProperties]](=restObj=,
      =value=, =excludedNames=).
   4. If =environment= is undefined, return
      [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=,
      =restObj=).
   5. Return
      [[https://tc39.es/ecma262/#sec-initializereferencedbinding][InitializeReferencedBinding]](=lhs=,
      =restObj=).

**** Runtime Semantics: IteratorBindingInitialization
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-iteratorbindinginitialization
     :END:

   With parameters =iteratorRecord= and =environment=.

   Note

   When undefined is passed for =environment= it indicates that a
   [[https://tc39.es/ecma262/#sec-putvalue][PutValue]] operation should be
   used to assign the initialization value. This is the case for formal
   parameter lists of non-strict functions. In that case the formal
   parameter bindings are preinitialized in order to deal with the
   possibility of multiple parameters with the same name.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[]

   1. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[Elision][Elision]]]

   1. Return the result of performing
      IteratorDestructuringAssignmentEvaluation of
      [[Elision][Elision]] with
      =iteratorRecord= as the argument.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]]]

   1. If [[Elision][Elision]] is present,
      then

      1. Perform ? IteratorDestructuringAssignmentEvaluation of
         [[Elision][Elision]] with
         =iteratorRecord= as the argument.

   2. Return the result of performing IteratorBindingInitialization for
      [[BindingRestElement][BindingRestElement]]
      with =iteratorRecord= and =environment= as arguments.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]]]

   1. Return the result of performing IteratorBindingInitialization for
      [[BindingElementList][BindingElementList]]
      with =iteratorRecord= and =environment= as arguments.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]],]

   1. Return the result of performing IteratorBindingInitialization for
      [[BindingElementList][BindingElementList]]
      with =iteratorRecord= and =environment= as arguments.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]],[[Elision][Elision]]]

   1. Perform ? IteratorBindingInitialization for
      [[BindingElementList][BindingElementList]]
      with =iteratorRecord= and =environment= as arguments.
   2. Return the result of performing
      IteratorDestructuringAssignmentEvaluation of
      [[Elision][Elision]] with
      =iteratorRecord= as the argument.

   [[ArrayBindingPattern][ArrayBindingPattern]]:[[[BindingElementList][BindingElementList]],[[Elision][Elision]]opt[[BindingRestElement][BindingRestElement]]]

   1. Perform ? IteratorBindingInitialization for
      [[BindingElementList][BindingElementList]]
      with =iteratorRecord= and =environment= as arguments.
   2. If [[Elision][Elision]] is present,
      then

      1. Perform ? IteratorDestructuringAssignmentEvaluation of
         [[Elision][Elision]] with
         =iteratorRecord= as the argument.

   3. Return the result of performing IteratorBindingInitialization for
      [[BindingRestElement][BindingRestElement]]
      with =iteratorRecord= and =environment= as arguments.

   [[BindingElementList][BindingElementList]]:[[BindingElisionElement][BindingElisionElement]]

   1. Return the result of performing IteratorBindingInitialization for
      [[BindingElisionElement][BindingElisionElement]]
      with =iteratorRecord= and =environment= as arguments.

   [[BindingElementList][BindingElementList]]:[[BindingElementList][BindingElementList]],[[BindingElisionElement][BindingElisionElement]]

   1. Perform ? IteratorBindingInitialization for
      [[BindingElementList][BindingElementList]]
      with =iteratorRecord= and =environment= as arguments.
   2. Return the result of performing IteratorBindingInitialization for
      [[BindingElisionElement][BindingElisionElement]]
      using =iteratorRecord= and =environment= as arguments.

   [[BindingElisionElement][BindingElisionElement]]:[[BindingElement][BindingElement]]

   1. Return the result of performing IteratorBindingInitialization of
      [[BindingElement][BindingElement]] with
      =iteratorRecord= and =environment= as the arguments.

   [[BindingElisionElement][BindingElisionElement]]:[[Elision][Elision]][[BindingElement][BindingElement]]

   1. Perform ? IteratorDestructuringAssignmentEvaluation of
      [[Elision][Elision]] with
      =iteratorRecord= as the argument.
   2. Return the result of performing IteratorBindingInitialization of
      [[BindingElement][BindingElement]] with
      =iteratorRecord= and =environment= as the arguments.

   [[BindingElement][BindingElement]]:[[SingleNameBinding][SingleNameBinding]]

   1. Return the result of performing IteratorBindingInitialization for
      [[SingleNameBinding][SingleNameBinding]]
      with =iteratorRecord= and =environment= as the arguments.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]opt

   1. Let =bindingId= be StringValue of
      [[file:expressions.org::#BindingIdentifier][BindingIdentifier]].
   2. Let =lhs= be
      ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=bindingId=,
      =environment=).
   3. If =iteratorRecord=.[[Done]] is false, then

      1. Let =next= be
         [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
      2. If =next= is an
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
         completion]], set =iteratorRecord=.[[Done]] to true.
      3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
      4. If =next= is false, set =iteratorRecord=.[[Done]] to true.
      5. Else,

         1. Let =v= be
            [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
         2. If =v= is an
            [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
            completion]], set =iteratorRecord=.[[Done]] to true.
         3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=v=).

   4. If =iteratorRecord=.[[Done]] is true, let =v= be undefined.
   5. If [[Initializer][Initializer]] is
      present and =v= is undefined, then

      1. If
         [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Initializer][Initializer]])
         is true, then

         1. Set =v= to the result of performing NamedEvaluation for
            [[Initializer][Initializer]] with
            argument =bindingId=.

      2. Else,

         1. Let =defaultValue= be the result of evaluating
            [[Initializer][Initializer]].
         2. Set =v= to
            ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=defaultValue=).

   6. If =environment= is undefined, return
      ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=, =v=).
   7. Return
      [[https://tc39.es/ecma262/#sec-initializereferencedbinding][InitializeReferencedBinding]](=lhs=,
      =v=).

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]opt

   1. If =iteratorRecord=.[[Done]] is false, then

      1. Let =next= be
         [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
      2. If =next= is an
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
         completion]], set =iteratorRecord=.[[Done]] to true.
      3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
      4. If =next= is false, set =iteratorRecord=.[[Done]] to true.
      5. Else,

         1. Let =v= be
            [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
         2. If =v= is an
            [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
            completion]], set =iteratorRecord=.[[Done]] to true.
         3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=v=).

   2. If =iteratorRecord=.[[Done]] is true, let =v= be undefined.
   3. If [[Initializer][Initializer]] is
      present and =v= is undefined, then

      1. Let =defaultValue= be the result of evaluating
         [[Initializer][Initializer]].
      2. Set =v= to
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=defaultValue=).

   4. Return the result of performing BindingInitialization of
      [[BindingPattern][BindingPattern]] with
      =v= and =environment= as the arguments.

   [[BindingRestElement][BindingRestElement]]:...[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Let =lhs= be
      ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](StringValue
      of
      [[file:expressions.org::#BindingIdentifier][BindingIdentifier]],
      =environment=).
   2. Let =A= be
      ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](0).
   3. Let =n= be 0.
   4. Repeat,

      1. If =iteratorRecord=.[[Done]] is false, then

         1. Let =next= be
            [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
         2. If =next= is an
            [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
            completion]], set =iteratorRecord=.[[Done]] to true.
         3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
         4. If =next= is false, set =iteratorRecord=.[[Done]] to true.

      2. If =iteratorRecord=.[[Done]] is true, then

         1. If =environment= is undefined, return
            ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=,
            =A=).
         2. Return
            [[https://tc39.es/ecma262/#sec-initializereferencedbinding][InitializeReferencedBinding]](=lhs=,
            =A=).

      3. Let =nextValue= be
         [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
      4. If =nextValue= is an
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
         completion]], set =iteratorRecord=.[[Done]] to true.
      5. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextValue=).
      6. Perform
         ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=A=,
         ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=n=),
         =nextValue=).
      7. Set =n= to =n= + 1.

   [[BindingRestElement][BindingRestElement]]:...[[BindingPattern][BindingPattern]]

   1. Let =A= be
      ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](0).
   2. Let =n= be 0.
   3. Repeat,

      1. If =iteratorRecord=.[[Done]] is false, then

         1. Let =next= be
            [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
         2. If =next= is an
            [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
            completion]], set =iteratorRecord=.[[Done]] to true.
         3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
         4. If =next= is false, set =iteratorRecord=.[[Done]] to true.

      2. If =iteratorRecord=.[[Done]] is true, then

         1. Return the result of performing BindingInitialization of
            [[BindingPattern][BindingPattern]]
            with =A= and =environment= as the arguments.

      3. Let =nextValue= be
         [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
      4. If =nextValue= is an
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
         completion]], set =iteratorRecord=.[[Done]] to true.
      5. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextValue=).
      6. Perform
         ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=A=,
         ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=n=),
         =nextValue=).
      7. Set =n= to =n= + 1.

**** Runtime Semantics: KeyedBindingInitialization
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-keyedbindinginitialization
     :END:

   With parameters =value=, =environment=, and =propertyName=.

   Note

   When undefined is passed for =environment= it indicates that a
   [[https://tc39.es/ecma262/#sec-putvalue][PutValue]] operation should be
   used to assign the initialization value. This is the case for formal
   parameter lists of non-strict functions. In that case the formal
   parameter bindings are preinitialized in order to deal with the
   possibility of multiple parameters with the same name.

   [[BindingElement][BindingElement]]:[[BindingPattern][BindingPattern]][[Initializer][Initializer]]opt

   1. Let =v= be ? [[https://tc39.es/ecma262/#sec-getv][GetV]](=value=,
      =propertyName=).
   2. If [[Initializer][Initializer]] is
      present and =v= is undefined, then

      1. Let =defaultValue= be the result of evaluating
         [[Initializer][Initializer]].
      2. Set =v= to
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=defaultValue=).

   3. Return the result of performing BindingInitialization for
      [[BindingPattern][BindingPattern]]
      passing =v= and =environment= as arguments.

   [[SingleNameBinding][SingleNameBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][[Initializer][Initializer]]opt

   1. Let =bindingId= be StringValue of
      [[file:expressions.org::#BindingIdentifier][BindingIdentifier]].
   2. Let =lhs= be
      ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=bindingId=,
      =environment=).
   3. Let =v= be ? [[https://tc39.es/ecma262/#sec-getv][GetV]](=value=,
      =propertyName=).
   4. If [[Initializer][Initializer]] is
      present and =v= is undefined, then

      1. If
         [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Initializer][Initializer]])
         is true, then

         1. Set =v= to the result of performing NamedEvaluation for
            [[Initializer][Initializer]] with
            argument =bindingId=.

      2. Else,

         1. Let =defaultValue= be the result of evaluating
            [[Initializer][Initializer]].
         2. Set =v= to
            ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=defaultValue=).

   5. If =environment= is undefined, return
      ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=, =v=).
   6. Return
      [[https://tc39.es/ecma262/#sec-initializereferencedbinding][InitializeReferencedBinding]](=lhs=,
      =v=).

** Empty Statement
   :PROPERTIES:
   :CUSTOM_ID: empty-statement
   :END:

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-42
    :END:
   
    #+NAME: EmptyStatement
    #+begin_quote
    [[EmptyStatement][EmptyStatement]]:
       ;
    #+end_quote

    #+begin_src gerbil :noweb-ref empty-statement-exp
      (defstruct (empty-statement statement) ()) 
      (def EmptyStatement
        (.begin (token-production-value? #\;) (return (empty-statement))))
    #+end_src
*** Runtime Semantics: Evaluation
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-evaluation-44
    :END:

  [[EmptyStatement][EmptyStatement]]:;

  1. Return
     [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

** Expression Statement
   :PROPERTIES:
   :CUSTOM_ID: expression-statement
   :END:

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-43
    :END:

 [[ExpressionStatement][ExpressionStatement]][Yield,
 Await]:[lookahead ∉ { {, function, async [no
 [[LineTerminator][LineTerminator]] here]
 function, class, let [
 }][[Expression][Expression]][+In, ?Yield,
 ?Await]; Note

 An
 [[ExpressionStatement][ExpressionStatement]]
 cannot start with a U+007B (LEFT CURLY BRACKET) because that might make
 it ambiguous with a [[Block][Block]]. An
 [[ExpressionStatement][ExpressionStatement]]
 cannot start with the =function= or =class= keywords because that would
 make it ambiguous with a
 [[FunctionDeclaration][FunctionDeclaration]],
 a
 [[GeneratorDeclaration][GeneratorDeclaration]],
 or a
 [[ClassDeclaration][ClassDeclaration]]. An
 [[ExpressionStatement][ExpressionStatement]]
 cannot start with =async function= because that would make it ambiguous
 with an
 [[AsyncFunctionDeclaration][AsyncFunctionDeclaration]]
 or a
 [[AsyncGeneratorDeclaration][AsyncGeneratorDeclaration]].
 An
 [[ExpressionStatement][ExpressionStatement]]
 cannot start with the two token sequence =let [= because that would make
 it ambiguous with a =let=
 [[LexicalDeclaration][LexicalDeclaration]]
 whose first
 [[LexicalBinding][LexicalBinding]] was an
 [[ArrayBindingPattern][ArrayBindingPattern]].

*** Runtime Semantics: Evaluation
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-evaluation-45
    :END:

  [[ExpressionStatement][ExpressionStatement]]:[[Expression][Expression]];

  1. Let =exprRef= be the result of evaluating
     [[Expression][Expression]].
  2. Return
     ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).

** The =if= Statement
   :PROPERTIES:
   :CUSTOM_ID: the-if-statement
   :END:

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-44
    :END:

 [[IfStatement][IfStatement]][Yield, Await,
 Return]:if([[Expression][Expression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await,
 ?Return]else[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 if([[Expression][Expression]][+In, ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 Each =else= for which the choice of associated =if= is ambiguous shall
 be associated with the nearest possible =if= that would otherwise have
 no corresponding =else=.

*** Static Semantics: Early Errors
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-early-errors-13
    :END:

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]else[[Statement][Statement]]
  if([[Expression][Expression]])[[Statement][Statement]]

  - It is a Syntax Error if
    [[https://tc39.es/ecma262/#sec-islabelledfunction][IsLabelledFunction]]([[Statement][Statement]])
    is true.

  Note

  It is only necessary to apply this rule if the extension specified in
  [[https://tc39.es/ecma262/#sec-labelled-function-declarations][B.3.2]]
  is implemented.

*** Static Semantics: ContainsDuplicateLabels
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsduplicatelabels-2
    :END:

  With parameter =labelSet=.

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]else[[Statement][Statement]]

  1. Let =hasDuplicate= be ContainsDuplicateLabels of the first
     [[Statement][Statement]] with argument
     =labelSet=.
  2. If =hasDuplicate= is true, return true.
  3. Return ContainsDuplicateLabels of the second
     [[Statement][Statement]] with argument
     =labelSet=.

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]

  1. Return ContainsDuplicateLabels of
     [[Statement][Statement]] with argument
     =labelSet=.

*** Static Semantics: ContainsUndefinedBreakTarget
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-2
    :END:

  With parameter =labelSet=.

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]else[[Statement][Statement]]

  1. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of the first
     [[Statement][Statement]] with argument
     =labelSet=.
  2. If =hasUndefinedLabels= is true, return true.
  3. Return ContainsUndefinedBreakTarget of the second
     [[Statement][Statement]] with argument
     =labelSet=.

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]

  1. Return ContainsUndefinedBreakTarget of
     [[Statement][Statement]] with argument
     =labelSet=.

*** Static Semantics: ContainsUndefinedContinueTarget
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-2
    :END:

  With parameters =iterationSet= and =labelSet=.

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]else[[Statement][Statement]]

  1. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of the
     first [[Statement][Statement]] with
     arguments =iterationSet= and « ».
  2. If =hasUndefinedLabels= is true, return true.
  3. Return ContainsUndefinedContinueTarget of the second
     [[Statement][Statement]] with arguments
     =iterationSet= and « ».

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]

  1. Return ContainsUndefinedContinueTarget of
     [[Statement][Statement]] with arguments
     =iterationSet= and « ».

*** Static Semantics: VarDeclaredNames
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-vardeclarednames-3
    :END:

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]else[[Statement][Statement]]

  1. Let =names= be VarDeclaredNames of the first
     [[Statement][Statement]].
  2. Append to =names= the elements of the VarDeclaredNames of the second
     [[Statement][Statement]].
  3. Return =names=.

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]

  1. Return the VarDeclaredNames of
     [[Statement][Statement]].

*** Static Semantics: VarScopedDeclarations
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-varscopeddeclarations-3
    :END:

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]else[[Statement][Statement]]

  1. Let =declarations= be VarScopedDeclarations of the first
     [[Statement][Statement]].
  2. Append to =declarations= the elements of the VarScopedDeclarations of
     the second [[Statement][Statement]].
  3. Return =declarations=.

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]

  1. Return the VarScopedDeclarations of
     [[Statement][Statement]].

*** Runtime Semantics: Evaluation
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-evaluation-46
    :END:

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]else[[Statement][Statement]]

  1. Let =exprRef= be the result of evaluating
     [[Expression][Expression]].
  2. Let =exprValue= be
     ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](?
     [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=)).
  3. If =exprValue= is true, then

     1. Let =stmtCompletion= be the result of evaluating the first
        [[Statement][Statement]].

  4. Else,

     1. Let =stmtCompletion= be the result of evaluating the second
        [[Statement][Statement]].

  5. Return
     [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=stmtCompletion=,
     undefined)).

  [[IfStatement][IfStatement]]:if([[Expression][Expression]])[[Statement][Statement]]

  1. Let =exprRef= be the result of evaluating
     [[Expression][Expression]].
  2. Let =exprValue= be
     ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](?
     [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=)).
  3. If =exprValue= is false, then

     1. Return
        [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](undefined).

  4. Else,

     1. Let =stmtCompletion= be the result of evaluating
        [[Statement][Statement]].
     2. Return
        [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=stmtCompletion=,
        undefined)).

** Iteration Statements
   :PROPERTIES:
   :CUSTOM_ID: iteration-statements
   :END:

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-45
    :END:

 [[IterationStatement][IterationStatement]][Yield,
 Await,
 Return]:do[[Statement][Statement]][?Yield,
 ?Await,
 ?Return]while([[Expression][Expression]][+In,
 ?Yield, ?Await]);
 while([[Expression][Expression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return] for([lookahead ≠ let
 [][[Expression][Expression]][~In, ?Yield,
 ?Await]opt;[[Expression][Expression]][+In,
 ?Yield,
 ?Await]opt;[[Expression][Expression]][+In,
 ?Yield,
 ?Await]opt)[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 for(var[[VariableDeclarationList][VariableDeclarationList]][~In,
 ?Yield,
 ?Await];[[Expression][Expression]][+In,
 ?Yield,
 ?Await]opt;[[Expression][Expression]][+In,
 ?Yield,
 ?Await]opt)[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 for([[LexicalDeclaration][LexicalDeclaration]][~In,
 ?Yield,
 ?Await][[Expression][Expression]][+In,
 ?Yield,
 ?Await]opt;[[Expression][Expression]][+In,
 ?Yield,
 ?Await]opt)[[Statement][Statement]][?Yield,
 ?Await, ?Return] for([lookahead ≠ let
 [][[LeftHandSideExpression][LeftHandSideExpression]][?Yield,
 ?Await]in[[Expression][Expression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 for(var[[ForBinding][ForBinding]][?Yield,
 ?Await]in[[Expression][Expression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 for([[ForDeclaration][ForDeclaration]][?Yield,
 ?Await]in[[Expression][Expression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return] for([lookahead ≠
 let][[LeftHandSideExpression][LeftHandSideExpression]][?Yield,
 ?Await]of[[AssignmentExpression][AssignmentExpression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 for(var[[ForBinding][ForBinding]][?Yield,
 ?Await]of[[AssignmentExpression][AssignmentExpression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 for([[ForDeclaration][ForDeclaration]][?Yield,
 ?Await]of[[AssignmentExpression][AssignmentExpression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return] [+Await]forawait([lookahead ≠
 let][[LeftHandSideExpression][LeftHandSideExpression]][?Yield,
 ?Await]of[[AssignmentExpression][AssignmentExpression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 [+Await]forawait(var[[ForBinding][ForBinding]][?Yield,
 ?Await]of[[AssignmentExpression][AssignmentExpression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 [+Await]forawait([[ForDeclaration][ForDeclaration]][?Yield,
 ?Await]of[[AssignmentExpression][AssignmentExpression]][+In,
 ?Yield,
 ?Await])[[Statement][Statement]][?Yield,
 ?Await, ?Return]
 [[ForDeclaration][ForDeclaration]][Yield,
 Await]:[[LetOrConst][LetOrConst]][[ForBinding][ForBinding]][?Yield,
 ?Await] [[ForBinding][ForBinding]][Yield,
 Await]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][?Yield,
 ?Await]
 [[BindingPattern][BindingPattern]][?Yield,
 ?Await] Note

 This section is extended by Annex
 [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

*** Semantics
    :PROPERTIES:
    :CUSTOM_ID: semantics-1
    :END:

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-14
     :END:

   [[IterationStatement][IterationStatement]]:do[[Statement][Statement]]while([[Expression][Expression]]);
   while([[Expression][Expression]])[[Statement][Statement]]
   for([[Expression][Expression]]opt;[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for(var[[VariableDeclarationList][VariableDeclarationList]];[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   - It is a Syntax Error if
     [[https://tc39.es/ecma262/#sec-islabelledfunction][IsLabelledFunction]]([[Statement][Statement]])
     is true.

   Note

   It is only necessary to apply this rule if the extension specified in
   [[https://tc39.es/ecma262/#sec-labelled-function-declarations][B.3.2]]
   is implemented.

**** Runtime Semantics: LoopContinues ( =completion=, =labelSet= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-loopcontinues-completion-labelset
     :END:

   The abstract operation LoopContinues with arguments =completion= and
   =labelSet= is defined by the following steps:

   1. If =completion=.[[Type]] is normal, return true.
   2. If =completion=.[[Type]] is not continue, return false.
   3. If =completion=.[[Target]] is empty, return true.
   4. If =completion=.[[Target]] is an element of =labelSet=, return true.
   5. Return false.

   Note

   Within the [[Statement][Statement]] part
   of an
   [[IterationStatement][IterationStatement]]
   a [[ContinueStatement][ContinueStatement]]
   may be used to begin a new iteration.

*** The =do=-=while= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-do-while-statement
    :END:

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-3
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:do[[Statement][Statement]]while([[Expression][Expression]]);

   1. Return ContainsDuplicateLabels of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-3
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:do[[Statement][Statement]]while([[Expression][Expression]]);

   1. Return ContainsUndefinedBreakTarget of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-3
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[IterationStatement][IterationStatement]]:do[[Statement][Statement]]while([[Expression][Expression]]);

   1. Return ContainsUndefinedContinueTarget of
      [[Statement][Statement]] with arguments
      =iterationSet= and « ».

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-4
     :END:

   [[IterationStatement][IterationStatement]]:do[[Statement][Statement]]while([[Expression][Expression]]);

   1. Return the VarDeclaredNames of
      [[Statement][Statement]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-4
     :END:

   [[IterationStatement][IterationStatement]]:do[[Statement][Statement]]while([[Expression][Expression]]);

   1. Return the VarScopedDeclarations of
      [[Statement][Statement]].

**** Runtime Semantics: LabelledEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-labelledevaluation-1
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:do[[Statement][Statement]]while([[Expression][Expression]]);

   1. Let =V= be undefined.
   2. Repeat,

      1. Let =stmtResult= be the result of evaluating
         [[Statement][Statement]].
      2. If
         [[https://tc39.es/ecma262/#sec-loopcontinues][LoopContinues]](=stmtResult=,
         =labelSet=) is false, return
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=stmtResult=,
         =V=)).
      3. If =stmtResult=.[[Value]] is not empty, set =V= to
         =stmtResult=.[[Value]].
      4. Let =exprRef= be the result of evaluating
         [[Expression][Expression]].
      5. Let =exprValue= be
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).
      6. If
         ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](=exprValue=)
         is false, return
         [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=V=).

*** The =while= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-while-statement
    :END:

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-4
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:while([[Expression][Expression]])[[Statement][Statement]]

   1. Return ContainsDuplicateLabels of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-4
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:while([[Expression][Expression]])[[Statement][Statement]]

   1. Return ContainsUndefinedBreakTarget of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-4
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[IterationStatement][IterationStatement]]:while([[Expression][Expression]])[[Statement][Statement]]

   1. Return ContainsUndefinedContinueTarget of
      [[Statement][Statement]] with arguments
      =iterationSet= and « ».

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-5
     :END:

   [[IterationStatement][IterationStatement]]:while([[Expression][Expression]])[[Statement][Statement]]

   1. Return the VarDeclaredNames of
      [[Statement][Statement]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-5
     :END:

   [[IterationStatement][IterationStatement]]:while([[Expression][Expression]])[[Statement][Statement]]

   1. Return the VarScopedDeclarations of
      [[Statement][Statement]].

**** Runtime Semantics: LabelledEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-labelledevaluation-2
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:while([[Expression][Expression]])[[Statement][Statement]]

   1. Let =V= be undefined.
   2. Repeat,

      1. Let =exprRef= be the result of evaluating
         [[Expression][Expression]].
      2. Let =exprValue= be
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).
      3. If
         ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](=exprValue=)
         is false, return
         [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=V=).
      4. Let =stmtResult= be the result of evaluating
         [[Statement][Statement]].
      5. If
         [[https://tc39.es/ecma262/#sec-loopcontinues][LoopContinues]](=stmtResult=,
         =labelSet=) is false, return
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=stmtResult=,
         =V=)).
      6. If =stmtResult=.[[Value]] is not empty, set =V= to
         =stmtResult=.[[Value]].

*** The =for= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-for-statement
    :END:

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-15
     :END:

   [[IterationStatement][IterationStatement]]:for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   - It is a Syntax Error if any element of the BoundNames of
     [[LexicalDeclaration][LexicalDeclaration]]
     also occurs in the VarDeclaredNames of
     [[Statement][Statement]].

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-5
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[Expression][Expression]]opt;[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for(var[[VariableDeclarationList][VariableDeclarationList]];[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Return ContainsDuplicateLabels of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-5
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[Expression][Expression]]opt;[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for(var[[VariableDeclarationList][VariableDeclarationList]];[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Return ContainsUndefinedBreakTarget of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-5
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[Expression][Expression]]opt;[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for(var[[VariableDeclarationList][VariableDeclarationList]];[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]
   for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Return ContainsUndefinedContinueTarget of
      [[Statement][Statement]] with arguments
      =iterationSet= and « ».

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-6
     :END:

   [[IterationStatement][IterationStatement]]:for([[Expression][Expression]]opt;[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Return the VarDeclaredNames of
      [[Statement][Statement]].

   [[IterationStatement][IterationStatement]]:for(var[[VariableDeclarationList][VariableDeclarationList]];[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Let =names= be BoundNames of
      [[VariableDeclarationList][VariableDeclarationList]].
   2. Append to =names= the elements of the VarDeclaredNames of
      [[Statement][Statement]].
   3. Return =names=.

   [[IterationStatement][IterationStatement]]:for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Return the VarDeclaredNames of
      [[Statement][Statement]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-6
     :END:

   [[IterationStatement][IterationStatement]]:for([[Expression][Expression]]opt;[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Return the VarScopedDeclarations of
      [[Statement][Statement]].

   [[IterationStatement][IterationStatement]]:for(var[[VariableDeclarationList][VariableDeclarationList]];[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Let =declarations= be VarScopedDeclarations of
      [[VariableDeclarationList][VariableDeclarationList]].
   2. Append to =declarations= the elements of the VarScopedDeclarations of
      [[Statement][Statement]].
   3. Return =declarations=.

   [[IterationStatement][IterationStatement]]:for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Return the VarScopedDeclarations of
      [[Statement][Statement]].

**** Runtime Semantics: LabelledEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-labelledevaluation-3
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[Expression][Expression]]opt;[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. If the first [[Expression][Expression]]
      is present, then

      1. Let =exprRef= be the result of evaluating the first
         [[Expression][Expression]].
      2. Perform
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).

   2. Return
      ? [[https://tc39.es/ecma262/#sec-forbodyevaluation][ForBodyEvaluation]](the
      second [[Expression][Expression]], the
      third [[Expression][Expression]],
      [[Statement][Statement]], « »,
      =labelSet=).

   [[IterationStatement][IterationStatement]]:for(var[[VariableDeclarationList][VariableDeclarationList]];[[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1. Let =varDcl= be the result of evaluating
      [[VariableDeclarationList][VariableDeclarationList]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=varDcl=).
   3. Return
      ? [[https://tc39.es/ecma262/#sec-forbodyevaluation][ForBodyEvaluation]](the
      first [[Expression][Expression]], the
      second [[Expression][Expression]],
      [[Statement][Statement]], « »,
      =labelSet=).

   [[IterationStatement][IterationStatement]]:for([[LexicalDeclaration][LexicalDeclaration]][[Expression][Expression]]opt;[[Expression][Expression]]opt)[[Statement][Statement]]

   1.  Let =oldEnv= be the
       [[https://tc39.es/ecma262/#running-execution-context][running
       execution context]]'s LexicalEnvironment.
   2.  Let =loopEnv= be
       [[https://tc39.es/ecma262/#sec-newdeclarativeenvironment][NewDeclarativeEnvironment]](=oldEnv=).
   3.  Let =loopEnvRec= be =loopEnv='s
       [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]].
   4.  Let =isConst= be IsConstantDeclaration of
       [[LexicalDeclaration][LexicalDeclaration]].
   5.  Let =boundNames= be the BoundNames of
       [[LexicalDeclaration][LexicalDeclaration]].
   6.  For each element =dn= of =boundNames=, do

       1. If =isConst= is true, then

          1. Perform ! =loopEnvRec=.CreateImmutableBinding(=dn=, true).

       2. Else,

          1. Perform ! =loopEnvRec=.CreateMutableBinding(=dn=, false).

   7.  Set the
       [[https://tc39.es/ecma262/#running-execution-context][running
       execution context]]'s LexicalEnvironment to =loopEnv=.
   8.  Let =forDcl= be the result of evaluating
       [[LexicalDeclaration][LexicalDeclaration]].
   9.  If =forDcl= is an
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
       completion]], then

       1. Set the
          [[https://tc39.es/ecma262/#running-execution-context][running
          execution context]]'s LexicalEnvironment to =oldEnv=.
       2. Return
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=forDcl=).

   10. If =isConst= is false, let =perIterationLets= be =boundNames=;
       otherwise let =perIterationLets= be « ».
   11. Let =bodyResult= be
       [[https://tc39.es/ecma262/#sec-forbodyevaluation][ForBodyEvaluation]](the
       first [[Expression][Expression]], the
       second [[Expression][Expression]],
       [[Statement][Statement]],
       =perIterationLets=, =labelSet=).
   12. Set the
       [[https://tc39.es/ecma262/#running-execution-context][running
       execution context]]'s LexicalEnvironment to =oldEnv=.
   13. Return
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=bodyResult=).

**** Runtime Semantics: ForBodyEvaluation ( =test=, =increment=,
   =stmt=, =perIterationBindings=, =labelSet= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-forbodyevaluation-test-increment-stmt-periterationbindings-labelset
     :END:

   The abstract operation ForBodyEvaluation with arguments =test=,
   =increment=, =stmt=, =perIterationBindings=, and =labelSet= is performed
   as follows:

   1. Let =V= be undefined.
   2. Perform
      ? [[https://tc39.es/ecma262/#sec-createperiterationenvironment][CreatePerIterationEnvironment]](=perIterationBindings=).
   3. Repeat,

      1. If =test= is not [empty], then

         1. Let =testRef= be the result of evaluating =test=.
         2. Let =testValue= be
            ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=testRef=).
         3. If
            ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](=testValue=)
            is false, return
            [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=V=).

      2. Let =result= be the result of evaluating =stmt=.
      3. If
         [[https://tc39.es/ecma262/#sec-loopcontinues][LoopContinues]](=result=,
         =labelSet=) is false, return
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=result=,
         =V=)).
      4. If =result=.[[Value]] is not empty, set =V= to =result=.[[Value]].
      5. Perform
         ? [[https://tc39.es/ecma262/#sec-createperiterationenvironment][CreatePerIterationEnvironment]](=perIterationBindings=).
      6. If =increment= is not [empty], then

         1. Let =incRef= be the result of evaluating =increment=.
         2. Perform
            ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=incRef=).

**** Runtime Semantics: CreatePerIterationEnvironment (
   =perIterationBindings= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-createperiterationenvironment-periterationbindings
     :END:

   The abstract operation CreatePerIterationEnvironment with argument
   =perIterationBindings= is performed as follows:

   1. If =perIterationBindings= has any elements, then

      1. Let =lastIterationEnv= be the
         [[https://tc39.es/ecma262/#running-execution-context][running
         execution context]]'s LexicalEnvironment.
      2. Let =lastIterationEnvRec= be =lastIterationEnv='s
         [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]].
      3. Let =outer= be =lastIterationEnv='s outer environment reference.
      4. [[https://tc39.es/ecma262/#assert][Assert]]: =outer= is not null.
      5. Let =thisIterationEnv= be
         [[https://tc39.es/ecma262/#sec-newdeclarativeenvironment][NewDeclarativeEnvironment]](=outer=).
      6. Let =thisIterationEnvRec= be =thisIterationEnv='s
         [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]].
      7. For each element =bn= of =perIterationBindings=, do

         1. Perform ! =thisIterationEnvRec=.CreateMutableBinding(=bn=,
            false).
         2. Let =lastValue= be ?
            =lastIterationEnvRec=.GetBindingValue(=bn=, true).
         3. Perform =thisIterationEnvRec=.InitializeBinding(=bn=,
            =lastValue=).

      8. Set the
         [[https://tc39.es/ecma262/#running-execution-context][running
         execution context]]'s LexicalEnvironment to =thisIterationEnv=.

   2. Return undefined.

*** The =for=-=in=, =for=-=of=, and =for=-=await=-=of= Statements
    :PROPERTIES:
    :CUSTOM_ID: the-for-in-for-of-and-for-await-of-statements
    :END:

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-16
     :END:

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   - It is a Syntax Error if
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is either an
     [[ObjectLiteral][ObjectLiteral]] or an
     [[ArrayLiteral][ArrayLiteral]] and if
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is not [[https://tc39.es/ecma262/#sec-syntactic-grammar][covering]] an
     [[AssignmentPattern][AssignmentPattern]].

   If
   [[LeftHandSideExpression][LeftHandSideExpression]]
   is either an
   [[ObjectLiteral][ObjectLiteral]] or an
   [[ArrayLiteral][ArrayLiteral]] and if
   [[LeftHandSideExpression][LeftHandSideExpression]]
   is [[https://tc39.es/ecma262/#sec-syntactic-grammar][covering]] an
   [[AssignmentPattern][AssignmentPattern]]
   then the following rules are not applied. Instead, the Early Error rules
   for
   [[AssignmentPattern][AssignmentPattern]]
   are used.

   - It is a Syntax Error if AssignmentTargetType of
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is not simple.
   - It is a Syntax Error if the
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is
     [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]:([[Expression][Expression]])
     and [[Expression][Expression]] derives a
     phrase that would produce a Syntax Error according to these rules if
     that phrase were substituted for
     [[LeftHandSideExpression][LeftHandSideExpression]].
     This rule is recursively applied.

   Note

   The last rule means that the other rules are applied even if parentheses
   surround [[Expression][Expression]].

   [[IterationStatement][IterationStatement]]:for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   - It is a Syntax Error if the BoundNames of
     [[ForDeclaration][ForDeclaration]]
     contains "let".
   - It is a Syntax Error if any element of the BoundNames of
     [[ForDeclaration][ForDeclaration]] also
     occurs in the VarDeclaredNames of
     [[Statement][Statement]].
   - It is a Syntax Error if the BoundNames of
     [[ForDeclaration][ForDeclaration]]
     contains any duplicate entries.

**** Static Semantics: BoundNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-boundnames-4
     :END:

   [[ForDeclaration][ForDeclaration]]:[[LetOrConst][LetOrConst]][[ForBinding][ForBinding]]

   1. Return the BoundNames of
      [[ForBinding][ForBinding]].

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-6
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Return ContainsDuplicateLabels of
      [[Statement][Statement]] with argument
      =labelSet=.

   Note

   This section is extended by Annex
   [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-6
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Return ContainsUndefinedBreakTarget of
      [[Statement][Statement]] with argument
      =labelSet=.

   Note

   This section is extended by Annex
   [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-6
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Return ContainsUndefinedContinueTarget of
      [[Statement][Statement]] with arguments
      =iterationSet= and « ».

   Note

   This section is extended by Annex
   [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

**** Static Semantics: IsDestructuring
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isdestructuring-1
     :END:

   [[ForDeclaration][ForDeclaration]]:[[LetOrConst][LetOrConst]][[ForBinding][ForBinding]]

   1. Return IsDestructuring of
      [[ForBinding][ForBinding]].

   [[ForBinding][ForBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Return false.

   [[ForBinding][ForBinding]]:[[BindingPattern][BindingPattern]]

   1. Return true.

   Note

   This section is extended by Annex
   [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-7
     :END:

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Return the VarDeclaredNames of
      [[Statement][Statement]].

   [[IterationStatement][IterationStatement]]:for(var[[ForBinding][ForBinding]]in[[Expression][Expression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =names= be the BoundNames of
      [[ForBinding][ForBinding]].
   2. Append to =names= the elements of the VarDeclaredNames of
      [[Statement][Statement]].
   3. Return =names=.

   Note

   This section is extended by Annex
   [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-7
     :END:

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]
   for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Return the VarScopedDeclarations of
      [[Statement][Statement]].

   [[IterationStatement][IterationStatement]]:for(var[[ForBinding][ForBinding]]in[[Expression][Expression]])[[Statement][Statement]]
   for(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]
   forawait(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =declarations= be a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing [[ForBinding][ForBinding]].
   2. Append to =declarations= the elements of the VarScopedDeclarations of
      [[Statement][Statement]].
   3. Return =declarations=.

   Note

   This section is extended by Annex
   [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

**** Runtime Semantics: BindingInitialization
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-bindinginitialization-2
     :END:

   With parameters =value= and =environment=.

   Note

   undefined is passed for =environment= to indicate that a
   [[https://tc39.es/ecma262/#sec-putvalue][PutValue]] operation should be
   used to assign the initialization value. This is the case for =var=
   statements and the formal parameter lists of some non-strict functions
   (see
   [[https://tc39.es/ecma262/#sec-functiondeclarationinstantiation][9.2.10]]).
   In those cases a lexical binding is hoisted and preinitialized prior to
   evaluation of its initializer.

   [[ForDeclaration][ForDeclaration]]:[[LetOrConst][LetOrConst]][[ForBinding][ForBinding]]

   1. Return the result of performing BindingInitialization for
      [[ForBinding][ForBinding]] passing
      =value= and =environment= as the arguments.

**** Runtime Semantics: BindingInstantiation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-bindinginstantiation
     :END:

   With parameter =environment=.

   [[ForDeclaration][ForDeclaration]]:[[LetOrConst][LetOrConst]][[ForBinding][ForBinding]]

   1. Let =envRec= be =environment='s
      [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]].
   2. [[https://tc39.es/ecma262/#assert][Assert]]: =envRec= is a
      declarative
      [[https://tc39.es/ecma262/#sec-environment-records][Environment
      Record]].
   3. For each element =name= of the BoundNames of
      [[ForBinding][ForBinding]], do

      1. If IsConstantDeclaration of
         [[LetOrConst][LetOrConst]] is true,
         then

         1. Perform ! =envRec=.CreateImmutableBinding(=name=, true).

      2. Else,

         1. Perform ! =envRec=.CreateMutableBinding(=name=, false).

**** Runtime Semantics: LabelledEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-labelledevaluation-4
     :END:

   With parameter =labelSet=.

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]in[[Expression][Expression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](«
      », [[Expression][Expression]],
      enumerate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[LeftHandSideExpression][LeftHandSideExpression]],
      [[Statement][Statement]], =keyResult=,
      enumerate, assignment, =labelSet=).

   [[IterationStatement][IterationStatement]]:for(var[[ForBinding][ForBinding]]in[[Expression][Expression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](«
      », [[Expression][Expression]],
      enumerate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[ForBinding][ForBinding]],
      [[Statement][Statement]], =keyResult=,
      enumerate, varBinding, =labelSet=).

   [[IterationStatement][IterationStatement]]:for([[ForDeclaration][ForDeclaration]]in[[Expression][Expression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](BoundNames
      of [[ForDeclaration][ForDeclaration]],
      [[Expression][Expression]], enumerate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[ForDeclaration][ForDeclaration]],
      [[Statement][Statement]], =keyResult=,
      enumerate, lexicalBinding, =labelSet=).

   [[IterationStatement][IterationStatement]]:for([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](«
      »,
      [[AssignmentExpression][AssignmentExpression]],
      iterate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[LeftHandSideExpression][LeftHandSideExpression]],
      [[Statement][Statement]], =keyResult=,
      iterate, assignment, =labelSet=).

   [[IterationStatement][IterationStatement]]:for(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](«
      »,
      [[AssignmentExpression][AssignmentExpression]],
      iterate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[ForBinding][ForBinding]],
      [[Statement][Statement]], =keyResult=,
      iterate, varBinding, =labelSet=).

   [[IterationStatement][IterationStatement]]:for([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](BoundNames
      of [[ForDeclaration][ForDeclaration]],
      [[AssignmentExpression][AssignmentExpression]],
      iterate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[ForDeclaration][ForDeclaration]],
      [[Statement][Statement]], =keyResult=,
      iterate, lexicalBinding, =labelSet=).

   [[IterationStatement][IterationStatement]]:forawait([[LeftHandSideExpression][LeftHandSideExpression]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](«
      »,
      [[AssignmentExpression][AssignmentExpression]],
      async-iterate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[LeftHandSideExpression][LeftHandSideExpression]],
      [[Statement][Statement]], =keyResult=,
      iterate, assignment, =labelSet=, async).

   [[IterationStatement][IterationStatement]]:forawait(var[[ForBinding][ForBinding]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](«
      »,
      [[AssignmentExpression][AssignmentExpression]],
      async-iterate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[ForBinding][ForBinding]],
      [[Statement][Statement]], =keyResult=,
      iterate, varBinding, =labelSet=, async).

   [[IterationStatement][IterationStatement]]:forawait([[ForDeclaration][ForDeclaration]]of[[AssignmentExpression][AssignmentExpression]])[[Statement][Statement]]

   1. Let =keyResult= be ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind][ForIn/OfHeadEvaluation]](BoundNames
      of [[ForDeclaration][ForDeclaration]],
      [[AssignmentExpression][AssignmentExpression]],
      async-iterate).
   2. Return ?
      [[https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofbodyevaluation-lhs-stmt-iterator-lhskind-labelset][ForIn/OfBodyEvaluation]]([[ForDeclaration][ForDeclaration]],
      [[Statement][Statement]], =keyResult=,
      iterate, lexicalBinding, =labelSet=, async).

   Note

   This section is extended by Annex
   [[https://tc39.es/ecma262/#sec-initializers-in-forin-statement-heads][B.3.6]].

**** Runtime Semantics: ForIn/OfHeadEvaluation ( =TDZnames=,
   =expr=, =iterationKind= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-forinofheadevaluation-tdznames-expr-iterationkind
     :END:

   The abstract operation ForIn/OfHeadEvaluation is called with arguments
   =TDZnames=, =expr=, and =iterationKind=. The value of =iterationKind= is
   either enumerate, iterate, or async-iterate.

   1. Let =oldEnv= be the
      [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment.
   2. If =TDZnames= is not an empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]],
      then

      1. [[https://tc39.es/ecma262/#assert][Assert]]: =TDZnames= has no
         duplicate entries.
      2. Let =TDZ= be
         [[https://tc39.es/ecma262/#sec-newdeclarativeenvironment][NewDeclarativeEnvironment]](=oldEnv=).
      3. Let =TDZEnvRec= be =TDZ='s
         [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]].
      4. For each string =name= in =TDZnames=, do

         1. Perform ! =TDZEnvRec=.CreateMutableBinding(=name=, false).

      5. Set the
         [[https://tc39.es/ecma262/#running-execution-context][running
         execution context]]'s LexicalEnvironment to =TDZ=.

   3. Let =exprRef= be the result of evaluating =expr=.
   4. Set the [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment to =oldEnv=.
   5. Let =exprValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).
   6. If =iterationKind= is enumerate, then

      1. If =exprValue= is undefined or null, then

         1. Return
            [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
            { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.

      2. Let =obj= be
         ! [[https://tc39.es/ecma262/#sec-toobject][ToObject]](=exprValue=).
      3. Return
         ? [[https://tc39.es/ecma262/#sec-enumerate-object-properties][EnumerateObjectProperties]](=obj=).

   7. Else,

      1. [[https://tc39.es/ecma262/#assert][Assert]]: =iterationKind= is
         iterate.
      2. If =iterationKind= is async-iterate, let =iteratorHint= be async.
      3. Else, let =iteratorHint= be sync.
      4. Return
         ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=exprValue=,
         =iteratorHint=).

**** Runtime Semantics: ForIn/OfBodyEvaluation ( =lhs=, =stmt=,
   =iteratorRecord=, =iterationKind=, =lhsKind=, =labelSet= [ ,
   =iteratorKind= ] )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-forinofbodyevaluation-lhs-stmt-iteratorrecord-iterationkind-lhskind-labelset-iteratorkind
     :END:

   The abstract operation ForIn/OfBodyEvaluation is called with arguments
   =lhs=, =stmt=, =iteratorRecord=, =iterationKind=, =lhsKind=, =labelSet=,
   and optional argument =iteratorKind=. The value of =lhsKind= is either
   assignment, varBinding or lexicalBinding. The value of =iteratorKind= is
   either sync or async.

   1. If =iteratorKind= is not present, set =iteratorKind= to sync.
   2. Let =oldEnv= be the
      [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment.
   3. Let =V= be undefined.
   4. Let =destructuring= be IsDestructuring of =lhs=.
   5. If =destructuring= is true and if =lhsKind= is assignment, then

      1. [[https://tc39.es/ecma262/#assert][Assert]]: =lhs= is a
         [[LeftHandSideExpression][LeftHandSideExpression]].
      2. Let =assignmentPattern= be the
         [[AssignmentPattern][AssignmentPattern]]
         that is
         [[https://tc39.es/ecma262/#sec-syntactic-grammar][covered]] by
         =lhs=.

   6. Repeat,

      1.  Let =nextResult= be
          ? [[https://tc39.es/ecma262/#sec-call][Call]](=iteratorRecord=.[[NextMethod]],
          =iteratorRecord=.[[Iterator]]).
      2.  If =iteratorKind= is async, then set =nextResult= to
          ? [[https://tc39.es/ecma262/#await][Await]](=nextResult=).
      3.  If
          [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=nextResult=)
          is not Object, throw a TypeError exception.
      4.  Let =done= be
          ? [[https://tc39.es/ecma262/#sec-iteratorcomplete][IteratorComplete]](=nextResult=).
      5.  If =done= is true, return
          [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=V=).
      6.  Let =nextValue= be
          ? [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=nextResult=).
      7.  If =lhsKind= is either assignment or varBinding, then

          1. If =destructuring= is false, then

             1. Let =lhsRef= be the result of evaluating =lhs=. (It may be
                evaluated repeatedly.)

      8.  Else,

          1. [[https://tc39.es/ecma262/#assert][Assert]]: =lhsKind= is
             lexicalBinding.
          2. [[https://tc39.es/ecma262/#assert][Assert]]: =lhs= is a
             [[ForDeclaration][ForDeclaration]].
          3. Let =iterationEnv= be
             [[https://tc39.es/ecma262/#sec-newdeclarativeenvironment][NewDeclarativeEnvironment]](=oldEnv=).
          4. Perform BindingInstantiation for =lhs= passing =iterationEnv=
             as the argument.
          5. Set the
             [[https://tc39.es/ecma262/#running-execution-context][running
             execution context]]'s LexicalEnvironment to =iterationEnv=.
          6. If =destructuring= is false, then

             1. [[https://tc39.es/ecma262/#assert][Assert]]: =lhs= binds a
                single name.
             2. Let =lhsName= be the sole element of BoundNames of =lhs=.
             3. Let =lhsRef= be
                ! [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=lhsName=).

      9.  If =destructuring= is false, then

          1. If =lhsRef= is an
             [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
             completion]], then

             1. Let =status= be =lhsRef=.

          2. Else if =lhsKind= is lexicalBinding, then

             1. Let =status= be
                [[https://tc39.es/ecma262/#sec-initializereferencedbinding][InitializeReferencedBinding]](=lhsRef=,
                =nextValue=).

          3. Else,

             1. Let =status= be
                [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhsRef=,
                =nextValue=).

      10. Else,

          1. If =lhsKind= is assignment, then

             1. Let =status= be DestructuringAssignmentEvaluation of
                =assignmentPattern= with argument =nextValue=.

          2. Else if =lhsKind= is varBinding, then

             1. [[https://tc39.es/ecma262/#assert][Assert]]: =lhs= is a
                [[ForBinding][ForBinding]].
             2. Let =status= be BindingInitialization of =lhs= with
                arguments =nextValue= and undefined.

          3. Else,

             1. [[https://tc39.es/ecma262/#assert][Assert]]: =lhsKind= is
                lexicalBinding.
             2. [[https://tc39.es/ecma262/#assert][Assert]]: =lhs= is a
                [[ForDeclaration][ForDeclaration]].
             3. Let =status= be BindingInitialization of =lhs= with
                arguments =nextValue= and =iterationEnv=.

      11. If =status= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], then

          1. Set the
             [[https://tc39.es/ecma262/#running-execution-context][running
             execution context]]'s LexicalEnvironment to =oldEnv=.
          2. If =iteratorKind= is async, return
             ? [[https://tc39.es/ecma262/#sec-asynciteratorclose][AsyncIteratorClose]](=iteratorRecord=,
             =status=).
          3. If =iterationKind= is enumerate, then

             1. Return =status=.

          4. Else,

             1. [[https://tc39.es/ecma262/#assert][Assert]]:
                =iterationKind= is iterate.
             2. Return
                ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
                =status=).

      12. Let =result= be the result of evaluating =stmt=.
      13. Set the
          [[https://tc39.es/ecma262/#running-execution-context][running
          execution context]]'s LexicalEnvironment to =oldEnv=.
      14. If
          [[https://tc39.es/ecma262/#sec-loopcontinues][LoopContinues]](=result=,
          =labelSet=) is false, then

          1. If =iterationKind= is enumerate, then

             1. Return
                [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=result=,
                =V=)).

          2. Else,

             1. [[https://tc39.es/ecma262/#assert][Assert]]:
                =iterationKind= is iterate.
             2. Set =status= to
                [[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=result=,
                =V=).
             3. If =iteratorKind= is async, return
                ? [[https://tc39.es/ecma262/#sec-asynciteratorclose][AsyncIteratorClose]](=iteratorRecord=,
                =status=).
             4. Return
                ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
                =status=).

      15. If =result=.[[Value]] is not empty, set =V= to
          =result=.[[Value]].

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-47
     :END:

   [[ForBinding][ForBinding]]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]]

   1. Let =bindingId= be StringValue of
      [[file:expressions.org::#BindingIdentifier][BindingIdentifier]].
   2. Return
      ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=bindingId=).

**** EnumerateObjectProperties ( =O= )
     :PROPERTIES:
     :CUSTOM_ID: enumerateobjectproperties-o
     :END:

   When the abstract operation EnumerateObjectProperties is called with
   argument =O=, the following steps are taken:

   1. [[https://tc39.es/ecma262/#assert][Assert]]:
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=O=)
      is Object.
   2. Return an Iterator object
      ([[https://tc39.es/ecma262/#sec-iterator-interface][25.1.1.2]]) whose
      =next= method iterates over all the String-valued keys of enumerable
      properties of =O=. The iterator object is never directly accessible
      to ECMAScript code. The mechanics and order of enumerating the
      properties is not specified but must conform to the rules specified
      below.

   The iterator's =throw= and =return= methods are null and are never
   invoked. The iterator's =next= method processes object properties to
   determine whether the property key should be returned as an iterator
   value. Returned property keys do not include keys that are Symbols.
   Properties of the target object may be deleted during enumeration. A
   property that is deleted before it is processed by the iterator's =next=
   method is ignored. If new properties are added to the target object
   during enumeration, the newly added properties are not guaranteed to be
   processed in the active enumeration. A
   [[https://tc39.es/ecma262/#property-name][property name]] will be
   returned by the iterator's =next= method at most once in any
   enumeration.

   Enumerating the properties of the target object includes enumerating
   properties of its prototype, and the prototype of the prototype, and so
   on, recursively; but a property of a prototype is not processed if it
   has the same name as a property that has already been processed by the
   iterator's =next= method. The values of [[Enumerable]] attributes are
   not considered when determining if a property of a prototype object has
   already been processed. The enumerable property names of prototype
   objects must be obtained by invoking EnumerateObjectProperties passing
   the prototype object as the argument. EnumerateObjectProperties must
   obtain the own property keys of the target object by calling its
   [[OwnPropertyKeys]] internal method. Property attributes of the target
   object must be obtained by calling its [[GetOwnProperty]] internal
   method.

   Note

   The following is an informative definition of an ECMAScript generator
   function that conforms to these rules:

   #+BEGIN_EXAMPLE
     function* EnumerateObjectProperties(obj) {
       const visited = new Set();
       for (const key of Reflect.ownKeys(obj)) {
         if (typeof key === "symbol") continue;
         const desc = Reflect.getOwnPropertyDescriptor(obj, key);
         if (desc) {
           visited.add(key);
           if (desc.enumerable) yield key;
         }
       }
       const proto = Reflect.getPrototypeOf(obj);
       if (proto === null) return;
       for (const protoKey of EnumerateObjectProperties(proto)) {
         if (!visited.has(protoKey)) yield protoKey;
       }
     }
   #+END_EXAMPLE

*** The =continue= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-continue-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-46
     :END:

  [[ContinueStatement][ContinueStatement]][Yield,
  Await]:continue; continue[no
  [[LineTerminator][LineTerminator]]
  here][[LabelIdentifier][LabelIdentifier]][?Yield,
  ?Await];
**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-17
     :END:

   [[ContinueStatement][ContinueStatement]]:continue;
   [[ContinueStatement][ContinueStatement]]:continue[[LabelIdentifier][LabelIdentifier]];

   - It is a Syntax Error if this
     [[ContinueStatement][ContinueStatement]]
     is not nested, directly or indirectly (but not crossing function
     boundaries), within an
     [[IterationStatement][IterationStatement]].

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-7
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[ContinueStatement][ContinueStatement]]:continue;

   1. Return false.

   [[ContinueStatement][ContinueStatement]]:continue[[LabelIdentifier][LabelIdentifier]];

   1. If the StringValue of
      [[LabelIdentifier][LabelIdentifier]] is
      not an element of =iterationSet=, return true.
   2. Return false.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-48
     :END:

   [[ContinueStatement][ContinueStatement]]:continue;

   1. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
      { [[Type]]: continue, [[Value]]: empty, [[Target]]: empty }.

   [[ContinueStatement][ContinueStatement]]:continue[[LabelIdentifier][LabelIdentifier]];

   1. Let =label= be the StringValue of
      [[LabelIdentifier][LabelIdentifier]].
   2. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
      { [[Type]]: continue, [[Value]]: empty, [[Target]]: =label= }.

*** The =break= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-break-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-47
     :END:

  [[BreakStatement][BreakStatement]][Yield,
  Await]:break; break[no
  [[LineTerminator][LineTerminator]]
  here][[LabelIdentifier][LabelIdentifier]][?Yield,
  ?Await];
**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-18
     :END:

   [[BreakStatement][BreakStatement]]:break;

   - It is a Syntax Error if this
     [[BreakStatement][BreakStatement]] is
     not nested, directly or indirectly (but not crossing function
     boundaries), within an
     [[IterationStatement][IterationStatement]]
     or a
     [[SwitchStatement][SwitchStatement]].

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-7
     :END:

   With parameter =labelSet=.

   [[BreakStatement][BreakStatement]]:break;

   1. Return false.

   [[BreakStatement][BreakStatement]]:break[[LabelIdentifier][LabelIdentifier]];

   1. If the StringValue of
      [[LabelIdentifier][LabelIdentifier]] is
      not an element of =labelSet=, return true.
   2. Return false.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-49
     :END:

   [[BreakStatement][BreakStatement]]:break;

   1. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
      { [[Type]]: break, [[Value]]: empty, [[Target]]: empty }.

   [[BreakStatement][BreakStatement]]:break[[LabelIdentifier][LabelIdentifier]];

   1. Let =label= be the StringValue of
      [[LabelIdentifier][LabelIdentifier]].
   2. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
      { [[Type]]: break, [[Value]]: empty, [[Target]]: =label= }.

*** The =return= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-return-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-48
     :END:
    
     #+NAME: ReturnStatement
     #+begin_quote
      [[ReturnStatement][ReturnStatement]][Yield, Await]:
       return; return[no [[LineTerminator][LineTerminator]] here][[Expression][Expression]][+In, ?Yield, ?Await];
     #+end_quote

     #+begin_src gerbil :noweb-ref return-statement
       (defstruct (return-statement statement) (expression) transparent: #t) 

       (def ReturnStatement
         (.let* ((expression (.begin (peek (tpt? 'IdentifierName))
                                     (tpv? "return")
                                     (.or Expression #f)))
                 (_ (token-value? #\;)))
           (return (return-statement expression))))
       (add-statement! ReturnStatement)
     #+end_src
   
   *Note* A =return= statement causes a function to cease execution and, in most
   cases, returns a value to the caller. If [[Expression][Expression]] is omitted, the return
   value is undefined. Otherwise, the return value is the value of [[Expression][Expression]]. A
   =return= statement may not actually return a value to the caller depending on
   surrounding context. For example, in a =try= block, a =return= statement's
   completion record may be replaced with another completion record during
   evaluation of the =finally= block.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-50
     :END:

   [[ReturnStatement][ReturnStatement]]:return;

   1. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
      { [[Type]]: return, [[Value]]: undefined, [[Target]]: empty }.

   [[ReturnStatement][ReturnStatement]]:return[[Expression][Expression]];

   1. Let =exprRef= be the result of evaluating
      [[Expression][Expression]].
   2. Let =exprValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).
   3. If
      ! [[https://tc39.es/ecma262/#sec-getgeneratorkind][GetGeneratorKind]]()
      is async, set =exprValue= to
      ? [[https://tc39.es/ecma262/#await][Await]](=exprValue=).
   4. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
      { [[Type]]: return, [[Value]]: =exprValue=, [[Target]]: empty }.

*** The =with= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-with-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-49
     :END:

  [[WithStatement][WithStatement]][Yield,
  Await,
  Return]:with([[Expression][Expression]][+In,
  ?Yield,
  ?Await])[[Statement][Statement]][?Yield,
  ?Await, ?Return] Note

  The =with= statement adds an object
  [[https://tc39.es/ecma262/#sec-environment-records][Environment Record]]
  for a computed object to the lexical environment of the
  [[https://tc39.es/ecma262/#running-execution-context][running execution
  context]]. It then executes a statement using this augmented lexical
  environment. Finally, it restores the original lexical environment.

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-19
     :END:

   [[WithStatement][WithStatement]]:with([[Expression][Expression]])[[Statement][Statement]]

   - It is a Syntax Error if the code that matches this production is
     contained in [[https://tc39.es/ecma262/#sec-strict-mode-code][strict
     mode code]].
   - It is a Syntax Error if
     [[https://tc39.es/ecma262/#sec-islabelledfunction][IsLabelledFunction]]([[Statement][Statement]])
     is true.

   Note

   It is only necessary to apply the second rule if the extension specified
   in
   [[https://tc39.es/ecma262/#sec-labelled-function-declarations][B.3.2]]
   is implemented.

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-7
     :END:

   With parameter =labelSet=.

   [[WithStatement][WithStatement]]:with([[Expression][Expression]])[[Statement][Statement]]

   1. Return ContainsDuplicateLabels of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-8
     :END:

   With parameter =labelSet=.

   [[WithStatement][WithStatement]]:with([[Expression][Expression]])[[Statement][Statement]]

   1. Return ContainsUndefinedBreakTarget of
      [[Statement][Statement]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-8
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[WithStatement][WithStatement]]:with([[Expression][Expression]])[[Statement][Statement]]

   1. Return ContainsUndefinedContinueTarget of
      [[Statement][Statement]] with arguments
      =iterationSet= and « ».

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-8
     :END:

   [[WithStatement][WithStatement]]:with([[Expression][Expression]])[[Statement][Statement]]

   1. Return the VarDeclaredNames of
      [[Statement][Statement]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-8
     :END:

   [[WithStatement][WithStatement]]:with([[Expression][Expression]])[[Statement][Statement]]

   1. Return the VarScopedDeclarations of
      [[Statement][Statement]].

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-51
     :END:

   [[WithStatement][WithStatement]]:with([[Expression][Expression]])[[Statement][Statement]]

   1. Let =val= be the result of evaluating
      [[Expression][Expression]].
   2. Let =obj= be ? [[https://tc39.es/ecma262/#sec-toobject][ToObject]](?
      [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=val=)).
   3. Let =oldEnv= be the
      [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment.
   4. Let =newEnv= be
      [[https://tc39.es/ecma262/#sec-newobjectenvironment][NewObjectEnvironment]](=obj=,
      =oldEnv=).
   5. Set the =withEnvironment= flag of =newEnv='s
      [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]]
      to true.
   6. Set the [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment to =newEnv=.
   7. Let =C= be the result of evaluating
      [[Statement][Statement]].
   8. Set the [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment to =oldEnv=.
   9. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=C=,
      undefined)).

   Note

   No matter how control leaves the embedded
   [[Statement][Statement]], whether normally
   or by some form of
   [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
   completion]] or exception, the LexicalEnvironment is always restored to
   its former state.

*** The =switch= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-switch-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-50
     :END:

  [[SwitchStatement][SwitchStatement]][Yield,
  Await,
  Return]:switch([[Expression][Expression]][+In,
  ?Yield,
  ?Await])[[CaseBlock][CaseBlock]][?Yield,
  ?Await, ?Return]
  [[CaseBlock][CaseBlock]][Yield, Await,
  Return]:{[[CaseClauses][CaseClauses]][?Yield,
  ?Await, ?Return]opt}
  {[[CaseClauses][CaseClauses]][?Yield,
  ?Await,
  ?Return]opt[[DefaultClause][DefaultClause]][?Yield,
  ?Await,
  ?Return][[CaseClauses][CaseClauses]][?Yield,
  ?Await, ?Return]opt}
  [[CaseClauses][CaseClauses]][Yield, Await,
  Return]:[[CaseClause][CaseClause]][?Yield,
  ?Await, ?Return]
  [[CaseClauses][CaseClauses]][?Yield,
  ?Await,
  ?Return][[CaseClause][CaseClause]][?Yield,
  ?Await, ?Return]
  [[CaseClause][CaseClause]][Yield, Await,
  Return]:case[[Expression][Expression]][+In,
  ?Yield,
  ?Await]:[[StatementList][StatementList]][?Yield,
  ?Await, ?Return]opt
  [[DefaultClause][DefaultClause]][Yield,
  Await,
  Return]:default:[[StatementList][StatementList]][?Yield,
  ?Await, ?Return]opt
**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-20
     :END:

   [[SwitchStatement][SwitchStatement]]:switch([[Expression][Expression]])[[CaseBlock][CaseBlock]]

   - It is a Syntax Error if the LexicallyDeclaredNames of
     [[CaseBlock][CaseBlock]] contains any
     duplicate entries.
   - It is a Syntax Error if any element of the LexicallyDeclaredNames of
     [[CaseBlock][CaseBlock]] also occurs in
     the VarDeclaredNames of
     [[CaseBlock][CaseBlock]].

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-8
     :END:

   With parameter =labelSet=.

   [[SwitchStatement][SwitchStatement]]:switch([[Expression][Expression]])[[CaseBlock][CaseBlock]]

   1. Return ContainsDuplicateLabels of
      [[CaseBlock][CaseBlock]] with argument
      =labelSet=.

   [[CaseBlock][CaseBlock]]:{}

   1. Return false.

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1. If the first
      [[CaseClauses][CaseClauses]] is
      present, then

      1. Let =hasDuplicates= be ContainsDuplicateLabels of the first
         [[CaseClauses][CaseClauses]] with
         argument =labelSet=.
      2. If =hasDuplicates= is true, return true.

   2. Let =hasDuplicates= be ContainsDuplicateLabels of
      [[DefaultClause][DefaultClause]] with
      argument =labelSet=.
   3. If =hasDuplicates= is true, return true.
   4. If the second
      [[CaseClauses][CaseClauses]] is not
      present, return false.
   5. Return ContainsDuplicateLabels of the second
      [[CaseClauses][CaseClauses]] with
      argument =labelSet=.

   [[CaseClauses][CaseClauses]]:[[CaseClauses][CaseClauses]][[CaseClause][CaseClause]]

   1. Let =hasDuplicates= be ContainsDuplicateLabels of
      [[CaseClauses][CaseClauses]] with
      argument =labelSet=.
   2. If =hasDuplicates= is true, return true.
   3. Return ContainsDuplicateLabels of
      [[CaseClause][CaseClause]] with
      argument =labelSet=.

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return ContainsDuplicateLabels of
      [[StatementList][StatementList]] with
      argument =labelSet=.
   2. Return false.

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return ContainsDuplicateLabels of
      [[StatementList][StatementList]] with
      argument =labelSet=.
   2. Return false.

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-9
     :END:

   With parameter =labelSet=.

   [[SwitchStatement][SwitchStatement]]:switch([[Expression][Expression]])[[CaseBlock][CaseBlock]]

   1. Return ContainsUndefinedBreakTarget of
      [[CaseBlock][CaseBlock]] with argument
      =labelSet=.

   [[CaseBlock][CaseBlock]]:{}

   1. Return false.

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1. If the first
      [[CaseClauses][CaseClauses]] is
      present, then

      1. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of the
         first [[CaseClauses][CaseClauses]]
         with argument =labelSet=.
      2. If =hasUndefinedLabels= is true, return true.

   2. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of
      [[DefaultClause][DefaultClause]] with
      argument =labelSet=.
   3. If =hasUndefinedLabels= is true, return true.
   4. If the second
      [[CaseClauses][CaseClauses]] is not
      present, return false.
   5. Return ContainsUndefinedBreakTarget of the second
      [[CaseClauses][CaseClauses]] with
      argument =labelSet=.

   [[CaseClauses][CaseClauses]]:[[CaseClauses][CaseClauses]][[CaseClause][CaseClause]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of
      [[CaseClauses][CaseClauses]] with
      argument =labelSet=.
   2. If =hasUndefinedLabels= is true, return true.
   3. Return ContainsUndefinedBreakTarget of
      [[CaseClause][CaseClause]] with
      argument =labelSet=.

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return ContainsUndefinedBreakTarget of
      [[StatementList][StatementList]] with
      argument =labelSet=.
   2. Return false.

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return ContainsUndefinedBreakTarget of
      [[StatementList][StatementList]] with
      argument =labelSet=.
   2. Return false.

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-9
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[SwitchStatement][SwitchStatement]]:switch([[Expression][Expression]])[[CaseBlock][CaseBlock]]

   1. Return ContainsUndefinedContinueTarget of
      [[CaseBlock][CaseBlock]] with arguments
      =iterationSet= and « ».

   [[CaseBlock][CaseBlock]]:{}

   1. Return false.

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1. If the first
      [[CaseClauses][CaseClauses]] is
      present, then

      1. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of the
         first [[CaseClauses][CaseClauses]]
         with arguments =iterationSet= and « ».
      2. If =hasUndefinedLabels= is true, return true.

   2. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of
      [[DefaultClause][DefaultClause]] with
      arguments =iterationSet= and « ».
   3. If =hasUndefinedLabels= is true, return true.
   4. If the second
      [[CaseClauses][CaseClauses]] is not
      present, return false.
   5. Return ContainsUndefinedContinueTarget of the second
      [[CaseClauses][CaseClauses]] with
      arguments =iterationSet= and « ».

   [[CaseClauses][CaseClauses]]:[[CaseClauses][CaseClauses]][[CaseClause][CaseClause]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of
      [[CaseClauses][CaseClauses]] with
      arguments =iterationSet= and « ».
   2. If =hasUndefinedLabels= is true, return true.
   3. Return ContainsUndefinedContinueTarget of
      [[CaseClause][CaseClause]] with
      arguments =iterationSet= and « ».

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return ContainsUndefinedContinueTarget of
      [[StatementList][StatementList]] with
      arguments =iterationSet= and « ».
   2. Return false.

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return ContainsUndefinedContinueTarget of
      [[StatementList][StatementList]] with
      arguments =iterationSet= and « ».
   2. Return false.

**** Static Semantics: LexicallyDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-lexicallydeclarednames-1
     :END:

   [[CaseBlock][CaseBlock]]:{}

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1. If the first
      [[CaseClauses][CaseClauses]] is
      present, let =names= be the LexicallyDeclaredNames of the first
      [[CaseClauses][CaseClauses]].
   2. Else, let =names= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   3. Append to =names= the elements of the LexicallyDeclaredNames of
      [[DefaultClause][DefaultClause]].
   4. If the second
      [[CaseClauses][CaseClauses]] is not
      present, return =names=.
   5. Return the result of appending to =names= the elements of the
      LexicallyDeclaredNames of the second
      [[CaseClauses][CaseClauses]].

   [[CaseClauses][CaseClauses]]:[[CaseClauses][CaseClauses]][[CaseClause][CaseClause]]

   1. Let =names= be LexicallyDeclaredNames of
      [[CaseClauses][CaseClauses]].
   2. Append to =names= the elements of the LexicallyDeclaredNames of
      [[CaseClause][CaseClause]].
   3. Return =names=.

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the LexicallyDeclaredNames of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the LexicallyDeclaredNames of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Static Semantics: LexicallyScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-lexicallyscopeddeclarations-1
     :END:

   [[CaseBlock][CaseBlock]]:{}

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1. If the first
      [[CaseClauses][CaseClauses]] is
      present, let =declarations= be the LexicallyScopedDeclarations of the
      first [[CaseClauses][CaseClauses]].
   2. Else, let =declarations= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   3. Append to =declarations= the elements of the
      LexicallyScopedDeclarations of
      [[DefaultClause][DefaultClause]].
   4. If the second
      [[CaseClauses][CaseClauses]] is not
      present, return =declarations=.
   5. Return the result of appending to =declarations= the elements of the
      LexicallyScopedDeclarations of the second
      [[CaseClauses][CaseClauses]].

   [[CaseClauses][CaseClauses]]:[[CaseClauses][CaseClauses]][[CaseClause][CaseClause]]

   1. Let =declarations= be LexicallyScopedDeclarations of
      [[CaseClauses][CaseClauses]].
   2. Append to =declarations= the elements of the
      LexicallyScopedDeclarations of
      [[CaseClause][CaseClause]].
   3. Return =declarations=.

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the LexicallyScopedDeclarations of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the LexicallyScopedDeclarations of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-9
     :END:

   [[SwitchStatement][SwitchStatement]]:switch([[Expression][Expression]])[[CaseBlock][CaseBlock]]

   1. Return the VarDeclaredNames of
      [[CaseBlock][CaseBlock]].

   [[CaseBlock][CaseBlock]]:{}

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1. If the first
      [[CaseClauses][CaseClauses]] is
      present, let =names= be the VarDeclaredNames of the first
      [[CaseClauses][CaseClauses]].
   2. Else, let =names= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   3. Append to =names= the elements of the VarDeclaredNames of
      [[DefaultClause][DefaultClause]].
   4. If the second
      [[CaseClauses][CaseClauses]] is not
      present, return =names=.
   5. Return the result of appending to =names= the elements of the
      VarDeclaredNames of the second
      [[CaseClauses][CaseClauses]].

   [[CaseClauses][CaseClauses]]:[[CaseClauses][CaseClauses]][[CaseClause][CaseClause]]

   1. Let =names= be VarDeclaredNames of
      [[CaseClauses][CaseClauses]].
   2. Append to =names= the elements of the VarDeclaredNames of
      [[CaseClause][CaseClause]].
   3. Return =names=.

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the VarDeclaredNames of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the VarDeclaredNames of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-9
     :END:

   [[SwitchStatement][SwitchStatement]]:switch([[Expression][Expression]])[[CaseBlock][CaseBlock]]

   1. Return the VarScopedDeclarations of
      [[CaseBlock][CaseBlock]].

   [[CaseBlock][CaseBlock]]:{}

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1. If the first
      [[CaseClauses][CaseClauses]] is
      present, let =declarations= be the VarScopedDeclarations of the first
      [[CaseClauses][CaseClauses]].
   2. Else, let =declarations= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   3. Append to =declarations= the elements of the VarScopedDeclarations of
      [[DefaultClause][DefaultClause]].
   4. If the second
      [[CaseClauses][CaseClauses]] is not
      present, return =declarations=.
   5. Return the result of appending to =declarations= the elements of the
      VarScopedDeclarations of the second
      [[CaseClauses][CaseClauses]].

   [[CaseClauses][CaseClauses]]:[[CaseClauses][CaseClauses]][[CaseClause][CaseClause]]

   1. Let =declarations= be VarScopedDeclarations of
      [[CaseClauses][CaseClauses]].
   2. Append to =declarations= the elements of the VarScopedDeclarations of
      [[CaseClause][CaseClause]].
   3. Return =declarations=.

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the VarScopedDeclarations of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]opt

   1. If the [[StatementList][StatementList]]
      is present, return the VarScopedDeclarations of
      [[StatementList][StatementList]].
   2. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Semantics: CaseBlockEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-caseblockevaluation
     :END:

   With parameter =input=.

   [[CaseBlock][CaseBlock]]:{}

   1. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](undefined).

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]}

   1. Let =V= be undefined.
   2. Let =A= be the
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      of [[CaseClause][CaseClause]] items in
      [[CaseClauses][CaseClauses]], in source
      text order.
   3. Let =found= be false.
   4. For each [[CaseClause][CaseClause]] =C=
      in =A=, do

      1. If =found= is false, then

         1. Set =found= to
            ? [[https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected][CaseClauseIsSelected]](=C=,
            =input=).

      2. If =found= is true, then

         1. Let =R= be the result of evaluating =C=.
         2. If =R=.[[Value]] is not empty, set =V= to =R=.[[Value]].
         3. If =R= is an
            [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
            completion]], return
            [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=R=,
            =V=)).

   5. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=V=).

   [[CaseBlock][CaseBlock]]:{[[CaseClauses][CaseClauses]]opt[[DefaultClause][DefaultClause]][[CaseClauses][CaseClauses]]opt}

   1.  Let =V= be undefined.
   2.  If the first
       [[CaseClauses][CaseClauses]] is
       present, then

       1. Let =A= be the
          [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
          of [[CaseClause][CaseClause]] items
          in the first
          [[CaseClauses][CaseClauses]], in
          source text order.

   3.  Else,

       1. Let =A= be « ».

   4.  Let =found= be false.
   5.  For each [[CaseClause][CaseClause]]
       =C= in =A=, do

       1. If =found= is false, then

          1. Set =found= to
             ? [[https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected][CaseClauseIsSelected]](=C=,
             =input=).

       2. If =found= is true, then

          1. Let =R= be the result of evaluating =C=.
          2. If =R=.[[Value]] is not empty, set =V= to =R=.[[Value]].
          3. If =R= is an
             [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
             completion]], return
             [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=R=,
             =V=)).

   6.  Let =foundInB= be false.
   7.  If the second
       [[CaseClauses][CaseClauses]] is
       present, then

       1. Let =B= be the
          [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
          of [[CaseClause][CaseClause]] items
          in the second
          [[CaseClauses][CaseClauses]], in
          source text order.

   8.  Else,

       1. Let =B= be « ».

   9.  If =found= is false, then

       1. For each [[CaseClause][CaseClause]]
          =C= in =B=, do

          1. If =foundInB= is false, then

             1. Set =foundInB= to
                ? [[https://tc39.es/ecma262/#sec-runtime-semantics-caseclauseisselected][CaseClauseIsSelected]](=C=,
                =input=).

          2. If =foundInB= is true, then

             1. Let =R= be the result of evaluating
                [[CaseClause][CaseClause]]
                =C=.
             2. If =R=.[[Value]] is not empty, set =V= to =R=.[[Value]].
             3. If =R= is an
                [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
                completion]], return
                [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=R=,
                =V=)).

   10. If =foundInB= is true, return
       [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=V=).
   11. Let =R= be the result of evaluating
       [[DefaultClause][DefaultClause]].
   12. If =R=.[[Value]] is not empty, set =V= to =R=.[[Value]].
   13. If =R= is an
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
       completion]], return
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=R=,
       =V=)).
   14. For each [[CaseClause][CaseClause]]
       =C= in =B= (NOTE: this is another complete iteration of the second
       [[CaseClauses][CaseClauses]]), do

       1. Let =R= be the result of evaluating
          [[CaseClause][CaseClause]] =C=.
       2. If =R=.[[Value]] is not empty, set =V= to =R=.[[Value]].
       3. If =R= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], return
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=R=,
          =V=)).

   15. Return
       [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=V=).

   <<sec-runtime-semantics-caseselectorevaluation>>
**** Runtime Semantics: CaseClauseIsSelected ( =C=, =input= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-caseclauseisselected-c-input
     :END:

   The abstract operation CaseClauseIsSelected, given
   [[CaseClause][CaseClause]] =C= and value
   =input=, determines whether =C= matches =input=.

   1. [[https://tc39.es/ecma262/#assert][Assert]]: =C= is an instance of
      the production
      [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]opt
      .
   2. Let =exprRef= be the result of evaluating the
      [[Expression][Expression]] of =C=.
   3. Let =clauseSelector= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).
   4. Return the result of performing
      [[https://tc39.es/ecma262/#sec-strict-equality-comparison][Strict
      Equality Comparison]] =input= === =clauseSelector=.

   Note

   This operation does not execute =C='s
   [[StatementList][StatementList]] (if any).
   The [[CaseBlock][CaseBlock]] algorithm
   uses its return value to determine which
   [[StatementList][StatementList]] to start
   executing.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-52
     :END:

   [[SwitchStatement][SwitchStatement]]:switch([[Expression][Expression]])[[CaseBlock][CaseBlock]]

   1. Let =exprRef= be the result of evaluating
      [[Expression][Expression]].
   2. Let =switchValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).
   3. Let =oldEnv= be the
      [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment.
   4. Let =blockEnv= be
      [[https://tc39.es/ecma262/#sec-newdeclarativeenvironment][NewDeclarativeEnvironment]](=oldEnv=).
   5. Perform
      [[https://tc39.es/ecma262/#sec-blockdeclarationinstantiation][BlockDeclarationInstantiation]]([[CaseBlock][CaseBlock]],
      =blockEnv=).
   6. Set the [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment to =blockEnv=.
   7. Let =R= be CaseBlockEvaluation of
      [[CaseBlock][CaseBlock]] with argument
      =switchValue=.
   8. Set the [[https://tc39.es/ecma262/#running-execution-context][running
      execution context]]'s LexicalEnvironment to =oldEnv=.
   9. Return =R=.

   Note

   No matter how control leaves the
   [[SwitchStatement][SwitchStatement]] the
   LexicalEnvironment is always restored to its former state.

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:

   1. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[CaseClause][CaseClause]]:case[[Expression][Expression]]:[[StatementList][StatementList]]

   1. Return the result of evaluating
      [[StatementList][StatementList]].

   [[DefaultClause][DefaultClause]]:default:

   1. Return
      [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   [[DefaultClause][DefaultClause]]:default:[[StatementList][StatementList]]

   1. Return the result of evaluating
      [[StatementList][StatementList]].

*** Labelled Statements
    :PROPERTIES:
    :CUSTOM_ID: labelled-statements
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-51
     :END:

  [[LabelledStatement][LabelledStatement]][Yield,
  Await,
  Return]:[[LabelIdentifier][LabelIdentifier]][?Yield,
  ?Await]:[[LabelledItem][LabelledItem]][?Yield,
  ?Await, ?Return]
  [[LabelledItem][LabelledItem]][Yield,
  Await,
  Return]:[[Statement][Statement]][?Yield,
  ?Await, ?Return]
  [[FunctionDeclaration][FunctionDeclaration]][?Yield,
  ?Await, ~Default] Note

  A [[Statement][Statement]] may be prefixed
  by a label. Labelled statements are only used in conjunction with
  labelled =break= and =continue= statements. ECMAScript has no =goto=
  statement. A [[Statement][Statement]] can
  be part of a
  [[LabelledStatement][LabelledStatement]],
  which itself can be part of a
  [[LabelledStatement][LabelledStatement]],
  and so on. The labels introduced this way are collectively referred to
  as the “current label set” when describing the semantics of individual
  statements.

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-21
     :END:

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   - It is a Syntax Error if any source text matches this rule.

   Note

   An alternative definition for this rule is provided in
   [[https://tc39.es/ecma262/#sec-labelled-function-declarations][B.3.2]].

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-9
     :END:

   With parameter =labelSet=.

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Let =label= be the StringValue of
      [[LabelIdentifier][LabelIdentifier]].
   2. If =label= is an element of =labelSet=, return true.
   3. Let =newLabelSet= be a copy of =labelSet= with =label= appended.
   4. Return ContainsDuplicateLabels of
      [[LabelledItem][LabelledItem]] with
      argument =newLabelSet=.

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return false.

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-10
     :END:

   With parameter =labelSet=.

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Let =label= be the StringValue of
      [[LabelIdentifier][LabelIdentifier]].
   2. Let =newLabelSet= be a copy of =labelSet= with =label= appended.
   3. Return ContainsUndefinedBreakTarget of
      [[LabelledItem][LabelledItem]] with
      argument =newLabelSet=.

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return false.

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-10
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Let =label= be the StringValue of
      [[LabelIdentifier][LabelIdentifier]].
   2. Let =newLabelSet= be a copy of =labelSet= with =label= appended.
   3. Return ContainsUndefinedContinueTarget of
      [[LabelledItem][LabelledItem]] with
      arguments =iterationSet= and =newLabelSet=.

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return false.

**** Static Semantics: IsLabelledFunction ( =stmt= )
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-islabelledfunction-stmt
     :END:

   The abstract operation IsLabelledFunction with argument =stmt= performs
   the following steps:

   1. If =stmt= is not a
      [[LabelledStatement][LabelledStatement]],
      return false.
   2. Let =item= be the
      [[LabelledItem][LabelledItem]] of
      =stmt=.
   3. If =item= is
      [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]
      , return true.
   4. Let =subStmt= be the
      [[Statement][Statement]] of =item=.
   5. Return
      [[https://tc39.es/ecma262/#sec-islabelledfunction][IsLabelledFunction]](=subStmt=).

**** Static Semantics: LexicallyDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-lexicallydeclarednames-2
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return the LexicallyDeclaredNames of
      [[LabelledItem][LabelledItem]].

   [[LabelledItem][LabelledItem]]:[[Statement][Statement]]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return BoundNames of
      [[FunctionDeclaration][FunctionDeclaration]].

**** Static Semantics: LexicallyScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-lexicallyscopeddeclarations-2
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return the LexicallyScopedDeclarations of
      [[LabelledItem][LabelledItem]].

   [[LabelledItem][LabelledItem]]:[[Statement][Statement]]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return a new
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing
      [[FunctionDeclaration][FunctionDeclaration]].

**** Static Semantics: TopLevelLexicallyDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-toplevellexicallydeclarednames-1
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Static Semantics: TopLevelLexicallyScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-toplevellexicallyscopeddeclarations-1
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Static Semantics: TopLevelVarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-toplevelvardeclarednames-1
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return the TopLevelVarDeclaredNames of
      [[LabelledItem][LabelledItem]].

   [[LabelledItem][LabelledItem]]:[[Statement][Statement]]

   1. If [[Statement][Statement]] is
      [[Statement][Statement]]:[[LabelledStatement][LabelledStatement]]
      , return TopLevelVarDeclaredNames of
      [[Statement][Statement]].
   2. Return VarDeclaredNames of
      [[Statement][Statement]].

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return BoundNames of
      [[FunctionDeclaration][FunctionDeclaration]].

**** Static Semantics: TopLevelVarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-toplevelvarscopeddeclarations-1
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return the TopLevelVarScopedDeclarations of
      [[LabelledItem][LabelledItem]].

   [[LabelledItem][LabelledItem]]:[[Statement][Statement]]

   1. If [[Statement][Statement]] is
      [[Statement][Statement]]:[[LabelledStatement][LabelledStatement]]
      , return TopLevelVarScopedDeclarations of
      [[Statement][Statement]].
   2. Return VarScopedDeclarations of
      [[Statement][Statement]].

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return a new
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing
      [[FunctionDeclaration][FunctionDeclaration]].

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-10
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return the VarDeclaredNames of
      [[LabelledItem][LabelledItem]].

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-10
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Return the VarScopedDeclarations of
      [[LabelledItem][LabelledItem]].

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

**** Runtime Semantics: LabelledEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-labelledevaluation-5
     :END:

   With parameter =labelSet=.

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Let =label= be the StringValue of
      [[LabelIdentifier][LabelIdentifier]].
   2. Append =label= as an element of =labelSet=.
   3. Let =stmtResult= be LabelledEvaluation of
      [[LabelledItem][LabelledItem]] with
      argument =labelSet=.
   4. If =stmtResult=.[[Type]] is break and
      [[https://tc39.es/ecma262/#sec-samevalue][SameValue]](=stmtResult=.[[Target]],
      =label=) is true, then

      1. Set =stmtResult= to
         [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](=stmtResult=.[[Value]]).

   5. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=stmtResult=).

   [[LabelledItem][LabelledItem]]:[[Statement][Statement]]

   1. If [[Statement][Statement]] is either a
      [[LabelledStatement][LabelledStatement]]
      or a
      [[BreakableStatement][BreakableStatement]],
      then

      1. Return LabelledEvaluation of
         [[Statement][Statement]] with
         argument =labelSet=.

   2. Else,

      1. Return the result of evaluating
         [[Statement][Statement]].

   [[LabelledItem][LabelledItem]]:[[FunctionDeclaration][FunctionDeclaration]]

   1. Return the result of evaluating
      [[FunctionDeclaration][FunctionDeclaration]].

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-53
     :END:

   [[LabelledStatement][LabelledStatement]]:[[LabelIdentifier][LabelIdentifier]]:[[LabelledItem][LabelledItem]]

   1. Let =newLabelSet= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   2. Return LabelledEvaluation of this
      [[LabelledStatement][LabelledStatement]]
      with argument =newLabelSet=.

*** The =throw= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-throw-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-52
     :END:

  [[ThrowStatement][ThrowStatement]][Yield,
  Await]:throw[no
  [[LineTerminator][LineTerminator]]
  here][[Expression][Expression]][+In,
  ?Yield, ?Await];
**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-54
     :END:

   [[ThrowStatement][ThrowStatement]]:throw[[Expression][Expression]];

   1. Let =exprRef= be the result of evaluating
      [[Expression][Expression]].
   2. Let =exprValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprRef=).
   3. Return
      [[https://tc39.es/ecma262/#sec-throwcompletion][ThrowCompletion]](=exprValue=).

*** The =try= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-try-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-53
     :END:

  [[TryStatement][TryStatement]][Yield,
  Await, Return]:try[[Block][Block]][?Yield,
  ?Await, ?Return][[Catch][Catch]][?Yield,
  ?Await, ?Return]
  try[[Block][Block]][?Yield, ?Await,
  ?Return][[Finally][Finally]][?Yield,
  ?Await, ?Return]
  try[[Block][Block]][?Yield, ?Await,
  ?Return][[Catch][Catch]][?Yield, ?Await,
  ?Return][[Finally][Finally]][?Yield,
  ?Await, ?Return] [[Catch][Catch]][Yield,
  Await,
  Return]:catch([[CatchParameter][CatchParameter]][?Yield,
  ?Await])[[Block][Block]][?Yield, ?Await,
  ?Return] catch[[Block][Block]][?Yield,
  ?Await, ?Return]
  [[Finally][Finally]][Yield, Await,
  Return]:finally[[Block][Block]][?Yield,
  ?Await, ?Return]
  [[CatchParameter][CatchParameter]][Yield,
  Await]:[[file:expressions.org::#BindingIdentifier][BindingIdentifier]][?Yield,
  ?Await]
  [[BindingPattern][BindingPattern]][?Yield,
  ?Await] Note

  The =try= statement encloses a block of code in which an exceptional
  condition can occur, such as a runtime error or a =throw= statement. The
  =catch= clause provides the exception-handling code. When a catch clause
  catches an exception, its
  [[CatchParameter][CatchParameter]] is
  bound to that exception.

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-22
     :END:

   [[Catch][Catch]]:catch([[CatchParameter][CatchParameter]])[[Block][Block]]

   - It is a Syntax Error if BoundNames of
     [[CatchParameter][CatchParameter]]
     contains any duplicate elements.
   - It is a Syntax Error if any element of the BoundNames of
     [[CatchParameter][CatchParameter]] also
     occurs in the LexicallyDeclaredNames of
     [[Block][Block]].
   - It is a Syntax Error if any element of the BoundNames of
     [[CatchParameter][CatchParameter]] also
     occurs in the VarDeclaredNames of
     [[Block][Block]].

   Note

   An alternative
   [[https://tc39.es/ecma262/#sec-static-semantic-rules][static semantics]]
   for this production is given in
   [[https://tc39.es/ecma262/#sec-variablestatements-in-catch-blocks][B.3.5]].

**** Static Semantics: ContainsDuplicateLabels
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsduplicatelabels-10
     :END:

   With parameter =labelSet=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]]

   1. Let =hasDuplicates= be ContainsDuplicateLabels of
      [[Block][Block]] with argument
      =labelSet=.
   2. If =hasDuplicates= is true, return true.
   3. Return ContainsDuplicateLabels of
      [[Catch][Catch]] with argument
      =labelSet=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Finally][Finally]]

   1. Let =hasDuplicates= be ContainsDuplicateLabels of
      [[Block][Block]] with argument
      =labelSet=.
   2. If =hasDuplicates= is true, return true.
   3. Return ContainsDuplicateLabels of
      [[Finally][Finally]] with argument
      =labelSet=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]][[Finally][Finally]]

   1. Let =hasDuplicates= be ContainsDuplicateLabels of
      [[Block][Block]] with argument
      =labelSet=.
   2. If =hasDuplicates= is true, return true.
   3. Let =hasDuplicates= be ContainsDuplicateLabels of
      [[Catch][Catch]] with argument
      =labelSet=.
   4. If =hasDuplicates= is true, return true.
   5. Return ContainsDuplicateLabels of
      [[Finally][Finally]] with argument
      =labelSet=.

   [[Catch][Catch]]:catch([[CatchParameter][CatchParameter]])[[Block][Block]]

   1. Return ContainsDuplicateLabels of
      [[Block][Block]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedBreakTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedbreaktarget-11
     :END:

   With parameter =labelSet=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of
      [[Block][Block]] with argument
      =labelSet=.
   2. If =hasUndefinedLabels= is true, return true.
   3. Return ContainsUndefinedBreakTarget of
      [[Catch][Catch]] with argument
      =labelSet=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Finally][Finally]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of
      [[Block][Block]] with argument
      =labelSet=.
   2. If =hasUndefinedLabels= is true, return true.
   3. Return ContainsUndefinedBreakTarget of
      [[Finally][Finally]] with argument
      =labelSet=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]][[Finally][Finally]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of
      [[Block][Block]] with argument
      =labelSet=.
   2. If =hasUndefinedLabels= is true, return true.
   3. Let =hasUndefinedLabels= be ContainsUndefinedBreakTarget of
      [[Catch][Catch]] with argument
      =labelSet=.
   4. If =hasUndefinedLabels= is true, return true.
   5. Return ContainsUndefinedBreakTarget of
      [[Finally][Finally]] with argument
      =labelSet=.

   [[Catch][Catch]]:catch([[CatchParameter][CatchParameter]])[[Block][Block]]

   1. Return ContainsUndefinedBreakTarget of
      [[Block][Block]] with argument
      =labelSet=.

**** Static Semantics: ContainsUndefinedContinueTarget
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-containsundefinedcontinuetarget-11
     :END:

   With parameters =iterationSet= and =labelSet=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of
      [[Block][Block]] with arguments
      =iterationSet= and « ».
   2. If =hasUndefinedLabels= is true, return true.
   3. Return ContainsUndefinedContinueTarget of
      [[Catch][Catch]] with arguments
      =iterationSet= and « ».

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Finally][Finally]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of
      [[Block][Block]] with arguments
      =iterationSet= and « ».
   2. If =hasUndefinedLabels= is true, return true.
   3. Return ContainsUndefinedContinueTarget of
      [[Finally][Finally]] with arguments
      =iterationSet= and « ».

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]][[Finally][Finally]]

   1. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of
      [[Block][Block]] with arguments
      =iterationSet= and « ».
   2. If =hasUndefinedLabels= is true, return true.
   3. Let =hasUndefinedLabels= be ContainsUndefinedContinueTarget of
      [[Catch][Catch]] with arguments
      =iterationSet= and « ».
   4. If =hasUndefinedLabels= is true, return true.
   5. Return ContainsUndefinedContinueTarget of
      [[Finally][Finally]] with arguments
      =iterationSet= and « ».

   [[Catch][Catch]]:catch([[CatchParameter][CatchParameter]])[[Block][Block]]

   1. Return ContainsUndefinedContinueTarget of
      [[Block][Block]] with arguments
      =iterationSet= and « ».

**** Static Semantics: VarDeclaredNames
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-vardeclarednames-11
     :END:

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]]

   1. Let =names= be VarDeclaredNames of
      [[Block][Block]].
   2. Append to =names= the elements of the VarDeclaredNames of
      [[Catch][Catch]].
   3. Return =names=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Finally][Finally]]

   1. Let =names= be VarDeclaredNames of
      [[Block][Block]].
   2. Append to =names= the elements of the VarDeclaredNames of
      [[Finally][Finally]].
   3. Return =names=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]][[Finally][Finally]]

   1. Let =names= be VarDeclaredNames of
      [[Block][Block]].
   2. Append to =names= the elements of the VarDeclaredNames of
      [[Catch][Catch]].
   3. Append to =names= the elements of the VarDeclaredNames of
      [[Finally][Finally]].
   4. Return =names=.

   [[Catch][Catch]]:catch([[CatchParameter][CatchParameter]])[[Block][Block]]

   1. Return the VarDeclaredNames of
      [[Block][Block]].

**** Static Semantics: VarScopedDeclarations
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-varscopeddeclarations-11
     :END:

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]]

   1. Let =declarations= be VarScopedDeclarations of
      [[Block][Block]].
   2. Append to =declarations= the elements of the VarScopedDeclarations of
      [[Catch][Catch]].
   3. Return =declarations=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Finally][Finally]]

   1. Let =declarations= be VarScopedDeclarations of
      [[Block][Block]].
   2. Append to =declarations= the elements of the VarScopedDeclarations of
      [[Finally][Finally]].
   3. Return =declarations=.

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]][[Finally][Finally]]

   1. Let =declarations= be VarScopedDeclarations of
      [[Block][Block]].
   2. Append to =declarations= the elements of the VarScopedDeclarations of
      [[Catch][Catch]].
   3. Append to =declarations= the elements of the VarScopedDeclarations of
      [[Finally][Finally]].
   4. Return =declarations=.

   [[Catch][Catch]]:catch([[CatchParameter][CatchParameter]])[[Block][Block]]

   1. Return the VarScopedDeclarations of
      [[Block][Block]].

**** Runtime Semantics: CatchClauseEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-catchclauseevaluation
     :END:

   With parameter =thrownValue=.

   [[Catch][Catch]]:catch([[CatchParameter][CatchParameter]])[[Block][Block]]

   1.  Let =oldEnv= be the
       [[https://tc39.es/ecma262/#running-execution-context][running
       execution context]]'s LexicalEnvironment.
   2.  Let =catchEnv= be
       [[https://tc39.es/ecma262/#sec-newdeclarativeenvironment][NewDeclarativeEnvironment]](=oldEnv=).
   3.  Let =catchEnvRec= be =catchEnv='s
       [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]].
   4.  For each element =argName= of the BoundNames of
       [[CatchParameter][CatchParameter]], do

       1. Perform ! =catchEnvRec=.CreateMutableBinding(=argName=, false).

   5.  Set the
       [[https://tc39.es/ecma262/#running-execution-context][running
       execution context]]'s LexicalEnvironment to =catchEnv=.
   6.  Let =status= be BindingInitialization of
       [[CatchParameter][CatchParameter]]
       with arguments =thrownValue= and =catchEnv=.
   7.  If =status= is an
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
       completion]], then

       1. Set the
          [[https://tc39.es/ecma262/#running-execution-context][running
          execution context]]'s LexicalEnvironment to =oldEnv=.
       2. Return
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=status=).

   8.  Let =B= be the result of evaluating
       [[Block][Block]].
   9.  Set the
       [[https://tc39.es/ecma262/#running-execution-context][running
       execution context]]'s LexicalEnvironment to =oldEnv=.
   10. Return
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=B=).

   [[Catch][Catch]]:catch[[Block][Block]]

   1. Return the result of evaluating
      [[Block][Block]].

   Note

   No matter how control leaves the
   [[Block][Block]] the LexicalEnvironment is
   always restored to its former state.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-55
     :END:

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]]

   1. Let =B= be the result of evaluating
      [[Block][Block]].
   2. If =B=.[[Type]] is throw, let =C= be CatchClauseEvaluation of
      [[Catch][Catch]] with argument
      =B=.[[Value]].
   3. Else, let =C= be =B=.
   4. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=C=,
      undefined)).

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Finally][Finally]]

   1. Let =B= be the result of evaluating
      [[Block][Block]].
   2. Let =F= be the result of evaluating
      [[Finally][Finally]].
   3. If =F=.[[Type]] is normal, set =F= to =B=.
   4. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=F=,
      undefined)).

   [[TryStatement][TryStatement]]:try[[Block][Block]][[Catch][Catch]][[Finally][Finally]]

   1. Let =B= be the result of evaluating
      [[Block][Block]].
   2. If =B=.[[Type]] is throw, let =C= be CatchClauseEvaluation of
      [[Catch][Catch]] with argument
      =B=.[[Value]].
   3. Else, let =C= be =B=.
   4. Let =F= be the result of evaluating
      [[Finally][Finally]].
   5. If =F=.[[Type]] is normal, set =F= to =C=.
   6. Return
      [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]([[https://tc39.es/ecma262/#sec-updateempty][UpdateEmpty]](=F=,
      undefined)).

*** The =debugger= Statement
    :PROPERTIES:
    :CUSTOM_ID: the-debugger-statement
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-54
     :END:

  [[DebuggerStatement][DebuggerStatement]]:debugger;
**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-56
     :END:

   Note

   Evaluating a
   [[DebuggerStatement][DebuggerStatement]]
   may allow an implementation to cause a breakpoint when run under a
   debugger. If a debugger is not present or active this statement has no
   observable effect.

   [[DebuggerStatement][DebuggerStatement]]:debugger;

   1. If an implementation-defined debugging facility is available and
      enabled, then

      1. Perform an implementation-defined debugging action.
      2. Let =result= be an implementation-defined
         [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]]
         value.

   2. Else,

      1. Let =result= be
         [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

   3. Return =result=.
