#+TITLE: Expressions

#+SEQ_TODO:   TODO(t) INPROGRESS(i) WAITING(w@) | DONE(d) CANCELED(c@)
An ~expression~ is one of the primary components within [[file:source-code.org][Source Code]]. We already
break up the source text into [[file:lexical.org][Lexical Tokens]], and now it is time to turn those
tokens into an AST.

#+begin_src gerbil :noweb-ref expression
  (defstruct expression ())
#+end_src

* Smooth Operators
There's a tonne of "operations".

   [[LogicalANDExpression][LogicalANDExpression]][In, Yield, Await]:
      [[BitwiseORExpression][BitwiseORExpression]][?In, ?Yield, ?Await]
   [[LogicalANDExpression][LogicalANDExpression]][?In, ?Yield, ?Await]&&[[BitwiseORExpression][BitwiseORExpression]][?In, ?Yield, ?Await]

The non-left-recursive abstraction of that is ~operator~.

#+begin_src gerbil :noweb-ref operator
  (def (parse-operator side op)
    (.or (.let* ((lhs side) (rhs (.begin (tpv? op) side)))
           (return (values lhs op rhs)))
         (.let* (s side) (return (values s #f #f)))))
#+end_src

#+begin_src gerbil
  (import :std/test)
  (def op-toks (lexify (tokenize "foo = bar;")))

  (run (.let* ((values lhs op rhs) (parse-operator Identifier "="))
         (check (identifier-name lhs) => "foo"))
       op-toks)
#+end_src

A lot of the time we take the ~lhs~ and ~rhs~ and make a struct with it. Syntax
to the rescue.

#+begin_src gerbil :noweb-ref operator
  (defstruct (operator expression) (lhs op rhs) transparent: #t)
  (defrules Operator ()
    ((_ maker side op)
     (.begin
       #t
       (.let* ((values lhs _ rhs) (parse-operator side op))
         (return (if rhs (maker lhs op rhs) lhs))))))
#+end_src

#+begin_src gerbil 
  (def TestEqualOP
    (Operator operator Identifier #\=))

  (let (top (run TestEqualOP op-toks))
    (check (identifier-name (operator-lhs top)) => "foo")
    (check (identifier-name (operator-rhs top)) => "bar"))
#+end_src

* No [[file:lexical.org::#LineTerminator][LineTerminator]] here? ~no-token-here~!

  Some parsers actually need to see if there is a [[file:lexical.org::#LineTerminator][LineTerminator]], but we
  lexically rid ourselves of those with [[file:lexical.org::#lexify-and-lex-tokens][Lexify: ~lex-tokens~]]. 

  However, that also still gives us access to the original token stream. Using
  that and some clever magic, we'll write a parser that runs that assertion.
  
  #+begin_src gerbil :noweb-ref no-token-here
    (def (no-token-here type)
      (def T-ITEM (.begin (.not (token-production-type? type)) ITEM))
      (def (find-token t)
        (.let* (t? T-ITEM)
          (if (eq? t? t) (return #t) (find-token t))))
      (def (.find-token t)
        (.let* (ts (next-source-tokens))
          (sat identity (return (run (find-token t) ts)))))
      (peek (.let* (t (peek T-ITEM)) (.find-token t)))) 
  #+end_src

  Must test it out as herbie says it's logical.

  #+begin_src gerbil
    (let ((notok (lexify "asd asd asd asd"))
          (yestok (lexify "asd \n asd asd asd")))
      (check (run (.begin ITEM (no-token-here 'LineTerminator)) yestok)
             => #f)
      (check (run (.begin ITEM (no-token-here 'LineTerminator)) notok)
             => #t))
  #+end_src

  

* /File/ expressions.ss
#+begin_src gerbil :tangle expressions.ss :noweb yes
  ;;; -*- Gerbil -*-
  ;;; (C) me at drewc.ca
  (import :drewc/smug :drewc/js-syntax/lexical) 
  (export #t)

  <<all-expressions>>
#+end_src


#+begin_src gerbil :noweb-ref all-expressions :noweb yes :comments noweb
<<expression>>
<<operator>>
<<no-token-here>>
<<id>>
<<id-ref>>
<<literal-exp>>
<<primary-expression-expression>>
<<member-expression>>
<<call-expression>>
<<new-expression>>
<<arguments>>
<<argument-list>>
<<spread-element>>
<<left-hand-side-expression>>
<<update-expression>>
<<unary-expression>>
<<exponentiation-expression>>
<<multiplicative-expression>>
<<multiplicative-operator>>
<<additive-expression>>
<<shift-expression>>
<<relational-expression>>
<<equality-expression>>
<<bitwise-expression>>
<<logical-and-expression>>
<<logical-or-expression>>
<<conditional-expression>>
<<assignment-expression>>
<<comma-operator-expression>>
#+end_src

* ECMAScript Language: Expressions
  :PROPERTIES:
  :CUSTOM_ID: ecmascript-language-expressions
  :END:

** Identifiers
   :PROPERTIES:
   :CUSTOM_ID: identifiers
   :END:

   #+begin_src gerbil :noweb-ref expression
     (defstruct (identifiers expression) ())
   #+end_src

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-identifiers
    :END:
   
    #+NAME: IdentifierReference
    #+begin_quote
      [[IdentifierReference][IdentifierReference]][Yield, Await]:
       [[Identifier][Identifier]] 
       [~Yield]yield 
       [~Await]await
    #+end_quote 

    #+begin_src gerbil :noweb-ref id-ref
      (defstruct (identifier-reference identifiers) (identifier) transparent: #t) 
      (def IdentifierReference
        (.let* (id Identifier) (return (identifier-reference id))))
    #+end_src

**** BindingIdentifier
     :PROPERTIES:
     :CUSTOM_ID: BindingIdentifier
     :END:

     #+NAME: BindingIdentifier
     #+begin_quote
     [[BindingIdentifier][BindingIdentifier]][Yield, Await]:
       [[Identifier][Identifier]] 
       yield 
       await
     #+end_quote


     #+begin_src gerbil :noweb-ref id-ref
       (defstruct (binding-identifier identifiers) (identifier) transparent: #t) 
       (def BindingIdentifier
         (.let* (id Identifier) (return (binding-identifier id))))
     #+end_src


     #+name: LabelIdentifier
     #+begin_quote
      [[LabelIdentifier][LabelIdentifier]][Yield, Await]:
        [[Identifier][Identifier]]
        [~Yield]yield 
        [~Await]await
     #+end_quote

     #+begin_src gerbil :noweb-ref id-ref
       (defstruct (label-identifier identifiers) (identifier) transparent: #t) 
       (def LabelIdentifier
         (.let* (id Identifier) (return (label-identifier id))))
     #+end_src
   
**** Identifier  
    #+begin_quote
     [[Identifier][Identifier]]:
       [[IdentifierName][IdentifierName]] but not [[ReservedWord][ReservedWord]] 
    #+end_quote

    #+begin_src gerbil :noweb-ref id
      (defstruct (identifier expression) (name) transparent: #t) 
      (def Identifier
        (.begin (peek (token-production-type? 'IdentifierName))
                (peek (token-production-value? (.not ReservedWord)))
                (.let* (t (item))
                  (return (identifier (token-production-value t))))))
    #+end_src
  Note

  =yield= and =await= are permitted as
  [[BindingIdentifier][BindingIdentifier]]
  in the grammar, and prohibited with
  [[https://tc39.es/ecma262/#sec-static-semantic-rules][static semantics]]
  below, to prohibit automatic semicolon insertion in cases such as

  #+BEGIN_EXAMPLE
    let
    await 0;
  #+END_EXAMPLE

*** Static Semantics: Early Errors
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-early-errors-2
    :END:

  [[BindingIdentifier][BindingIdentifier]]:[[Identifier][Identifier]]

  - It is a Syntax Error if the code matched by this production is
    contained in [[https://tc39.es/ecma262/#sec-strict-mode-code][strict
    mode code]] and the StringValue of
    [[Identifier][Identifier]] is
    "arguments" or "eval".

  [[IdentifierReference][IdentifierReference]]:yield
  [[BindingIdentifier][BindingIdentifier]]:yield
  [[LabelIdentifier][LabelIdentifier]]:yield

  - It is a Syntax Error if the code matched by this production is
    contained in [[https://tc39.es/ecma262/#sec-strict-mode-code][strict
    mode code]].

  [[IdentifierReference][IdentifierReference]]:await
  [[BindingIdentifier][BindingIdentifier]]:await
  [[LabelIdentifier][LabelIdentifier]]:await

  - It is a Syntax Error if the
    [[https://tc39.es/ecma262/#sec-context-free-grammars][goal symbol]] of
    the syntactic grammar is
    [[Module][Module]].

  [[BindingIdentifier][BindingIdentifier]]:yield

  - It is a Syntax Error if this production has a _{[Yield]} parameter.

  [[BindingIdentifier][BindingIdentifier]]:await

  - It is a Syntax Error if this production has an
    _{[[[https://tc39.es/ecma262/#await][Await]]]} parameter.

  [[IdentifierReference][IdentifierReference]][Yield,
  Await]:[[Identifier][Identifier]]
  [[BindingIdentifier][BindingIdentifier]][Yield,
  Await]:[[Identifier][Identifier]]
  [[LabelIdentifier][LabelIdentifier]][Yield,
  Await]:[[Identifier][Identifier]]

  - It is a Syntax Error if this production has a _{[Yield]} parameter and
    StringValue of
    [[Identifier][Identifier]] is "yield".
  - It is a Syntax Error if this production has an
    _{[[[https://tc39.es/ecma262/#await][Await]]]} parameter and
    StringValue of
    [[Identifier][Identifier]] is "await".

  [[Identifier][Identifier]]:[[IdentifierName][IdentifierName]]but
  not [[ReservedWord][ReservedWord]]

  - It is a Syntax Error if this phrase is contained in
    [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode code]]
    and the StringValue of
    [[IdentifierName][IdentifierName]] is:
    "implements", "interface", "let", "package", "private", "protected",
    "public", "static", or "yield".
  - It is a Syntax Error if the
    [[https://tc39.es/ecma262/#sec-context-free-grammars][goal symbol]] of
    the syntactic grammar is
    [[Module][Module]] and the StringValue
    of [[IdentifierName][IdentifierName]] is
    "await".
  - It is a Syntax Error if StringValue of
    [[IdentifierName][IdentifierName]] is
    the same String value as the StringValue of any
    [[ReservedWord][ReservedWord]] except
    for =yield= or =await=.

  Note

  StringValue of
  [[IdentifierName][IdentifierName]]
  normalizes any Unicode escape sequences in
  [[IdentifierName][IdentifierName]] hence
  such escapes cannot be used to write an
  [[Identifier][Identifier]] whose code
  point sequence is the same as a
  [[ReservedWord][ReservedWord]].

*** Static Semantics: BoundNames
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-boundnames
    :END:

  [[BindingIdentifier][BindingIdentifier]]:[[Identifier][Identifier]]

  1. Return a new
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
     containing the StringValue of
     [[Identifier][Identifier]].

  [[BindingIdentifier][BindingIdentifier]]:yield

  1. Return a new
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
     containing "yield".

  [[BindingIdentifier][BindingIdentifier]]:await

  1. Return a new
     [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
     containing "await".

  <<sec-identifiers-static-semantics-isvalidsimpleassignmenttarget>>
*** Static Semantics: AssignmentTargetType
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-assignmenttargettype
    :END:

  [[IdentifierReference][IdentifierReference]]:[[Identifier][Identifier]]

  1. If this
     [[IdentifierReference][IdentifierReference]]
     is contained in
     [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode code]]
     and StringValue of
     [[Identifier][Identifier]] is "eval" or
     "arguments", return invalid.
  2. Return simple.

  [[IdentifierReference][IdentifierReference]]:yield

  1. Return simple.

  [[IdentifierReference][IdentifierReference]]:await

  1. Return simple.

*** Static Semantics: StringValue
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-stringvalue-2
    :END:

  [[IdentifierReference][IdentifierReference]]:yield
  [[BindingIdentifier][BindingIdentifier]]:yield
  [[LabelIdentifier][LabelIdentifier]]:yield

  1. Return "yield".

  [[IdentifierReference][IdentifierReference]]:await
  [[BindingIdentifier][BindingIdentifier]]:await
  [[LabelIdentifier][LabelIdentifier]]:await

  1. Return "await".

  [[Identifier][Identifier]]:[[IdentifierName][IdentifierName]]but
  not [[ReservedWord][ReservedWord]]

  1. Return the StringValue of
     [[IdentifierName][IdentifierName]].

*** Runtime Semantics: BindingInitialization
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-bindinginitialization
    :END:

  With parameters =value= and =environment=.

  Note

  undefined is passed for =environment= to indicate that a
  [[https://tc39.es/ecma262/#sec-putvalue][PutValue]] operation should be
  used to assign the initialization value. This is the case for =var=
  statements and formal parameter lists of some non-strict functions (See
  [[https://tc39.es/ecma262/#sec-functiondeclarationinstantiation][9.2.10]]).
  In those cases a lexical binding is hoisted and preinitialized prior to
  evaluation of its initializer.

  [[BindingIdentifier][BindingIdentifier]]:[[Identifier][Identifier]]

  1. Let =name= be StringValue of
     [[Identifier][Identifier]].
  2. Return
     ? [[https://tc39.es/ecma262/#sec-initializeboundname][InitializeBoundName]](=name=,
     =value=, =environment=).

  [[BindingIdentifier][BindingIdentifier]]:yield

  1. Return
     ? [[https://tc39.es/ecma262/#sec-initializeboundname][InitializeBoundName]]("yield",
     =value=, =environment=).

  [[BindingIdentifier][BindingIdentifier]]:await

  1. Return
     ? [[https://tc39.es/ecma262/#sec-initializeboundname][InitializeBoundName]]("await",
     =value=, =environment=).

**** Runtime Semantics: InitializeBoundName ( =name=, =value=,
   =environment= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-initializeboundname-name-value-environment
     :END:

   1. [[https://tc39.es/ecma262/#assert][Assert]]:
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=name=)
      is String.
   2. If =environment= is not undefined, then

      1. Let =env= be the
         [[https://tc39.es/ecma262/#sec-lexical-environments][EnvironmentRecord]]
         component of =environment=.
      2. Perform =env=.InitializeBinding(=name=, =value=).
      3. Return
         [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](undefined).

   3. Else,

      1. Let =lhs= be
         [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=name=).
      2. Return
         ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=,
         =value=).

*** Runtime Semantics: Evaluation
    :PROPERTIES:
    :CUSTOM_ID: runtime-semantics-evaluation
    :END:

  [[IdentifierReference][IdentifierReference]]:[[Identifier][Identifier]]

  1. Return
     ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](StringValue
     of [[Identifier][Identifier]]).

  [[IdentifierReference][IdentifierReference]]:yield

  1. Return
     ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]]("yield").

  [[IdentifierReference][IdentifierReference]]:await

  1. Return
     ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]]("await").

  Note 1

  The result of evaluating an
  [[IdentifierReference][IdentifierReference]]
  is always a value of type
  [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]].

  Note 2

  In [[https://tc39.es/ecma262/#non-strict-code][non-strict code]], the
  [[https://tc39.es/ecma262/#sec-keywords-and-reserved-words][keyword]]
  =yield= may be used as an identifier. Evaluating the
  [[IdentifierReference][IdentifierReference]]
  resolves the binding of =yield= as if it was an
  [[Identifier][Identifier]]. Early Error
  restriction ensures that such an evaluation only can occur for
  [[https://tc39.es/ecma262/#non-strict-code][non-strict code]].

** Primary Expression
   :PROPERTIES:
   :CUSTOM_ID: primary-expression
   :END:

*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-17
    :END:

**** PrimaryExpression
  
  #+begin_quote
  [[PrimaryExpression][PrimaryExpression]][Yield, Await]:
   this
  [[IdentifierReference][IdentifierReference]][?Yield, ?Await]
  [[Literal][Literal]]
  [[ArrayLiteral][ArrayLiteral]][?Yield, ?Await]
  [[ObjectLiteral][ObjectLiteral]][?Yield, ?Await]
  [[FunctionExpression][FunctionExpression]]
  [[ClassExpression][ClassExpression]][?Yield, ?Await]
  [[GeneratorExpression][GeneratorExpression]]
  [[AsyncFunctionExpression][AsyncFunctionExpression]]
  [[AsyncGeneratorExpression][AsyncGeneratorExpression]]
  [[RegularExpressionLiteral][RegularExpressionLiteral]]
  [[TemplateLiteral][TemplateLiteral]][?Yield ?Await, ~Tagged]
  [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]][?Yield, ?Await] 
  #+end_quote

  #+begin_src gerbil :noweb-ref primary-expression-expression
    (def PrimaryExpression 
      (.begin #t (.or IdentifierReference Literal)))
  #+end_src
  [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]][Yield, Await]:
  ([[Expression][Expression]][+In,?Yield, ?Await])
  ([[Expression][Expression]][+In, ?Yield, ?Await],) ()
  (...[[BindingIdentifier][BindingIdentifier]][?Yield, ?Await])
  (...[[BindingPattern][BindingPattern]][?Yield, ?Await]) 
  ([[Expression][Expression]][+In, ?Yield, ?Await],...[[BindingIdentifier][BindingIdentifier]][?Yield, ?Await])
  ([[Expression][Expression]][+In, ?Yield, ?Await],...[[BindingPattern][BindingPattern]][?Yield, ?Await])
*** Supplemental Syntax
    :PROPERTIES:
    :CUSTOM_ID: supplemental-syntax
    :END:

 When processing an instance of the production\\
 [[PrimaryExpression][PrimaryExpression]][Yield,
 Await]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]][?Yield,
 ?Await]\\
 the interpretation of
 [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]
 is refined using the following grammar:

 [[ParenthesizedExpression][ParenthesizedExpression]][Yield,
 Await]:([[Expression][Expression]][+In,
 ?Yield, ?Await])
*** Semantics
    :PROPERTIES:
    :CUSTOM_ID: semantics
    :END:

**** Static Semantics: CoveredParenthesizedExpression
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-coveredparenthesizedexpression
     :END:

   [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]:([[Expression][Expression]])

   1. Return the
      [[ParenthesizedExpression][ParenthesizedExpression]]
      that is [[https://tc39.es/ecma262/#sec-syntactic-grammar][covered]]
      by
      [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].

**** Static Semantics: HasName
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-hasname
     :END:

   [[PrimaryExpression][PrimaryExpression]]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]

   1. Let =expr= be CoveredParenthesizedExpression of
      [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].
   2. If IsFunctionDefinition of =expr= is false, return false.
   3. Return HasName of =expr=.

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition
     :END:

   [[PrimaryExpression][PrimaryExpression]]:this
   [[IdentifierReference][IdentifierReference]]
   [[Literal][Literal]]
   [[ArrayLiteral][ArrayLiteral]]
   [[ObjectLiteral][ObjectLiteral]]
   [[RegularExpressionLiteral][RegularExpressionLiteral]]
   [[TemplateLiteral][TemplateLiteral]]

   1. Return false.

   [[PrimaryExpression][PrimaryExpression]]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]

   1. Let =expr= be CoveredParenthesizedExpression of
      [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].
   2. Return IsFunctionDefinition of =expr=.

**** Static Semantics: IsIdentifierRef
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isidentifierref
     :END:

   [[PrimaryExpression][PrimaryExpression]]:[[IdentifierReference][IdentifierReference]]

   1. Return true.

   [[PrimaryExpression][PrimaryExpression]]:this
   [[Literal][Literal]]
   [[ArrayLiteral][ArrayLiteral]]
   [[ObjectLiteral][ObjectLiteral]]
   [[FunctionExpression][FunctionExpression]]
   [[ClassExpression][ClassExpression]]
   [[GeneratorExpression][GeneratorExpression]]
   [[AsyncFunctionExpression][AsyncFunctionExpression]]
   [[AsyncGeneratorExpression][AsyncGeneratorExpression]]
   [[RegularExpressionLiteral][RegularExpressionLiteral]]
   [[TemplateLiteral][TemplateLiteral]]
   [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]

   1. Return false.

   <<sec-semantics-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-1
     :END:

   [[PrimaryExpression][PrimaryExpression]]:this
   [[Literal][Literal]]
   [[ArrayLiteral][ArrayLiteral]]
   [[ObjectLiteral][ObjectLiteral]]
   [[FunctionExpression][FunctionExpression]]
   [[ClassExpression][ClassExpression]]
   [[GeneratorExpression][GeneratorExpression]]
   [[AsyncFunctionExpression][AsyncFunctionExpression]]
   [[AsyncGeneratorExpression][AsyncGeneratorExpression]]
   [[RegularExpressionLiteral][RegularExpressionLiteral]]
   [[TemplateLiteral][TemplateLiteral]]

   1. Return invalid.

   [[PrimaryExpression][PrimaryExpression]]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]

   1. Let =expr= be CoveredParenthesizedExpression of
      [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].
   2. Return AssignmentTargetType of =expr=.

**** The =this= Keyword
     :PROPERTIES:
     :CUSTOM_ID: the-this-keyword
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-1
      :END:

    [[PrimaryExpression][PrimaryExpression]]:this

    1. Return
       ? [[https://tc39.es/ecma262/#sec-resolvethisbinding][ResolveThisBinding]]().

**** Identifier Reference
     :PROPERTIES:
     :CUSTOM_ID: identifier-reference
     :END:

   See [[https://tc39.es/ecma262/#sec-identifiers][12.1]] for
   [[IdentifierReference][IdentifierReference]].

**** Literals
     :PROPERTIES:
     :CUSTOM_ID: literals-1
     :END:

***** Syntax
      :PROPERTIES:
      :CUSTOM_ID: syntax-18
      :END:

****** ~Literal~
       :PROPERTIES:
       :CUSTOM_ID: Literal
       :END:

    [[Literal][Literal]]:
     [[NullLiteral][NullLiteral]]
     [[BooleanLiteral][BooleanLiteral]]
     [[NumericLiteral][NumericLiteral]]
     [[StringLiteral][StringLiteral]]

     #+begin_src gerbil :noweb-ref literal-exp
       (defstruct (literal expression) (value) transparent: #t)
       (defstruct (null-literal literal) () transparent: #t)
       (defstruct (boolean-literal literal) () transparent: #t)
       (defstruct (numeric-literal literal) () transparent: #t)
       (defstruct (string-literal literal) () transparent: #t)

       (def Literal
         (.or (.let* (l NullLiteral) (return (null-literal
                                               (tpv l))))

              (.let* (l BooleanLiteral) (return (boolean-literal (tpv l))))
              (.let* (t (.begin (peek (tpt? 'StringLiteral)) (item)))
                (return (string-literal (tpv t))))
              (.let* (t (.begin (peek (tpt? 'NumericLiteral)) (item)))
                (return (numeric-literal (tpv t))))))


     #+end_src

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-2
      :END:

    [[Literal][Literal]]:[[NullLiteral][NullLiteral]]

    1. Return null.

    [[Literal][Literal]]:[[BooleanLiteral][BooleanLiteral]]

    1. If [[BooleanLiteral][BooleanLiteral]]
       is the token =false=, return false.
    2. If [[BooleanLiteral][BooleanLiteral]]
       is the token =true=, return true.

    [[Literal][Literal]]:[[NumericLiteral][NumericLiteral]]

    1. Return the NumericValue of
       [[NumericLiteral][NumericLiteral]] as
       defined in
       [[https://tc39.es/ecma262/#sec-literals-numeric-literals][11.8.3]].

    [[Literal][Literal]]:[[StringLiteral][StringLiteral]]

    1. Return the StringValue of
       [[StringLiteral][StringLiteral]] as
       defined in
       [[https://tc39.es/ecma262/#sec-string-literals-static-semantics-stringvalue][11.8.4.1]].

**** Array Initializer
     :PROPERTIES:
     :CUSTOM_ID: array-initializer
     :END:

   Note

   An [[ArrayLiteral][ArrayLiteral]] is an
   expression describing the initialization of an Array object, using a
   list, of zero or more expressions each of which represents an array
   element, enclosed in square brackets. The elements need not be literals;
   they are evaluated each time the array initializer is evaluated.

   Array elements may be elided at the beginning, middle or end of the
   element list. Whenever a comma in the element list is not preceded by an
   [[AssignmentExpression][AssignmentExpression]]
   (i.e., a comma at the beginning or after another comma), the missing
   array element contributes to the length of the Array and increases the
   index of subsequent elements. Elided array elements are not defined. If
   an element is elided at the end of an array, that element does not
   contribute to the length of the Array.

***** Syntax
      :PROPERTIES:
      :CUSTOM_ID: syntax-19
      :END:

   [[ArrayLiteral][ArrayLiteral]][Yield,
   Await]:[[[Elision][Elision]]opt]
   [[[ElementList][ElementList]][?Yield,
   ?Await]]
   [[[ElementList][ElementList]][?Yield,
   ?Await],[[Elision][Elision]]opt]
   [[ElementList][ElementList]][Yield,
   Await]:[[Elision][Elision]]opt[[AssignmentExpression][AssignmentExpression]][+In,
   ?Yield, ?Await]
   [[Elision][Elision]]opt[[SpreadElement][SpreadElement]][?Yield,
   ?Await]
   [[ElementList][ElementList]][?Yield,
   ?Await],[[Elision][Elision]]opt[[AssignmentExpression][AssignmentExpression]][+In,
   ?Yield, ?Await]
   [[ElementList][ElementList]][?Yield,
   ?Await],[[Elision][Elision]]opt[[SpreadElement][SpreadElement]][?Yield,
   ?Await] [[Elision][Elision]]:,
   [[Elision][Elision]],

***** SpreadElement 

   [[SpreadElement][SpreadElement]][Yield, Await]:
     ...[[AssignmentExpression][AssignmentExpression]][+In, ?Yield, ?Await] 

     #+begin_src gerbil :noweb-ref spread-element
       (defstruct (spread-element expression) (expression) transparent: #t)
       (def SpreadElement (.let* ((_ (tpv? "..."))
                                  (e AssignmentExpression))
                            (return (spread-element e))))
     #+end_src

  <<sec-static-semantics-elisionwidth>>
**** Runtime Semantics: ArrayAccumulation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-arrayaccumulation
     :END:

   With parameters =array= and =nextIndex=.

   [[Elision][Elision]]:,

   1. Let =len= be =nextIndex= + 1.
   2. Perform
      ? [[https://tc39.es/ecma262/#sec-set-o-p-v-throw][Set]](=array=,
      "length", =len=, true).
   3. NOTE: The above Set throws if =len= exceeds 2^{32}-1.
   4. Return =len=.

   [[Elision][Elision]]:[[Elision][Elision]],

   1. Return the result of performing ArrayAccumulation for
      [[Elision][Elision]] with arguments
      =array= and =nextIndex= + 1.

   [[ElementList][ElementList]]:[[Elision][Elision]]opt[[AssignmentExpression][AssignmentExpression]]

   1. If [[Elision][Elision]] is present,
      then

      1. Set =nextIndex= to the result of performing ArrayAccumulation for
         [[Elision][Elision]] with arguments
         =array= and =nextIndex=.
      2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextIndex=).

   2. Let =initResult= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   3. Let =initValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=initResult=).
   4. Let =created= be
      ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=array=,
      ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=nextIndex=),
      =initValue=).
   5. Return =nextIndex= + 1.

   [[ElementList][ElementList]]:[[Elision][Elision]]opt[[SpreadElement][SpreadElement]]

   1. If [[Elision][Elision]] is present,
      then

      1. Set =nextIndex= to the result of performing ArrayAccumulation for
         [[Elision][Elision]] with arguments
         =array= and =nextIndex=.
      2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextIndex=).

   2. Return the result of performing ArrayAccumulation for
      [[SpreadElement][SpreadElement]] with
      arguments =array= and =nextIndex=.

   [[ElementList][ElementList]]:[[ElementList][ElementList]],[[Elision][Elision]]opt[[AssignmentExpression][AssignmentExpression]]

   1. Set =nextIndex= to the result of performing ArrayAccumulation for
      [[ElementList][ElementList]] with
      arguments =array= and =nextIndex=.
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextIndex=).
   3. If [[Elision][Elision]] is present,
      then

      1. Set =nextIndex= to the result of performing ArrayAccumulation for
         [[Elision][Elision]] with arguments
         =array= and =nextIndex=.
      2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextIndex=).

   4. Let =initResult= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   5. Let =initValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=initResult=).
   6. Let =created= be
      ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=array=,
      ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=nextIndex=),
      =initValue=).
   7. Return =nextIndex= + 1.

   [[ElementList][ElementList]]:[[ElementList][ElementList]],[[Elision][Elision]]opt[[SpreadElement][SpreadElement]]

   1. Set =nextIndex= to the result of performing ArrayAccumulation for
      [[ElementList][ElementList]] with
      arguments =array= and =nextIndex=.
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextIndex=).
   3. If [[Elision][Elision]] is present,
      then

      1. Set =nextIndex= to the result of performing ArrayAccumulation for
         [[Elision][Elision]] with arguments
         =array= and =nextIndex=.
      2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextIndex=).

   4. Return the result of performing ArrayAccumulation for
      [[SpreadElement][SpreadElement]] with
      arguments =array= and =nextIndex=.

   [[SpreadElement][SpreadElement]]:...[[AssignmentExpression][AssignmentExpression]]

   1. Let =spreadRef= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   2. Let =spreadObj= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=spreadRef=).
   3. Let =iteratorRecord= be
      ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=spreadObj=).
   4. Repeat,

      1. Let =next= be
         ? [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
      2. If =next= is false, return =nextIndex=.
      3. Let =nextValue= be
         ? [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
      4. Perform
         ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=array=,
         ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=nextIndex=),
         =nextValue=).
      5. Set =nextIndex= to =nextIndex= + 1.

   Note

   [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]]
   is used to ensure that own properties are defined for the array even if
   the standard built-in Array prototype object has been modified in a
   manner that would preclude the creation of new own properties using
   [[Set]].

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-3
     :END:

   [[ArrayLiteral][ArrayLiteral]]:[[[Elision][Elision]]opt]

   1. Let =array= be
      ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](0).
   2. If [[Elision][Elision]] is present,
      then

      1. Let =len= be the result of performing ArrayAccumulation for
         [[Elision][Elision]] with arguments
         =array= and 0.
      2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=len=).

   3. Return =array=.

   [[ArrayLiteral][ArrayLiteral]]:[[[ElementList][ElementList]]]

   1. Let =array= be
      ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](0).
   2. Let =len= be the result of performing ArrayAccumulation for
      [[ElementList][ElementList]] with
      arguments =array= and 0.
   3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=len=).
   4. Return =array=.

   [[ArrayLiteral][ArrayLiteral]]:[[[ElementList][ElementList]],[[Elision][Elision]]opt]

   1. Let =array= be
      ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](0).
   2. Let =nextIndex= be the result of performing ArrayAccumulation for
      [[ElementList][ElementList]] with
      arguments =array= and 0.
   3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextIndex=).
   4. If [[Elision][Elision]] is present,
      then

      1. Let =len= be the result of performing ArrayAccumulation for
         [[Elision][Elision]] with arguments
         =array= and =nextIndex=.
      2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=len=).

   5. Return =array=.

*** Object Initializer
    :PROPERTIES:
    :CUSTOM_ID: object-initializer
    :END:

  Note 1

  An object initializer is an expression describing the initialization of
  an Object, written in a form resembling a literal. It is a list of zero
  or more pairs of property keys and associated values, enclosed in curly
  brackets. The values need not be literals; they are evaluated each time
  the object initializer is evaluated.

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-20
     :END:

  [[ObjectLiteral][ObjectLiteral]][Yield,
  Await]:{}
  {[[PropertyDefinitionList][PropertyDefinitionList]][?Yield,
  ?Await]}
  {[[PropertyDefinitionList][PropertyDefinitionList]][?Yield,
  ?Await],}
  [[PropertyDefinitionList][PropertyDefinitionList]][Yield,
  Await]:[[PropertyDefinition][PropertyDefinition]][?Yield,
  ?Await]
  [[PropertyDefinitionList][PropertyDefinitionList]][?Yield,
  ?Await],[[PropertyDefinition][PropertyDefinition]][?Yield,
  ?Await]
  [[PropertyDefinition][PropertyDefinition]][Yield,
  Await]:[[IdentifierReference][IdentifierReference]][?Yield,
  ?Await]
  [[CoverInitializedName][CoverInitializedName]][?Yield,
  ?Await]
  [[PropertyName][PropertyName]][?Yield,
  ?Await]:[[AssignmentExpression][AssignmentExpression]][+In,
  ?Yield, ?Await]
  [[MethodDefinition][MethodDefinition]][?Yield,
  ?Await]
  ...[[AssignmentExpression][AssignmentExpression]][+In,
  ?Yield, ?Await]
  [[PropertyName][PropertyName]][Yield,
  Await]:[[LiteralPropertyName][LiteralPropertyName]]
  [[ComputedPropertyName][ComputedPropertyName]][?Yield,
  ?Await]
  [[LiteralPropertyName][LiteralPropertyName]]:[[IdentifierName][IdentifierName]]
  [[StringLiteral][StringLiteral]]
  [[NumericLiteral][NumericLiteral]]
  [[ComputedPropertyName][ComputedPropertyName]][Yield,
  Await]:[[[AssignmentExpression][AssignmentExpression]][+In,
  ?Yield, ?Await]]
  [[CoverInitializedName][CoverInitializedName]][Yield,
  Await]:[[IdentifierReference][IdentifierReference]][?Yield,
  ?Await][[Initializer][Initializer]][+In,
  ?Yield, ?Await]
  [[Initializer][Initializer]][In, Yield,
  Await]:=[[AssignmentExpression][AssignmentExpression]][?In,
  ?Yield, ?Await] Note 2

  [[MethodDefinition][MethodDefinition]] is
  defined in [[https://tc39.es/ecma262/#sec-method-definitions][14.3]].

  Note 3

  In certain contexts,
  [[ObjectLiteral][ObjectLiteral]] is used
  as a cover grammar for a more restricted secondary grammar. The
  [[CoverInitializedName][CoverInitializedName]]
  production is necessary to fully cover these secondary grammars.
  However, use of this production results in an early Syntax Error in
  normal contexts where an actual
  [[ObjectLiteral][ObjectLiteral]] is
  expected.

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-3
     :END:

   [[PropertyDefinition][PropertyDefinition]]:[[MethodDefinition][MethodDefinition]]

   - It is a Syntax Error if HasDirectSuper of
     [[MethodDefinition][MethodDefinition]]
     is true.

   In addition to describing an actual object initializer the
   [[ObjectLiteral][ObjectLiteral]]
   productions are also used as a cover grammar for
   [[ObjectAssignmentPattern][ObjectAssignmentPattern]]
   and may be recognized as part of a
   [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].
   When [[ObjectLiteral][ObjectLiteral]]
   appears in a context where
   [[ObjectAssignmentPattern][ObjectAssignmentPattern]]
   is required the following Early Error rules are *not* applied. In
   addition, they are not applied when initially parsing a
   [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]
   or
   [[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]].

   [[PropertyDefinition][PropertyDefinition]]:[[CoverInitializedName][CoverInitializedName]]

   - Always throw a Syntax Error if code matches this production.

   Note

   This production exists so that
   [[ObjectLiteral][ObjectLiteral]] can serve
   as a cover grammar for
   [[ObjectAssignmentPattern][ObjectAssignmentPattern]].
   It cannot occur in an actual object initializer.

**** Static Semantics: ComputedPropertyContains
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-computedpropertycontains
     :END:

   With parameter =symbol=.

   [[PropertyName][PropertyName]]:[[LiteralPropertyName][LiteralPropertyName]]

   1. Return false.

   [[PropertyName][PropertyName]]:[[ComputedPropertyName][ComputedPropertyName]]

   1. Return the result of
      [[ComputedPropertyName][ComputedPropertyName]]
      Contains =symbol=.

**** Static Semantics: Contains
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-contains
     :END:

   With parameter =symbol=.

   [[PropertyDefinition][PropertyDefinition]]:[[MethodDefinition][MethodDefinition]]

   1. If =symbol= is
      [[MethodDefinition][MethodDefinition]],
      return true.
   2. Return the result of ComputedPropertyContains for
      [[MethodDefinition][MethodDefinition]]
      with argument =symbol=.

   Note

   Static semantic rules that depend upon substructure generally do not
   look into function definitions.

   [[LiteralPropertyName][LiteralPropertyName]]:[[IdentifierName][IdentifierName]]

   1. If =symbol= is a
      [[ReservedWord][ReservedWord]], return
      false.
   2. If =symbol= is an
      [[Identifier][Identifier]] and
      StringValue of =symbol= is the same value as the StringValue of
      [[IdentifierName][IdentifierName]],
      return true.
   3. Return false.

**** Static Semantics: IsComputedPropertyKey
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-iscomputedpropertykey
     :END:

   [[PropertyName][PropertyName]]:[[LiteralPropertyName][LiteralPropertyName]]

   1. Return false.

   [[PropertyName][PropertyName]]:[[ComputedPropertyName][ComputedPropertyName]]

   1. Return true.

**** Static Semantics: PropName
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-propname
     :END:

   [[PropertyDefinition][PropertyDefinition]]:[[IdentifierReference][IdentifierReference]]

   1. Return StringValue of
      [[IdentifierReference][IdentifierReference]].

   [[PropertyDefinition][PropertyDefinition]]:...[[AssignmentExpression][AssignmentExpression]]

   1. Return empty.

   [[PropertyDefinition][PropertyDefinition]]:[[PropertyName][PropertyName]]:[[AssignmentExpression][AssignmentExpression]]

   1. Return PropName of
      [[PropertyName][PropertyName]].

   [[LiteralPropertyName][LiteralPropertyName]]:[[IdentifierName][IdentifierName]]

   1. Return StringValue of
      [[IdentifierName][IdentifierName]].

   [[LiteralPropertyName][LiteralPropertyName]]:[[StringLiteral][StringLiteral]]

   1. Return the String value whose code units are the SV of
      [[StringLiteral][StringLiteral]].

   [[LiteralPropertyName][LiteralPropertyName]]:[[NumericLiteral][NumericLiteral]]

   1. Let =nbr= be the NumericValue of
      [[NumericLiteral][NumericLiteral]].
   2. Return ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=nbr=).

   [[ComputedPropertyName][ComputedPropertyName]]:[[[AssignmentExpression][AssignmentExpression]]]

   1. Return empty.

**** Static Semantics: PropertyNameList
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-propertynamelist
     :END:

   [[PropertyDefinitionList][PropertyDefinitionList]]:[[PropertyDefinition][PropertyDefinition]]

   1. If PropName of
      [[PropertyDefinition][PropertyDefinition]]
      is empty, return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   2. Return a new
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing PropName of
      [[PropertyDefinition][PropertyDefinition]].

   [[PropertyDefinitionList][PropertyDefinitionList]]:[[PropertyDefinitionList][PropertyDefinitionList]],[[PropertyDefinition][PropertyDefinition]]

   1. Let =list= be PropertyNameList of
      [[PropertyDefinitionList][PropertyDefinitionList]].
   2. If PropName of
      [[PropertyDefinition][PropertyDefinition]]
      is empty, return =list=.
   3. Append PropName of
      [[PropertyDefinition][PropertyDefinition]]
      to the end of =list=.
   4. Return =list=.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-4
     :END:

   [[ObjectLiteral][ObjectLiteral]]:{}

   1. Return
      [[https://tc39.es/ecma262/#sec-objectcreate][ObjectCreate]](%Object.prototype%).

   [[ObjectLiteral][ObjectLiteral]]:{[[PropertyDefinitionList][PropertyDefinitionList]]}
   {[[PropertyDefinitionList][PropertyDefinitionList]],}

   1. Let =obj= be
      [[https://tc39.es/ecma262/#sec-objectcreate][ObjectCreate]](%Object.prototype%).
   2. Perform ? PropertyDefinitionEvaluation of
      [[PropertyDefinitionList][PropertyDefinitionList]]
      with arguments =obj= and true.
   3. Return =obj=.

   [[LiteralPropertyName][LiteralPropertyName]]:[[IdentifierName][IdentifierName]]

   1. Return StringValue of
      [[IdentifierName][IdentifierName]].

   [[LiteralPropertyName][LiteralPropertyName]]:[[StringLiteral][StringLiteral]]

   1. Return the String value whose code units are the SV of
      [[StringLiteral][StringLiteral]].

   [[LiteralPropertyName][LiteralPropertyName]]:[[NumericLiteral][NumericLiteral]]

   1. Let =nbr= be the NumericValue of
      [[NumericLiteral][NumericLiteral]].
   2. Return ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=nbr=).

   [[ComputedPropertyName][ComputedPropertyName]]:[[[AssignmentExpression][AssignmentExpression]]]

   1. Let =exprValue= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   2. Let =propName= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprValue=).
   3. Return
      ? [[https://tc39.es/ecma262/#sec-topropertykey][ToPropertyKey]](=propName=).

**** Runtime Semantics: PropertyDefinitionEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-propertydefinitionevaluation
     :END:

   With parameters =object= and =enumerable=.

   [[PropertyDefinitionList][PropertyDefinitionList]]:[[PropertyDefinitionList][PropertyDefinitionList]],[[PropertyDefinition][PropertyDefinition]]

   1. Perform ? PropertyDefinitionEvaluation of
      [[PropertyDefinitionList][PropertyDefinitionList]]
      with arguments =object= and =enumerable=.
   2. Return the result of performing PropertyDefinitionEvaluation of
      [[PropertyDefinition][PropertyDefinition]]
      with arguments =object= and =enumerable=.

   [[PropertyDefinition][PropertyDefinition]]:...[[AssignmentExpression][AssignmentExpression]]

   1. Let =exprValue= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   2. Let =fromValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprValue=).
   3. Let =excludedNames= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   4. Return
      ? [[https://tc39.es/ecma262/#sec-copydataproperties][CopyDataProperties]](=object=,
      =fromValue=, =excludedNames=).

   [[PropertyDefinition][PropertyDefinition]]:[[IdentifierReference][IdentifierReference]]

   1. Let =propName= be StringValue of
      [[IdentifierReference][IdentifierReference]].
   2. Let =exprValue= be the result of evaluating
      [[IdentifierReference][IdentifierReference]].
   3. Let =propValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprValue=).
   4. [[https://tc39.es/ecma262/#assert][Assert]]: =enumerable= is true.
   5. [[https://tc39.es/ecma262/#assert][Assert]]: =object= is an ordinary,
      extensible object with no non-configurable properties.
   6. Return
      ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=object=,
      =propName=, =propValue=).

   [[PropertyDefinition][PropertyDefinition]]:[[PropertyName][PropertyName]]:[[AssignmentExpression][AssignmentExpression]]

   1. Let =propKey= be the result of evaluating
      [[PropertyName][PropertyName]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=propKey=).
   3. If
      [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[AssignmentExpression][AssignmentExpression]])
      is true, then

      1. Let =propValue= be NamedEvaluation of
         [[AssignmentExpression][AssignmentExpression]]
         with argument =propKey=.

   4. Else,

      1. Let =exprValueRef= be the result of evaluating
         [[AssignmentExpression][AssignmentExpression]].
      2. Let =propValue= be
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=exprValueRef=).

   5. [[https://tc39.es/ecma262/#assert][Assert]]: =enumerable= is true.
   6. [[https://tc39.es/ecma262/#assert][Assert]]: =object= is an ordinary,
      extensible object with no non-configurable properties.
   7. Return
      ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=object=,
      =propKey=, =propValue=).

   Note

   An alternative semantics for this production is given in
   [[https://tc39.es/ecma262/#sec-__proto__-property-names-in-object-initializers][B.3.1]].

*** Function Defining Expressions
    :PROPERTIES:
    :CUSTOM_ID: function-defining-expressions
    :END:

  See [[https://tc39.es/ecma262/#sec-function-definitions][14.1]] for
  [[PrimaryExpression][PrimaryExpression]]:[[FunctionExpression][FunctionExpression]]
  .

  See
  [[https://tc39.es/ecma262/#sec-generator-function-definitions][14.4]]
  for
  [[PrimaryExpression][PrimaryExpression]]:[[GeneratorExpression][GeneratorExpression]]
  .

  See [[https://tc39.es/ecma262/#sec-class-definitions][14.6]] for
  [[PrimaryExpression][PrimaryExpression]]:[[ClassExpression][ClassExpression]]
  .

  See [[https://tc39.es/ecma262/#sec-async-function-definitions][14.7]]
  for
  [[PrimaryExpression][PrimaryExpression]]:[[AsyncFunctionExpression][AsyncFunctionExpression]]
  .

  See
  [[https://tc39.es/ecma262/#sec-async-generator-function-definitions][14.5]]
  for
  [[PrimaryExpression][PrimaryExpression]]:[[AsyncGeneratorExpression][AsyncGeneratorExpression]]
  .

*** Regular Expression Literals
    :PROPERTIES:
    :CUSTOM_ID: regular-expression-literals-1
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-21
     :END:

  See
  [[https://tc39.es/ecma262/#sec-literals-regular-expression-literals][11.8.5]].

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-4
     :END:

   [[PrimaryExpression][PrimaryExpression]]:[[RegularExpressionLiteral][RegularExpressionLiteral]]

   - It is a Syntax Error if
     [[https://tc39.es/ecma262/#sec-isvalidregularexpressionliteral][IsValidRegularExpressionLiteral]]([[RegularExpressionLiteral][RegularExpressionLiteral]])
     is false.

**** Static Semantics: IsValidRegularExpressionLiteral ( =literal=
   )
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isvalidregularexpressionliteral-literal
     :END:

   The abstract operation IsValidRegularExpressionLiteral determines if its
   argument is a valid regular expression literal. The following steps are
   taken:

   1. [[https://tc39.es/ecma262/#assert][Assert]]: =literal= is a
      [[RegularExpressionLiteral][RegularExpressionLiteral]].
   2. If FlagText of =literal= contains any code points other than =g=,
      =i=, =m=, =s=, =u=, or =y=, or if it contains the same code point
      more than once, return false.
   3. Let =P= be BodyText of =literal=.
   4. If FlagText of =literal= contains =u=, then

      1. Parse =P= using the grammars in
         [[https://tc39.es/ecma262/#sec-patterns][21.2.1]]. The
         [[https://tc39.es/ecma262/#sec-context-free-grammars][goal
         symbol]] for the parse is
         [[Pattern][Pattern]][+U, +N]. If =P=
         did not conform to the grammar, if any elements of =P= were not
         matched by the parse, or if any Early Error conditions exist,
         return false. Otherwise, return true.

   5. Parse =P= using the grammars in
      [[https://tc39.es/ecma262/#sec-patterns][21.2.1]]. The
      [[https://tc39.es/ecma262/#sec-context-free-grammars][goal symbol]]
      for the parse is
      [[Pattern][Pattern]][~U, ~N]. If the
      result of parsing contains a
      [[GroupName][GroupName]], reparse with
      the [[https://tc39.es/ecma262/#sec-context-free-grammars][goal
      symbol]] [[Pattern][Pattern]][~U, +N].
      If =P= did not conform to the grammar, if any elements of =P= were
      not matched by the parse, or if any Early Error conditions exist,
      return false. Otherwise, return true.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-5
     :END:

   [[PrimaryExpression][PrimaryExpression]]:[[RegularExpressionLiteral][RegularExpressionLiteral]]

   1. Let =pattern= be the String value consisting of the
      [[https://tc39.es/ecma262/#sec-utf16encoding][UTF16Encoding]] of each
      code point of BodyText of
      [[RegularExpressionLiteral][RegularExpressionLiteral]].
   2. Let =flags= be the String value consisting of the
      [[https://tc39.es/ecma262/#sec-utf16encoding][UTF16Encoding]] of each
      code point of FlagText of
      [[RegularExpressionLiteral][RegularExpressionLiteral]].
   3. Return
      [[https://tc39.es/ecma262/#sec-regexpcreate][RegExpCreate]](=pattern=,
      =flags=).

*** Template Literals
    :PROPERTIES:
    :CUSTOM_ID: template-literals
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-22
     :END:

  [[TemplateLiteral][TemplateLiteral]][Yield,
  Await,
  Tagged]:[[NoSubstitutionTemplate][NoSubstitutionTemplate]]
  [[SubstitutionTemplate][SubstitutionTemplate]][?Yield,
  ?Await, ?Tagged]
  [[SubstitutionTemplate][SubstitutionTemplate]][Yield,
  Await,
  Tagged]:[[TemplateHead][TemplateHead]][[Expression][Expression]][+In,
  ?Yield,
  ?Await][[TemplateSpans][TemplateSpans]][?Yield,
  ?Await, ?Tagged]
  [[TemplateSpans][TemplateSpans]][Yield,
  Await,
  Tagged]:[[TemplateTail][TemplateTail]]
  [[TemplateMiddleList][TemplateMiddleList]][?Yield,
  ?Await,
  ?Tagged][[TemplateTail][TemplateTail]]
  [[TemplateMiddleList][TemplateMiddleList]][Yield,
  Await,
  Tagged]:[[TemplateMiddle][TemplateMiddle]][[Expression][Expression]][+In,
  ?Yield, ?Await]
  [[TemplateMiddleList][TemplateMiddleList]][?Yield,
  ?Await,
  ?Tagged][[TemplateMiddle][TemplateMiddle]][[Expression][Expression]][+In,
  ?Yield, ?Await]
  <<sec-primary-expression-template-literals-static-semantics-early-errors>>
**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-5
     :END:

   [[TemplateLiteral][TemplateLiteral]][Yield,
   Await,
   Tagged]:[[NoSubstitutionTemplate][NoSubstitutionTemplate]]

   - It is a Syntax Error if the number of elements in the result of
     TemplateStrings of
     [[TemplateLiteral][TemplateLiteral]]
     with argument false is greater than 2^{32} - 1.
   - It is a Syntax Error if the _{[Tagged]} parameter was not set and
     [[NoSubstitutionTemplate][NoSubstitutionTemplate]]
     Contains
     [[NotEscapeSequence][NotEscapeSequence]].

   [[SubstitutionTemplate][SubstitutionTemplate]][Yield,
   Await,
   Tagged]:[[TemplateHead][TemplateHead]][[Expression][Expression]][+In,
   ?Yield,
   ?Await][[TemplateSpans][TemplateSpans]][?Yield,
   ?Await, ?Tagged]

   - It is a Syntax Error if the _{[Tagged]} parameter was not set and
     [[TemplateHead][TemplateHead]] Contains
     [[NotEscapeSequence][NotEscapeSequence]].

   [[TemplateSpans][TemplateSpans]][Yield,
   Await,
   Tagged]:[[TemplateTail][TemplateTail]]

   - It is a Syntax Error if the _{[Tagged]} parameter was not set and
     [[TemplateTail][TemplateTail]] Contains
     [[NotEscapeSequence][NotEscapeSequence]].

   [[TemplateMiddleList][TemplateMiddleList]][Yield,
   Await,
   Tagged]:[[TemplateMiddle][TemplateMiddle]][[Expression][Expression]][+In,
   ?Yield, ?Await]
   [[TemplateMiddleList][TemplateMiddleList]][?Yield,
   ?Await,
   ?Tagged][[TemplateMiddle][TemplateMiddle]][[Expression][Expression]][+In,
   ?Yield, ?Await]

   - It is a Syntax Error if the _{[Tagged]} parameter was not set and
     [[TemplateMiddle][TemplateMiddle]]
     Contains
     [[NotEscapeSequence][NotEscapeSequence]].

**** Static Semantics: TemplateStrings
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-templatestrings
     :END:

   With parameter =raw=.

   [[TemplateLiteral][TemplateLiteral]]:[[NoSubstitutionTemplate][NoSubstitutionTemplate]]

   1. If =raw= is false, then

      1. Let =string= be the TV of
         [[NoSubstitutionTemplate][NoSubstitutionTemplate]].

   2. Else,

      1. Let =string= be the TRV of
         [[NoSubstitutionTemplate][NoSubstitutionTemplate]].

   3. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing the single element, =string=.

   [[SubstitutionTemplate][SubstitutionTemplate]]:[[TemplateHead][TemplateHead]][[Expression][Expression]][[TemplateSpans][TemplateSpans]]

   1. If =raw= is false, then

      1. Let =head= be the TV of
         [[TemplateHead][TemplateHead]].

   2. Else,

      1. Let =head= be the TRV of
         [[TemplateHead][TemplateHead]].

   3. Let =tail= be TemplateStrings of
      [[TemplateSpans][TemplateSpans]] with
      argument =raw=.
   4. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing =head= followed by the elements, in order, of =tail=.

   [[TemplateSpans][TemplateSpans]]:[[TemplateTail][TemplateTail]]

   1. If =raw= is false, then

      1. Let =tail= be the TV of
         [[TemplateTail][TemplateTail]].

   2. Else,

      1. Let =tail= be the TRV of
         [[TemplateTail][TemplateTail]].

   3. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing the single element, =tail=.

   [[TemplateSpans][TemplateSpans]]:[[TemplateMiddleList][TemplateMiddleList]][[TemplateTail][TemplateTail]]

   1. Let =middle= be TemplateStrings of
      [[TemplateMiddleList][TemplateMiddleList]]
      with argument =raw=.
   2. If =raw= is false, then

      1. Let =tail= be the TV of
         [[TemplateTail][TemplateTail]].

   3. Else,

      1. Let =tail= be the TRV of
         [[TemplateTail][TemplateTail]].

   4. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing the elements, in order, of =middle= followed by =tail=.

   [[TemplateMiddleList][TemplateMiddleList]]:[[TemplateMiddle][TemplateMiddle]][[Expression][Expression]]

   1. If =raw= is false, then

      1. Let =string= be the TV of
         [[TemplateMiddle][TemplateMiddle]].

   2. Else,

      1. Let =string= be the TRV of
         [[TemplateMiddle][TemplateMiddle]].

   3. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing the single element, =string=.

   [[TemplateMiddleList][TemplateMiddleList]]:[[TemplateMiddleList][TemplateMiddleList]][[TemplateMiddle][TemplateMiddle]][[Expression][Expression]]

   1. Let =front= be TemplateStrings of
      [[TemplateMiddleList][TemplateMiddleList]]
      with argument =raw=.
   2. If =raw= is false, then

      1. Let =last= be the TV of
         [[TemplateMiddle][TemplateMiddle]].

   3. Else,

      1. Let =last= be the TRV of
         [[TemplateMiddle][TemplateMiddle]].

   4. Append =last= as the last element of the
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      =front=.
   5. Return =front=.

**** Runtime Semantics: ArgumentListEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-argumentlistevaluation
     :END:

   [[TemplateLiteral][TemplateLiteral]]:[[NoSubstitutionTemplate][NoSubstitutionTemplate]]

   1. Let =templateLiteral= be this
      [[TemplateLiteral][TemplateLiteral]].
   2. Let =siteObj= be
      [[https://tc39.es/ecma262/#sec-gettemplateobject][GetTemplateObject]](=templateLiteral=).
   3. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing the one element which is =siteObj=.

   [[SubstitutionTemplate][SubstitutionTemplate]]:[[TemplateHead][TemplateHead]][[Expression][Expression]][[TemplateSpans][TemplateSpans]]

   1. Let =templateLiteral= be this
      [[TemplateLiteral][TemplateLiteral]].
   2. Let =siteObj= be
      [[https://tc39.es/ecma262/#sec-gettemplateobject][GetTemplateObject]](=templateLiteral=).
   3. Let =firstSubRef= be the result of evaluating
      [[Expression][Expression]].
   4. Let =firstSub= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=firstSubRef=).
   5. Let =restSub= be ? SubstitutionEvaluation of
      [[TemplateSpans][TemplateSpans]].
   6. [[https://tc39.es/ecma262/#assert][Assert]]: =restSub= is a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   7. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      whose first element is =siteObj=, whose second elements is
      =firstSub=, and whose subsequent elements are the elements of
      =restSub=, in order. =restSub= may contain no elements.

**** Runtime Semantics: GetTemplateObject ( =templateLiteral= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-gettemplateobject-templateliteral
     :END:

   The abstract operation GetTemplateObject is called with a
   [[https://tc39.es/ecma262/#sec-syntactic-grammar][Parse Node]],
   =templateLiteral=, as an argument. It performs the following steps:

   1.  Let =rawStrings= be TemplateStrings of =templateLiteral= with
       argument true.
   2.  Let =realm= be [[https://tc39.es/ecma262/#current-realm][the current
       Realm Record]].
   3.  Let =templateRegistry= be =realm=.[[TemplateMap]].
   4.  For each element =e= of =templateRegistry=, do

       1. If =e=.[[Site]] is
          [[https://tc39.es/ecma262/#sec-syntactic-grammar][the same Parse
          Node]] as =templateLiteral=, then

          1. Return =e=.[[Array]].

   5.  Let =cookedStrings= be TemplateStrings of =templateLiteral= with
       argument false.
   6.  Let =count= be the number of elements in the
       [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
       =cookedStrings=.
   7.  [[https://tc39.es/ecma262/#assert][Assert]]: =count= ≤ 2^{32} - 1.
   8.  Let =template= be
       ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](=count=).
   9.  Let =rawObj= be
       ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](=count=).
   10. Let =index= be 0.
   11. Repeat, while =index= < =count=

       1. Let =prop= be
          ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=index=).
       2. Let =cookedValue= be the String value =cookedStrings=[=index=].
       3. Call =template=.[[DefineOwnProperty]](=prop=, PropertyDescriptor
          { [[Value]]: =cookedValue=, [[Writable]]: false, [[Enumerable]]:
          true, [[Configurable]]: false }).
       4. Let =rawValue= be the String value =rawStrings=[=index=].
       5. Call =rawObj=.[[DefineOwnProperty]](=prop=, PropertyDescriptor {
          [[Value]]: =rawValue=, [[Writable]]: false, [[Enumerable]]: true,
          [[Configurable]]: false }).
       6. Set =index= to =index= + 1.

   12. Perform
       [[https://tc39.es/ecma262/#sec-setintegritylevel][SetIntegrityLevel]](=rawObj=,
       frozen).
   13. Call =template=.[[DefineOwnProperty]]("raw", PropertyDescriptor {
       [[Value]]: =rawObj=, [[Writable]]: false, [[Enumerable]]: false,
       [[Configurable]]: false }).
   14. Perform
       [[https://tc39.es/ecma262/#sec-setintegritylevel][SetIntegrityLevel]](=template=,
       frozen).
   15. Append the
       [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][Record]]
       { [[Site]]: =templateLiteral=, [[Array]]: =template= } to
       =templateRegistry=.
   16. Return =template=.

   Note 1

   The creation of a template object cannot result in an
   [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
   completion]].

   Note 2

   Each [[TemplateLiteral][TemplateLiteral]]
   in the program code of a [[https://tc39.es/ecma262/#realm][realm]] is
   associated with a unique template object that is used in the evaluation
   of tagged Templates
   ([[https://tc39.es/ecma262/#sec-template-literals-runtime-semantics-evaluation][12.2.9.6]]).
   The template objects are frozen and the same template object is used
   each time a specific tagged Template is evaluated. Whether template
   objects are created lazily upon first evaluation of the
   [[TemplateLiteral][TemplateLiteral]] or
   eagerly prior to first evaluation is an implementation choice that is
   not observable to ECMAScript code.

   Note 3

   Future editions of this specification may define additional
   non-enumerable properties of template objects.

**** Runtime Semantics: SubstitutionEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-substitutionevaluation
     :END:

   [[TemplateSpans][TemplateSpans]]:[[TemplateTail][TemplateTail]]

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[TemplateSpans][TemplateSpans]]:[[TemplateMiddleList][TemplateMiddleList]][[TemplateTail][TemplateTail]]

   1. Return the result of SubstitutionEvaluation of
      [[TemplateMiddleList][TemplateMiddleList]].

   [[TemplateMiddleList][TemplateMiddleList]]:[[TemplateMiddle][TemplateMiddle]][[Expression][Expression]]

   1. Let =subRef= be the result of evaluating
      [[Expression][Expression]].
   2. Let =sub= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=subRef=).
   3. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      containing only =sub=.

   [[TemplateMiddleList][TemplateMiddleList]]:[[TemplateMiddleList][TemplateMiddleList]][[TemplateMiddle][TemplateMiddle]][[Expression][Expression]]

   1. Let =preceding= be ? SubstitutionEvaluation of
      [[TemplateMiddleList][TemplateMiddleList]].
   2. Let =nextRef= be the result of evaluating
      [[Expression][Expression]].
   3. Let =next= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=nextRef=).
   4. Append =next= as the last element of the
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      =preceding=.
   5. Return =preceding=.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-6
     :END:

   [[TemplateLiteral][TemplateLiteral]]:[[NoSubstitutionTemplate][NoSubstitutionTemplate]]

   1. Return the String value whose code units are the elements of the TV
      of
      [[NoSubstitutionTemplate][NoSubstitutionTemplate]]
      as defined in
      [[https://tc39.es/ecma262/#sec-template-literal-lexical-components][11.8.6]].

   [[SubstitutionTemplate][SubstitutionTemplate]]:[[TemplateHead][TemplateHead]][[Expression][Expression]][[TemplateSpans][TemplateSpans]]

   1. Let =head= be the TV of
      [[TemplateHead][TemplateHead]] as
      defined in
      [[https://tc39.es/ecma262/#sec-template-literal-lexical-components][11.8.6]].
   2. Let =subRef= be the result of evaluating
      [[Expression][Expression]].
   3. Let =sub= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=subRef=).
   4. Let =middle= be
      ? [[https://tc39.es/ecma262/#sec-tostring][ToString]](=sub=).
   5. Let =tail= be the result of evaluating
      [[TemplateSpans][TemplateSpans]].
   6. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=tail=).
   7. Return the
      [[https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type][string-concatenation]]
      of =head=, =middle=, and =tail=.

   Note 1

   The string conversion semantics applied to the
   [[Expression][Expression]] value are like
   =String.prototype.concat= rather than the =+= operator.

   [[TemplateSpans][TemplateSpans]]:[[TemplateTail][TemplateTail]]

   1. Let =tail= be the TV of
      [[TemplateTail][TemplateTail]] as
      defined in
      [[https://tc39.es/ecma262/#sec-template-literal-lexical-components][11.8.6]].
   2. Return the String value consisting of the code units of =tail=.

   [[TemplateSpans][TemplateSpans]]:[[TemplateMiddleList][TemplateMiddleList]][[TemplateTail][TemplateTail]]

   1. Let =head= be the result of evaluating
      [[TemplateMiddleList][TemplateMiddleList]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=head=).
   3. Let =tail= be the TV of
      [[TemplateTail][TemplateTail]] as
      defined in
      [[https://tc39.es/ecma262/#sec-template-literal-lexical-components][11.8.6]].
   4. Return the
      [[https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type][string-concatenation]]
      of =head= and =tail=.

   [[TemplateMiddleList][TemplateMiddleList]]:[[TemplateMiddle][TemplateMiddle]][[Expression][Expression]]

   1. Let =head= be the TV of
      [[TemplateMiddle][TemplateMiddle]] as
      defined in
      [[https://tc39.es/ecma262/#sec-template-literal-lexical-components][11.8.6]].
   2. Let =subRef= be the result of evaluating
      [[Expression][Expression]].
   3. Let =sub= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=subRef=).
   4. Let =middle= be
      ? [[https://tc39.es/ecma262/#sec-tostring][ToString]](=sub=).
   5. Return the sequence of code units consisting of the code units of
      =head= followed by the elements of =middle=.

   Note 2

   The string conversion semantics applied to the
   [[Expression][Expression]] value are like
   =String.prototype.concat= rather than the =+= operator.

   [[TemplateMiddleList][TemplateMiddleList]]:[[TemplateMiddleList][TemplateMiddleList]][[TemplateMiddle][TemplateMiddle]][[Expression][Expression]]

   1. Let =rest= be the result of evaluating
      [[TemplateMiddleList][TemplateMiddleList]].
   2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=rest=).
   3. Let =middle= be the TV of
      [[TemplateMiddle][TemplateMiddle]] as
      defined in
      [[https://tc39.es/ecma262/#sec-template-literal-lexical-components][11.8.6]].
   4. Let =subRef= be the result of evaluating
      [[Expression][Expression]].
   5. Let =sub= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=subRef=).
   6. Let =last= be
      ? [[https://tc39.es/ecma262/#sec-tostring][ToString]](=sub=).
   7. Return the sequence of code units consisting of the elements of
      =rest= followed by the code units of =middle= followed by the
      elements of =last=.

   Note 3

   The string conversion semantics applied to the
   [[Expression][Expression]] value are like
   =String.prototype.concat= rather than the =+= operator.

*** The Grouping Operator
    :PROPERTIES:
    :CUSTOM_ID: the-grouping-operator
    :END:

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-6
     :END:

   [[PrimaryExpression][PrimaryExpression]]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]

   - It is a Syntax Error if
     [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]
     is not [[https://tc39.es/ecma262/#sec-syntactic-grammar][covering]] a
     [[ParenthesizedExpression][ParenthesizedExpression]].
   - All Early Error rules for
     [[ParenthesizedExpression][ParenthesizedExpression]]
     and its derived productions also apply to
     CoveredParenthesizedExpression of
     [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-1
     :END:

   [[ParenthesizedExpression][ParenthesizedExpression]]:([[Expression][Expression]])

   1. Return IsFunctionDefinition of
      [[Expression][Expression]].

   <<sec-grouping-operator-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-2
     :END:

   [[ParenthesizedExpression][ParenthesizedExpression]]:([[Expression][Expression]])

   1. Return AssignmentTargetType of
      [[Expression][Expression]].

**** Runtime Semantics: NamedEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-namedevaluation
     :END:

   With parameter =name=.

   [[PrimaryExpression][PrimaryExpression]]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]

   1. Let =expr= be CoveredParenthesizedExpression of
      [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].
   2. Return the result of performing NamedEvaluation for =expr= with
      argument =name=.

   [[ParenthesizedExpression][ParenthesizedExpression]]:([[Expression][Expression]])

   1. [[https://tc39.es/ecma262/#assert][Assert]]:
      [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Expression][Expression]])
      is true.
   2. Return the result of performing NamedEvaluation for
      [[Expression][Expression]] with
      argument =name=.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-7
     :END:

   [[PrimaryExpression][PrimaryExpression]]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]

   1. Let =expr= be CoveredParenthesizedExpression of
      [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]].
   2. Return the result of evaluating =expr=.

   [[ParenthesizedExpression][ParenthesizedExpression]]:([[Expression][Expression]])

   1. Return the result of evaluating
      [[Expression][Expression]]. This may be
      of type
      [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]].

   Note

   This algorithm does not apply
   [[https://tc39.es/ecma262/#sec-getvalue][GetValue]] to the result of
   evaluating [[Expression][Expression]]. The
   principal motivation for this is so that operators such as =delete= and
   =typeof= may be applied to parenthesized expressions.

** Left-Hand-Side Expressions
   :PROPERTIES:
   :CUSTOM_ID: left-hand-side-expressions
   :END:
   
*** Syntax
    :PROPERTIES:
    :CUSTOM_ID: syntax-23
    :END:
   
 
**** MemberExpression

  [[MemberExpression][MemberExpression]][Yield, Await]:
    [[PrimaryExpression][PrimaryExpression]][?Yield, ?Await]
    [[MemberExpression][MemberExpression]][?Yield, ?Await] [[[Expression][Expression]][+In, ?Yield, ?Await]]
    [[MemberExpression][MemberExpression]][?Yie  ld, ?Await].[[IdentifierName][IdentifierName]]
    [[MemberExpression][MemberExpression]][?Yield, ?Await][[TemplateLiteral][TemplateLiteral]][?Yield, ?Await, +Tagged]
    [[SuperProperty][SuperProperty]][?Yield, ?Await]
    [[MetaProperty][MetaProperty]] 
    new[[MemberExpression][MemberExpression]][?Yield, ?Await][[Arguments][Arguments]][?Yield, ?Await]

    #+begin_src gerbil :noweb-ref member-expression 
      (defstruct (member-expression expression) (group expression identifier template)
        transparent: #t)

      (def (parse-member-expression (make-it-primary? #f))
       (.let* ((g (if make-it-primary?
                    PrimaryExpression
                    (parse-member-expression #t)))
                     (e (.or (bracket (tpv? #\[) Expression (tpv? #\])) #f))
                     (i (if e #f (.or (.begin (tpv? #\.) (parse-member-expression #t)) #f)))
                     (t (if (or e i) #f #f #;TemplateLiterate)))
               (if (not (or e i t)) g
                   (member-expression g e i t))))
      (def MemberExpression (.begin (.or (parse-member-expression) NewExpression)))

    #+end_src


  [[SuperProperty][SuperProperty]][Yield, Await]:
  super[[[Expression][Expression]][+In, ?Yield, ?Await]]
  super.[[IdentifierName][IdentifierName
 ]]
  [[MetaProperty][MetaProperty]]:[[NewTarget][NewTarget]]
  [[NewTarget][NewTarget]]:new.target
 
**** NewExpression
     :PROPERTIES:
     :CUSTOM_ID: NewExpression
     :END:

  [[NewExpression][NewExpression]][Yield, Await]:
   [[MemberExpression][MemberExpression]][?Yield, ?Await]
   new [[NewExpression][NewExpression]][?Yield, ?Await]

   #+begin_src gerbil :noweb-ref new-expression
     (defstruct (new-expression expression) (expression arguments) transparent: #t)
     (def NewExpression
       (.begin 
         #t
         (.or (.let* ((exp (.begin (tpv? "new") MemberExpression))
                      (args (.or Arguments #f)))

                (new-expression exp args))
              MemberExpression)))
   #+end_src

**** CallExpression

  [[CallExpression][CallExpression]][Yield, Await]:  
    [[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]][?Yield, ?Await]
    [[SuperCall][SuperCall]][?Yield, ?Await]
    [[ImportCall][ImportCall]][?Yield, ?Await]
    [[CallExpression][CallExpression]][?Yield, ?Await][[Arguments][Arguments]][?Yield, ?Await]
    [[CallExpression][CallExpression]][?Yield, ?Await][[[Expression][Expression]][+In, ?Yield, ?Await]]
    [[CallExpression][CallExpression]][?Yield, ?Await].[[IdentifierName][IdentifierName]]
    [[CallExpression][CallExpression]][?Yield, ?Await][[TemplateLiteral][TemplateLiteral]][?Yield, ?Await, +Tagged]

    #+begin_src gerbil :noweb-ref call-expression
      (def CallExpression FAIL)
    #+end_src

  

   [[SuperCall][SuperCall]][Yield, Await]:
   super[[Arguments][Arguments]][?Yield, ?Await]
 
  [[ImportCall][ImportCall]][Yield, Await]:
    import([[AssignmentExpression][AssignmentExpression]][+In, ?Yield, ?Await])
 
**** Arguments

    [[Arguments][Arguments]][Yield, Await]:
     ()
     ([[ArgumentList][ArgumentList]][?Yield, ?Await])
     ([[ArgumentList][ArgumentList]][?Yield, ?Await],)

     #+begin_src gerbil :noweb-ref arguments
       (defstruct (arguments expression) (list) transparent: #t) 
       (def Arguments
         (.let* ((_ (tpv? #\())
                 (empty? (.or (tpv? #\)) #f))
                 (args (if empty? [] ArgumentList)))
           (return (arguments args))))
     #+end_src

**** ArgumentList

   [[ArgumentList][ArgumentList]][Yield, Await]:

     [[AssignmentExpression][AssignmentExpression]][+In, ?Yield, ?Await] 
     ...[[AssignmentExpression][AssignmentExpression]][+In, ?Yield, ?Await]
     [[ArgumentList][ArgumentList]][?Yield, ?Await],[[AssignmentExpression][AssignmentExpression]][+In, ?Yield, ?Await]
     [[ArgumentList][ArgumentList]][?Yield, ?Await],...[[AssignmentExpression][AssignmentExpression]][+In, ?Yield, ?Await]

     #+begin_src gerbil :noweb-ref argument-list
       (def ArgumentList (.begin #t (sepby1 (.or SpreadElement AssignmentExpression)
                                            (tpv? #\,))))
     #+end_src

**** LeftHandSideExpression
     :PROPERTIES:
     :CUSTOM_ID: LeftHandSideExpression
     :END:

  #+begin_quote
  [[LeftHandSideExpression][LeftHandSideExpression]][Yield, Await]:
   [[NewExpression][NewExpression]][?Yield, ?Await]
   [[CallExpression][ CallExpression]][?Yield, ?Await]
  #+end_quote

  #+begin_src gerbil :noweb-ref left-hand-side-expression
    (def LeftHandSideExpression (.begin #t (.or NewExpression CallExpression)))
  #+end_src
*** Supplemental Syntax
    :PROPERTIES:
    :CUSTOM_ID: supplemental-syntax-1
    :END:

 When processing an instance of the production
 [[CallExpression][CallExpression]]:[[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]]
 the interpretation of
 [[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]]
 is refined using the following grammar:

 [[CallMemberExpression][CallMemberExpression]][Yield,
 Await]:[[MemberExpression][MemberExpression]][?Yield,
 ?Await][[Arguments][Arguments]][?Yield,
 ?Await]
*** Static Semantics
    :PROPERTIES:
    :CUSTOM_ID: static-semantics-1
    :END:

**** Static Semantics: CoveredCallExpression
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-coveredcallexpression
     :END:

   [[CallExpression][CallExpression]]:[[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]]

   1. Return the
      [[CallMemberExpression][CallMemberExpression]]
      that is [[https://tc39.es/ecma262/#sec-syntactic-grammar][covered]]
      by
      [[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]].

**** Static Semantics: Contains
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-contains-1
     :END:

   With parameter =symbol=.

   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]].[[IdentifierName][IdentifierName]]

   1. If
      [[MemberExpression][MemberExpression]]
      Contains =symbol= is true, return true.
   2. If =symbol= is a
      [[ReservedWord][ReservedWord]], return
      false.
   3. If =symbol= is an
      [[Identifier][Identifier]] and
      StringValue of =symbol= is the same value as the StringValue of
      [[IdentifierName][IdentifierName]],
      return true.
   4. Return false.

   [[SuperProperty][SuperProperty]]:super.[[IdentifierName][IdentifierName]]

   1. If =symbol= is the
      [[ReservedWord][ReservedWord]] =super=,
      return true.
   2. If =symbol= is a
      [[ReservedWord][ReservedWord]], return
      false.
   3. If =symbol= is an
      [[Identifier][Identifier]] and
      StringValue of =symbol= is the same value as the StringValue of
      [[IdentifierName][IdentifierName]],
      return true.
   4. Return false.

   [[CallExpression][CallExpression]]:[[CallExpression][CallExpression]].[[IdentifierName][IdentifierName]]

   1. If [[CallExpression][CallExpression]]
      Contains =symbol= is true, return true.
   2. If =symbol= is a
      [[ReservedWord][ReservedWord]], return
      false.
   3. If =symbol= is an
      [[Identifier][Identifier]] and
      StringValue of =symbol= is the same value as the StringValue of
      [[IdentifierName][IdentifierName]],
      return true.
   4. Return false.

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-2
     :END:

   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[[Expression][Expression]]]
   [[MemberExpression][MemberExpression]].[[IdentifierName][IdentifierName]]
   [[MemberExpression][MemberExpression]][[TemplateLiteral][TemplateLiteral]]
   [[SuperProperty][SuperProperty]]
   [[MetaProperty][MetaProperty]]
   new[[MemberExpression][MemberExpression]][[Arguments][Arguments]]
   [[NewExpression][NewExpression]]:new[[NewExpression][NewExpression]]
   [[LeftHandSideExpression][LeftHandSideExpression]]:[[CallExpression][CallExpression]]

   1. Return false.

**** Static Semantics: IsDestructuring
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isdestructuring
     :END:

   [[MemberExpression][MemberExpression]]:[[PrimaryExpression][PrimaryExpression]]

   1. If
      [[PrimaryExpression][PrimaryExpression]]
      is either an
      [[ObjectLiteral][ObjectLiteral]] or an
      [[ArrayLiteral][ArrayLiteral]], return
      true.
   2. Return false.

   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[[Expression][Expression]]]
   [[MemberExpression][MemberExpression]].[[IdentifierName][IdentifierName]]
   [[MemberExpression][MemberExpression]][[TemplateLiteral][TemplateLiteral]]
   [[SuperProperty][SuperProperty]]
   [[MetaProperty][MetaProperty]]
   new[[MemberExpression][MemberExpression]][[Arguments][Arguments]]
   [[NewExpression][NewExpression]]:new[[NewExpression][NewExpression]]
   [[LeftHandSideExpression][LeftHandSideExpression]]:[[CallExpression][CallExpression]]

   1. Return false.

**** Static Semantics: IsIdentifierRef
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isidentifierref-1
     :END:

   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[[Expression][Expression]]]
   [[MemberExpression][MemberExpression]].[[IdentifierName][IdentifierName]]
   [[MemberExpression][MemberExpression]][[TemplateLiteral][TemplateLiteral]]
   [[SuperProperty][SuperProperty]]
   [[MetaProperty][MetaProperty]]
   new[[MemberExpression][MemberExpression]][[Arguments][Arguments]]
   [[NewExpression][NewExpression]]:new[[NewExpression][NewExpression]]
   [[LeftHandSideExpression][LeftHandSideExpression]]:[[CallExpression][CallExpression]]

   1. Return false.

   <<sec-static-semantics-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-3
     :END:

   [[CallExpression][CallExpression]]:[[CallExpression][CallExpression]][[[Expression][Expression]]]
   [[CallExpression][CallExpression]].[[IdentifierName][IdentifierName]]
   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[[Expression][Expression]]]
   [[MemberExpression][MemberExpression]].[[IdentifierName][IdentifierName]]
   [[SuperProperty][SuperProperty]]

   1. Return simple.

   [[CallExpression][CallExpression]]:[[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]]
   [[SuperCall][SuperCall]]
   [[ImportCall][ImportCall]]
   [[CallExpression][CallExpression]][[Arguments][Arguments]]
   [[CallExpression][CallExpression]][[TemplateLiteral][TemplateLiteral]]
   [[NewExpression][NewExpression]]:new[[NewExpression][NewExpression]]
   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[TemplateLiteral][TemplateLiteral]]
   new[[MemberExpression][MemberExpression]][[Arguments][Arguments]]
   [[NewTarget][NewTarget]]:new.target

   1. Return invalid.

*** Property Accessors
    :PROPERTIES:
    :CUSTOM_ID: property-accessors
    :END:

  Note

  Properties are accessed by name, using either the dot notation:

  [[MemberExpression][MemberExpression]] =.=
  [[IdentifierName][IdentifierName]]\\
  [[CallExpression][CallExpression]] =.=
  [[IdentifierName][IdentifierName]]

  or the bracket notation:

  [[MemberExpression][MemberExpression]] =[=
  [[Expression][Expression]] =]=\\
  [[CallExpression][CallExpression]] =[=
  [[Expression][Expression]] =]=

  The dot notation is explained by the following syntactic conversion:

  [[MemberExpression][MemberExpression]] =.=
  [[IdentifierName][IdentifierName]]

  is identical in its behaviour to

  [[MemberExpression][MemberExpression]] =[=
  </identifier-name-string/> =]=

  and similarly

  [[CallExpression][CallExpression]] =.=
  [[IdentifierName][IdentifierName]]

  is identical in its behaviour to

  [[CallExpression][CallExpression]] =[=
  </identifier-name-string/> =]=

  where </identifier-name-string/> is the result of evaluating StringValue
  of [[IdentifierName][IdentifierName]].

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-8
     :END:

   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[[Expression][Expression]]]

   1. Let =baseReference= be the result of evaluating
      [[MemberExpression][MemberExpression]].
   2. Let =baseValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=baseReference=).
   3. Let =propertyNameReference= be the result of evaluating
      [[Expression][Expression]].
   4. Let =propertyNameValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=propertyNameReference=).
   5. Let =bv= be
      ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=baseValue=).
   6. Let =propertyKey= be
      ? [[https://tc39.es/ecma262/#sec-topropertykey][ToPropertyKey]](=propertyNameValue=).
   7. If the code matched by this
      [[MemberExpression][MemberExpression]]
      is [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode
      code]], let =strict= be true; else let =strict= be false.
   8. Return a value of type
      [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]]
      whose base value component is =bv=, whose referenced name component
      is =propertyKey=, and whose strict reference flag is =strict=.

   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]].[[IdentifierName][IdentifierName]]

   1. Let =baseReference= be the result of evaluating
      [[MemberExpression][MemberExpression]].
   2. Let =baseValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=baseReference=).
   3. Let =bv= be
      ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=baseValue=).
   4. Let =propertyNameString= be StringValue of
      [[IdentifierName][IdentifierName]].
   5. If the code matched by this
      [[MemberExpression][MemberExpression]]
      is [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode
      code]], let =strict= be true; else let =strict= be false.
   6. Return a value of type
      [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]]
      whose base value component is =bv=, whose referenced name component
      is =propertyNameString=, and whose strict reference flag is =strict=.

   [[CallExpression][CallExpression]]:[[CallExpression][CallExpression]][[[Expression][Expression]]]
   Is evaluated in exactly the same manner as
   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[[Expression][Expression]]]
   except that the contained
   [[CallExpression][CallExpression]] is
   evaluated in step 1.

   [[CallExpression][CallExpression]]:[[CallExpression][CallExpression]].[[IdentifierName][IdentifierName]]
   Is evaluated in exactly the same manner as
   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]].[[IdentifierName][IdentifierName]]
   except that the contained
   [[CallExpression][CallExpression]] is
   evaluated in step 1.

*** The =new= Operator
    :PROPERTIES:
    :CUSTOM_ID: the-new-operator
    :END:

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-9
     :END:

   [[NewExpression][NewExpression]]:new[[NewExpression][NewExpression]]

   1. Return
      ? [[https://tc39.es/ecma262/#sec-evaluatenew][EvaluateNew]]([[NewExpression][NewExpression]],
      empty).

   [[MemberExpression][MemberExpression]]:new[[MemberExpression][MemberExpression]][[Arguments][Arguments]]

   1. Return
      ? [[https://tc39.es/ecma262/#sec-evaluatenew][EvaluateNew]]([[MemberExpression][MemberExpression]],
      [[Arguments][Arguments]]).

***** Runtime Semantics: EvaluateNew ( =constructExpr=,
    =arguments= )
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluatenew-constructexpr-arguments
      :END:

    The abstract operation EvaluateNew with arguments =constructExpr=, and
    =arguments= performs the following steps:

    1. [[https://tc39.es/ecma262/#assert][Assert]]: =constructExpr= is
       either a
       [[NewExpression][NewExpression]] or a
       [[MemberExpression][MemberExpression]].
    2. [[https://tc39.es/ecma262/#assert][Assert]]: =arguments= is either
       empty or an [[Arguments][Arguments]].
    3. Let =ref= be the result of evaluating =constructExpr=.
    4. Let =constructor= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=ref=).
    5. If =arguments= is empty, let =argList= be a new empty
       [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
    6. Else,

       1. Let =argList= be ? ArgumentListEvaluation of =arguments=.

    7. If
       [[https://tc39.es/ecma262/#sec-isconstructor][IsConstructor]](=constructor=)
       is false, throw a TypeError exception.
    8. Return
       ? [[https://tc39.es/ecma262/#sec-construct][Construct]](=constructor=,
       =argList=).

*** Function Calls
    :PROPERTIES:
    :CUSTOM_ID: function-calls
    :END:

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-10
     :END:

   [[CallExpression][CallExpression]]:[[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]]

   1. Let =expr= be CoveredCallExpression of
      [[CoverCallExpressionAndAsyncArrowHead][CoverCallExpressionAndAsyncArrowHead]].
   2. Let =memberExpr= be the
      [[MemberExpression][MemberExpression]]
      of =expr=.
   3. Let =arguments= be the
      [[Arguments][Arguments]] of =expr=.
   4. Let =ref= be the result of evaluating =memberExpr=.
   5. Let =func= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=ref=).
   6. If
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=ref=)
      is
      [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]]
      and
      [[https://tc39.es/ecma262/#sec-ispropertyreference][IsPropertyReference]](=ref=)
      is false and
      [[https://tc39.es/ecma262/#sec-getreferencedname][GetReferencedName]](=ref=)
      is "eval", then

      1. If [[https://tc39.es/ecma262/#sec-samevalue][SameValue]](=func=,
         [[https://tc39.es/ecma262/#sec-eval-x][%eval%]]) is true, then

         1. Let =argList= be ? ArgumentListEvaluation of =arguments=.
         2. If =argList= has no elements, return undefined.
         3. Let =evalText= be the first element of =argList=.
         4. If the source code matching this
            [[CallExpression][CallExpression]]
            is [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode
            code]], let =strictCaller= be true. Otherwise let
            =strictCaller= be false.
         5. Let =evalRealm= be
            [[https://tc39.es/ecma262/#current-realm][the current Realm
            Record]].
         6. Return
            ? [[https://tc39.es/ecma262/#sec-performeval][PerformEval]](=evalText=,
            =evalRealm=, =strictCaller=, true).

   7. Let =thisCall= be this
      [[CallExpression][CallExpression]].
   8. Let =tailCall= be
      [[https://tc39.es/ecma262/#sec-isintailposition][IsInTailPosition]](=thisCall=).
   9. Return
      ? [[https://tc39.es/ecma262/#sec-evaluatecall][EvaluateCall]](=func=,
      =ref=, =arguments=, =tailCall=).

   A [[CallExpression][CallExpression]]
   evaluation that executes step 6.a.vi is a direct eval.

   [[CallExpression][CallExpression]]:[[CallExpression][CallExpression]][[Arguments][Arguments]]

   1. Let =ref= be the result of evaluating
      [[CallExpression][CallExpression]].
   2. Let =func= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=ref=).
   3. Let =thisCall= be this
      [[CallExpression][CallExpression]].
   4. Let =tailCall= be
      [[https://tc39.es/ecma262/#sec-isintailposition][IsInTailPosition]](=thisCall=).
   5. Return
      ? [[https://tc39.es/ecma262/#sec-evaluatecall][EvaluateCall]](=func=,
      =ref=, [[Arguments][Arguments]],
      =tailCall=).

   <<sec-evaluatedirectcall>>
**** Runtime Semantics: EvaluateCall ( =func=, =ref=, =arguments=,
   =tailPosition= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluatecall-func-ref-arguments-tailposition
     :END:

   The abstract operation EvaluateCall takes as arguments a value =func=, a
   value =ref=, a [[https://tc39.es/ecma262/#sec-syntactic-grammar][Parse
   Node]] =arguments=, and a Boolean argument =tailPosition=. It performs
   the following steps:

   1.  If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=ref=)
       is
       [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]],
       then

       1. If
          [[https://tc39.es/ecma262/#sec-ispropertyreference][IsPropertyReference]](=ref=)
          is true, then

          1. Let =thisValue= be
             [[https://tc39.es/ecma262/#sec-getthisvalue][GetThisValue]](=ref=).

       2. Else,

          1. [[https://tc39.es/ecma262/#assert][Assert]]: the base of =ref=
             is an
             [[https://tc39.es/ecma262/#sec-environment-records][Environment
             Record]].
          2. Let =refEnv= be
             [[https://tc39.es/ecma262/#sec-getbase][GetBase]](=ref=).
          3. Let =thisValue= be =refEnv=.WithBaseObject().

   2.  Else,

       1. Let =thisValue= be undefined.

   3.  Let =argList= be ? ArgumentListEvaluation of =arguments=.
   4.  If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=func=)
       is not Object, throw a TypeError exception.
   5.  If [[https://tc39.es/ecma262/#sec-iscallable][IsCallable]](=func=)
       is false, throw a TypeError exception.
   6.  If =tailPosition= is true, perform
       [[https://tc39.es/ecma262/#sec-preparefortailcall][PrepareForTailCall]]().
   7.  Let =result= be [[https://tc39.es/ecma262/#sec-call][Call]](=func=,
       =thisValue=, =argList=).
   8.  [[https://tc39.es/ecma262/#assert][Assert]]: If =tailPosition= is
       true, the above call will not return here, but instead evaluation
       will continue as if the following return has already occurred.
   9.  [[https://tc39.es/ecma262/#assert][Assert]]: If =result= is not an
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
       completion]], then
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=result=)
       is an
       [[https://tc39.es/ecma262/#sec-ecmascript-language-types][ECMAScript
       language type]].
   10. Return =result=.

*** The =super= Keyword
    :PROPERTIES:
    :CUSTOM_ID: the-super-keyword
    :END:

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-11
     :END:

   [[SuperProperty][SuperProperty]]:super[[[Expression][Expression]]]

   1. Let =env= be
      [[https://tc39.es/ecma262/#sec-getthisenvironment][GetThisEnvironment]]().
   2. Let =actualThis= be ? =env=.GetThisBinding().
   3. Let =propertyNameReference= be the result of evaluating
      [[Expression][Expression]].
   4. Let =propertyNameValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=propertyNameReference=).
   5. Let =propertyKey= be
      ? [[https://tc39.es/ecma262/#sec-topropertykey][ToPropertyKey]](=propertyNameValue=).
   6. If the code matched by this
      [[SuperProperty][SuperProperty]] is
      [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode code]],
      let =strict= be true; else let =strict= be false.
   7. Return
      ? [[https://tc39.es/ecma262/#sec-makesuperpropertyreference][MakeSuperPropertyReference]](=actualThis=,
      =propertyKey=, =strict=).

   [[SuperProperty][SuperProperty]]:super.[[IdentifierName][IdentifierName]]

   1. Let =env= be
      [[https://tc39.es/ecma262/#sec-getthisenvironment][GetThisEnvironment]]().
   2. Let =actualThis= be ? =env=.GetThisBinding().
   3. Let =propertyKey= be StringValue of
      [[IdentifierName][IdentifierName]].
   4. If the code matched by this
      [[SuperProperty][SuperProperty]] is
      [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode code]],
      let =strict= be true; else let =strict= be false.
   5. Return
      ? [[https://tc39.es/ecma262/#sec-makesuperpropertyreference][MakeSuperPropertyReference]](=actualThis=,
      =propertyKey=, =strict=).

   [[SuperCall][SuperCall]]:super[[Arguments][Arguments]]

   1. Let =newTarget= be
      [[https://tc39.es/ecma262/#sec-getnewtarget][GetNewTarget]]().
   2. [[https://tc39.es/ecma262/#assert][Assert]]:
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=newTarget=)
      is Object.
   3. Let =func= be
      ? [[https://tc39.es/ecma262/#sec-getsuperconstructor][GetSuperConstructor]]().
   4. Let =argList= be ? ArgumentListEvaluation of
      [[Arguments][Arguments]].
   5. Let =result= be
      ? [[https://tc39.es/ecma262/#sec-construct][Construct]](=func=,
      =argList=, =newTarget=).
   6. Let =thisER= be
      [[https://tc39.es/ecma262/#sec-getthisenvironment][GetThisEnvironment]]().
   7. Return ? =thisER=.BindThisValue(=result=).

**** Runtime Semantics: GetSuperConstructor ( )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-getsuperconstructor
     :END:

   The abstract operation GetSuperConstructor performs the following steps:

   1. Let =envRec= be
      [[https://tc39.es/ecma262/#sec-getthisenvironment][GetThisEnvironment]]().
   2. [[https://tc39.es/ecma262/#assert][Assert]]: =envRec= is a
      [[https://tc39.es/ecma262/#sec-function-environment-records][function
      Environment Record]].
   3. Let =activeFunction= be =envRec=.[[FunctionObject]].
   4. [[https://tc39.es/ecma262/#assert][Assert]]: =activeFunction= is an
      ECMAScript [[https://tc39.es/ecma262/#function-object][function
      object]].
   5. Let =superConstructor= be ! =activeFunction=.[[GetPrototypeOf]]().
   6. If
      [[https://tc39.es/ecma262/#sec-isconstructor][IsConstructor]](=superConstructor=)
      is false, throw a TypeError exception.
   7. Return =superConstructor=.

**** Runtime Semantics: MakeSuperPropertyReference ( =actualThis=,
   =propertyKey=, =strict= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-makesuperpropertyreference-actualthis-propertykey-strict
     :END:

   The abstract operation MakeSuperPropertyReference with arguments
   =actualThis=, =propertyKey=, and =strict= performs the following steps:

   1. Let =env= be
      [[https://tc39.es/ecma262/#sec-getthisenvironment][GetThisEnvironment]]().
   2. [[https://tc39.es/ecma262/#assert][Assert]]: =env=.HasSuperBinding()
      is true.
   3. Let =baseValue= be ? =env=.GetSuperBase().
   4. Let =bv= be
      ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=baseValue=).
   5. Return a value of type
      [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]]
      that is a [[https://tc39.es/ecma262/#super-reference][Super
      Reference]] whose base value component is =bv=, whose referenced name
      component is =propertyKey=, whose thisValue component is
      =actualThis=, and whose strict reference flag is =strict=.

*** Argument Lists
    :PROPERTIES:
    :CUSTOM_ID: argument-lists
    :END:

  Note

  The evaluation of an argument list produces a
  [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
  of values.

**** Runtime Semantics: ArgumentListEvaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-argumentlistevaluation-1
     :END:

   [[Arguments][Arguments]]:()

   1. Return a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].

   [[ArgumentList][ArgumentList]]:[[AssignmentExpression][AssignmentExpression]]

   1. Let =ref= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   2. Let =arg= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=ref=).
   3. Return a
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
      whose sole item is =arg=.

   [[ArgumentList][ArgumentList]]:...[[AssignmentExpression][AssignmentExpression]]

   1. Let =list= be a new empty
      [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
   2. Let =spreadRef= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   3. Let =spreadObj= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=spreadRef=).
   4. Let =iteratorRecord= be
      ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=spreadObj=).
   5. Repeat,

      1. Let =next= be
         ? [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
      2. If =next= is false, return =list=.
      3. Let =nextArg= be
         ? [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
      4. Append =nextArg= as the last element of =list=.

   [[ArgumentList][ArgumentList]]:[[ArgumentList][ArgumentList]],[[AssignmentExpression][AssignmentExpression]]

   1. Let =precedingArgs= be ? ArgumentListEvaluation of
      [[ArgumentList][ArgumentList]].
   2. Let =ref= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   3. Let =arg= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=ref=).
   4. Append =arg= to the end of =precedingArgs=.
   5. Return =precedingArgs=.

   [[ArgumentList][ArgumentList]]:[[ArgumentList][ArgumentList]],...[[AssignmentExpression][AssignmentExpression]]

   1. Let =precedingArgs= be ? ArgumentListEvaluation of
      [[ArgumentList][ArgumentList]].
   2. Let =spreadRef= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   3. Let =iteratorRecord= be
      ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](?
      [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=spreadRef=)).
   4. Repeat,

      1. Let =next= be
         ? [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
      2. If =next= is false, return =precedingArgs=.
      3. Let =nextArg= be
         ? [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
      4. Append =nextArg= as the last element of =precedingArgs=.

*** Import Calls
    :PROPERTIES:
    :CUSTOM_ID: import-calls
    :END:

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-12
     :END:

   [[ImportCall][ImportCall]]:import([[AssignmentExpression][AssignmentExpression]])

   1. Let =referencingScriptOrModule= be
      ! [[https://tc39.es/ecma262/#sec-getactivescriptormodule][GetActiveScriptOrModule]]().
   2. Let =argRef= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   3. Let =specifier= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=argRef=).
   4. Let =promiseCapability= be
      ! [[https://tc39.es/ecma262/#sec-newpromisecapability][NewPromiseCapability]]([[https://tc39.es/ecma262/#sec-promise-constructor][%Promise%]]).
   5. Let =specifierString= be
      [[https://tc39.es/ecma262/#sec-tostring][ToString]](=specifier=).
   6. [[https://tc39.es/ecma262/#sec-ifabruptrejectpromise][IfAbruptRejectPromise]](=specifierString=,
      =promiseCapability=).
   7. Perform
      ! [[https://tc39.es/ecma262/#sec-hostimportmoduledynamically][HostImportModuleDynamically]](=referencingScriptOrModule=,
      =specifierString=, =promiseCapability=).
   8. Return =promiseCapability=.[[Promise]].

*** Tagged Templates
    :PROPERTIES:
    :CUSTOM_ID: tagged-templates
    :END:

  Note

  A tagged template is a function call where the arguments of the call are
  derived from a
  [[TemplateLiteral][TemplateLiteral]]
  ([[https://tc39.es/ecma262/#sec-template-literals][12.2.9]]). The actual
  arguments include a template object
  ([[https://tc39.es/ecma262/#sec-gettemplateobject][12.2.9.4]]) and the
  values produced by evaluating the expressions embedded within the
  [[TemplateLiteral][TemplateLiteral]].

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-13
     :END:

   [[MemberExpression][MemberExpression]]:[[MemberExpression][MemberExpression]][[TemplateLiteral][TemplateLiteral]]

   1. Let =tagRef= be the result of evaluating
      [[MemberExpression][MemberExpression]].
   2. Let =tagFunc= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=tagRef=).
   3. Let =thisCall= be this
      [[MemberExpression][MemberExpression]].
   4. Let =tailCall= be
      [[https://tc39.es/ecma262/#sec-isintailposition][IsInTailPosition]](=thisCall=).
   5. Return
      ? [[https://tc39.es/ecma262/#sec-evaluatecall][EvaluateCall]](=tagFunc=,
      =tagRef=,
      [[TemplateLiteral][TemplateLiteral]],
      =tailCall=).

   [[CallExpression][CallExpression]]:[[CallExpression][CallExpression]][[TemplateLiteral][TemplateLiteral]]

   1. Let =tagRef= be the result of evaluating
      [[CallExpression][CallExpression]].
   2. Let =tagFunc= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=tagRef=).
   3. Let =thisCall= be this
      [[CallExpression][CallExpression]].
   4. Let =tailCall= be
      [[https://tc39.es/ecma262/#sec-isintailposition][IsInTailPosition]](=thisCall=).
   5. Return
      ? [[https://tc39.es/ecma262/#sec-evaluatecall][EvaluateCall]](=tagFunc=,
      =tagRef=,
      [[TemplateLiteral][TemplateLiteral]],
      =tailCall=).

*** Meta Properties
    :PROPERTIES:
    :CUSTOM_ID: meta-properties
    :END:

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-14
     :END:

   [[NewTarget][NewTarget]]:new.target

   1. Return [[https://tc39.es/ecma262/#sec-getnewtarget][GetNewTarget]]().

*** Update Expressions
    :PROPERTIES:
    :CUSTOM_ID: update-expressions
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-24
     :END:

***** UpdateExpression

     [[UpdateExpression][UpdateExpression]][Yield, Await]:
       [[LeftHandSideExpression][LeftHandSideExpression]][?Yield, ?Await]
       [[LeftHandSideExpression][LeftHandSideExpression]][?Yield, ?Await][no [[file:lexical.org::#LineTerminator][LineTerminator]] here]++
       [[LeftHandSideExpression][LeftHandSideExpression]][?Yield, ?Await][no [[file:lexical.org::#LineTerminator][LineTerminator]] here]--
       ++[[UnaryExpression][UnaryExpression]][?Yield, ?Await] --[[UnaryExpression][UnaryExpression]][?Yield, ?Await]

       #+begin_src gerbil :noweb-ref update-expression
         (defstruct (update-expression expression) (prefix expression postfix) transparent: #t)
         (def UpdateExpression
           (let (ops (.or (tpv? "++") (tpv? "--") #f))
             (.begin
               #t (.or (.let* ((pre ops) (exp LeftHandSideExpression)
                               (post (.or (.begin (no-token-here 'LineTerminator) ops)
                                          #f)))
                         (if (not (or pre post)) FAIL
                             (return (update-expression pre exp post))))
                       LeftHandSideExpression))))
       #+end_src

       

**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-7
     :END:

   [[UpdateExpression][UpdateExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]++
   [[LeftHandSideExpression][LeftHandSideExpression]]--

   - It is an early Syntax Error if AssignmentTargetType of
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is not simple.

   [[UpdateExpression][UpdateExpression]]:++[[UnaryExpression][UnaryExpression]]
   --[[UnaryExpression][UnaryExpression]]

   - It is an early Syntax Error if AssignmentTargetType of
     [[UnaryExpression][UnaryExpression]] is
     not simple.

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-3
     :END:

   [[UpdateExpression][UpdateExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]++
   [[LeftHandSideExpression][LeftHandSideExpression]]--
   ++[[UnaryExpression][UnaryExpression]]
   --[[UnaryExpression][UnaryExpression]]

   1. Return false.

   <<sec-update-expressions-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-4
     :END:

   [[UpdateExpression][UpdateExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]++
   [[LeftHandSideExpression][LeftHandSideExpression]]--
   ++[[UnaryExpression][UnaryExpression]]
   --[[UnaryExpression][UnaryExpression]]

   1. Return invalid.

**** Postfix Increment Operator
     :PROPERTIES:
     :CUSTOM_ID: postfix-increment-operator
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-15
      :END:

    [[UpdateExpression][UpdateExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]++

    1. Let =lhs= be the result of evaluating
       [[LeftHandSideExpression][LeftHandSideExpression]].
    2. Let =oldValue= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lhs=)).
    3. Let =newValue= be
       ! [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldvalue=)::add(=oldValue=,
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldValue=)::unit).
    4. Perform ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=,
       =newValue=).
    5. Return =oldValue=.

**** Postfix Decrement Operator
     :PROPERTIES:
     :CUSTOM_ID: postfix-decrement-operator
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-16
      :END:

    [[UpdateExpression][UpdateExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]--

    1. Let =lhs= be the result of evaluating
       [[LeftHandSideExpression][LeftHandSideExpression]].
    2. Let =oldValue= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lhs=)).
    3. Let =newValue= be
       ! [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldvalue=)::subtract(=oldValue=,
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldValue=)::unit).
    4. Perform ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lhs=,
       =newValue=).
    5. Return =oldValue=.

**** Prefix Increment Operator
     :PROPERTIES:
     :CUSTOM_ID: prefix-increment-operator
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-17
      :END:

    [[UpdateExpression][UpdateExpression]]:++[[UnaryExpression][UnaryExpression]]

    1. Let =expr= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. Let =oldValue= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=expr=)).
    3. Let =newValue= be
       ! [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldvalue=)::add(=oldValue=,
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldValue=)::unit).
    4. Perform ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=expr=,
       =newValue=).
    5. Return =newValue=.

**** Prefix Decrement Operator
     :PROPERTIES:
     :CUSTOM_ID: prefix-decrement-operator
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-18
      :END:

    [[UpdateExpression][UpdateExpression]]:--[[UnaryExpression][UnaryExpression]]

    1. Let =expr= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. Let =oldValue= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=expr=)).
    3. Let =newValue= be
       ! [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldvalue=)::subtract(=oldValue=,
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldValue=)::unit).
    4. Perform ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=expr=,
       =newValue=).
    5. Return =newValue=.

*** Unary Operators
    :PROPERTIES:
    :CUSTOM_ID: unary-operators
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-25
     :END:

***** UnaryExpression

     [[UnaryExpression][UnaryExpression]][Yield, Await]:
       [[UpdateExpression][UpdateExpression]][?Yield, ?Await]
       delete[[UnaryExpression][UnaryExpression]][?Yield, ?Await]
       void[[UnaryExpression][UnaryExpression]][?Yield, ?Await]
       typeof[[UnaryExpression][UnaryExpression]][?Yield, ?Await]
       +[[UnaryExpression][UnaryExpression]][?Yield, ?Await]
       -[[UnaryExpression][UnaryExpression]][?Yield, ?Await]
       ~[[UnaryExpression][UnaryExpression]][?Yield, ?Await]
       ![[UnaryExpression][UnaryExpression]][?Yield, ?Await]
       [+Await][[AwaitExpression][AwaitExpression]][?Yield]

       #+begin_src gerbil :noweb-ref unary-expression
         (defstruct (unary-expression expression) (op expression) transparent: #t)
         (def UnaryExpression
           (.begin
             #t
             (.or (.let* ((op (tpv? (.or "delete" "void" "typeof" "+" "-" "~" "!")))
                          (exp UpdateExpression))
                    (return (unary-expression op exp)))
                  UpdateExpression)))
       #+end_src
**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-4
     :END:

   [[UnaryExpression][UnaryExpression]]:delete[[UnaryExpression][UnaryExpression]]
   void[[UnaryExpression][UnaryExpression]]
   typeof[[UnaryExpression][UnaryExpression]]
   +[[UnaryExpression][UnaryExpression]] -[[UnaryExpression][UnaryExpression]]
   ~[[UnaryExpression][UnaryExpression]]
   ![[UnaryExpression][UnaryExpression]]
   [[AwaitExpression][AwaitExpression]]

   1. Return false.

   <<sec-unary-operators-static-semantics-isvalidsimpleassignmenttarget>>
***** atic Semantics: AssignmentTargetType
      :PROPERTIES:
      :CUSTOM_ID: static-semantics-assignmenttargettype-5
      :END:

    [[UnaryExpression][UnaryExpression]]:delete[[UnaryExpression][UnaryExpression]]
    void[[UnaryExpression][UnaryExpression]]
    typeof[[UnaryExpression][UnaryExpression]]
    +[[UnaryExpression][UnaryExpression]] -[[UnaryExpression][UnaryExpression]]
    ~[[UnaryExpression][UnaryExpression]]
    ![[UnaryExpression][UnaryExpression]]
    [[AwaitExpression][AwaitExpression]]

    1. Return invalid.

**** The =delete= Operator
     :PROPERTIES:
     :CUSTOM_ID: the-delete-operator
     :END:

***** Static Semantics: Early Errors
      :PROPERTIES:
      :CUSTOM_ID: static-semantics-early-errors-8
      :END:

    [[UnaryExpression][UnaryExpression]]:delete[[UnaryExpression][UnaryExpression]]

    - It is a Syntax Error if the
      [[UnaryExpression][UnaryExpression]] is
      contained in [[https://tc39.es/ecma262/#sec-strict-mode-code][strict
      mode code]] and the derived
      [[UnaryExpression][UnaryExpression]] is
      [[PrimaryExpression][PrimaryExpression]]:[[IdentifierReference][IdentifierReference]]
      .

    - It is a Syntax Error if the derived
      [[UnaryExpression][UnaryExpression]]
      is\\
      [[PrimaryExpression][PrimaryExpression]]:[[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]\\
      and
      [[CoverParenthesizedExpressionAndArrowParameterList][CoverParenthesizedExpressionAndArrowParameterList]]
      ultimately derives a phrase that, if used in place of
      [[UnaryExpression][UnaryExpression]],
      would produce a Syntax Error according to these rules. This rule is
      recursively applied.

    Note

    The last rule means that expressions such as =delete (((foo)))= produce
    early errors because of recursive application of the first rule.

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-19
      :END:

    [[UnaryExpression][UnaryExpression]]:delete[[UnaryExpression][UnaryExpression]]

    1. Let =ref= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=ref=).
    3. If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=ref=)
       is not
       [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]],
       return true.
    4. If
       [[https://tc39.es/ecma262/#sec-isunresolvablereference][IsUnresolvableReference]](=ref=)
       is true, then

       1. [[https://tc39.es/ecma262/#assert][Assert]]:
          [[https://tc39.es/ecma262/#sec-isstrictreference][IsStrictReference]](=ref=)
          is false.
       2. Return true.

    5. If
       [[https://tc39.es/ecma262/#sec-ispropertyreference][IsPropertyReference]](=ref=)
       is true, then

       1. If
          [[https://tc39.es/ecma262/#sec-issuperreference][IsSuperReference]](=ref=)
          is true, throw a ReferenceError exception.
       2. Let =baseObj= be
          ! [[https://tc39.es/ecma262/#sec-toobject][ToObject]]([[https://tc39.es/ecma262/#sec-getbase][GetBase]](=ref=)).
       3. Let =deleteStatus= be ?
          =baseObj=.[[Delete]]([[https://tc39.es/ecma262/#sec-getreferencedname][GetReferencedName]](=ref=)).
       4. If =deleteStatus= is false and
          [[https://tc39.es/ecma262/#sec-isstrictreference][IsStrictReference]](=ref=)
          is true, throw a TypeError exception.
       5. Return =deleteStatus=.

    6. Else,

       1. [[https://tc39.es/ecma262/#assert][Assert]]: =ref= is a
          [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]]
          to an
          [[https://tc39.es/ecma262/#sec-environment-records][Environment
          Record]] binding.
       2. Let =bindings= be
          [[https://tc39.es/ecma262/#sec-getbase][GetBase]](=ref=).
       3. Return ?
          =bindings=.DeleteBinding([[https://tc39.es/ecma262/#sec-getreferencedname][GetReferencedName]](=ref=)).

    Note

    When a =delete= operator occurs within
    [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode code]], a
    SyntaxError exception is thrown if its
    [[UnaryExpression][UnaryExpression]] is a
    direct reference to a variable, function argument, or function name. In
    addition, if a =delete= operator occurs within
    [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode code]] and
    the property to be deleted has the attribute { [[Configurable]]: false
    }, a TypeError exception is thrown.

**** The =void= Operator
     :PROPERTIES:
     :CUSTOM_ID: the-void-operator
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-20
      :END:

    [[UnaryExpression][UnaryExpression]]:void[[UnaryExpression][UnaryExpression]]

    1. Let =expr= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. Perform
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=expr=).
    3. Return undefined.

    Note

    [[https://tc39.es/ecma262/#sec-getvalue][GetValue]] must be called even
    though its value is not used because it may have observable
    side-effects.

**** The =typeof= Operator
     :PROPERTIES:
     :CUSTOM_ID: the-typeof-operator
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-21
      :END:

    [[UnaryExpression][UnaryExpression]]:typeof[[UnaryExpression][UnaryExpression]]

    1. Let =val= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=val=)
       is
       [[https://tc39.es/ecma262/#sec-reference-specification-type][Reference]],
       then

       1. If
          [[https://tc39.es/ecma262/#sec-isunresolvablereference][IsUnresolvableReference]](=val=)
          is true, return "undefined".

    3. Set =val= to
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=val=).
    4. Return a String according to
       [[https://tc39.es/ecma262/#table-35][Table 37]].

    Table 37: typeof Operator Results
    | Type of =val=                          | Result        |
    |----------------------------------------+---------------|
    | Undefined                              | "undefined"   |
    | Null                                   | "object"      |
    | Boolean                                | "boolean"     |
    | Number                                 | "number"      |
    | String                                 | "string"      |
    | Symbol                                 | "symbol"      |
    | BigInt                                 | "bigint"      |
    | Object (does not implement [[Call]])   | "object"      |
    | Object (implements [[Call]])           | "function"    |

**** Unary =+= Operator
     :PROPERTIES:
     :CUSTOM_ID: unary-operator
     :END:

   Note

   The unary + operator converts its operand to Number type.

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-22
      :END:

    [[UnaryExpression][UnaryExpression]]:+[[UnaryExpression][UnaryExpression]]

    1. Let =expr= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. Return ? [[https://tc39.es/ecma262/#sec-tonumber][ToNumber]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=expr=)).

**** Unary =-= Operator
     :PROPERTIES:
     :CUSTOM_ID: unary---operator
     :END:

   Note

   The unary =-= operator converts its operand to Number type and then
   negates it. Negating +0 produces -0, and negating -0 produces +0.

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-23
      :END:

    [[UnaryExpression][UnaryExpression]]:-[[UnaryExpression][UnaryExpression]]

    1. Let =expr= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. Let =oldValue= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=expr=)).
    3. Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldValue=).
    4. Return ! =T=::unaryMinus(=oldValue=).

*** Bitwise NOT Operator ( =~= )
    :PROPERTIES:
    :CUSTOM_ID: bitwise-not-operator
    :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-24
      :END:

    [[UnaryExpression][UnaryExpression]]:~[[UnaryExpression][UnaryExpression]]

    1. Let =expr= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. Let =oldValue= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=expr=)).
    3. Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=oldValue=).
    4. Return ! =T=::bitwiseNOT(=oldValue=).

*** Logical NOT Operator ( =!= )
    :PROPERTIES:
    :CUSTOM_ID: logical-not-operator
    :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-25
      :END:

    [[UnaryExpression][UnaryExpression]]:![[UnaryExpression][UnaryExpression]]

    1. Let =expr= be the result of evaluating
       [[UnaryExpression][UnaryExpression]].
    2. Let =oldValue= be
       ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](?
       [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=expr=)).
    3. If =oldValue= is true, return false.
    4. Return true.

*** Exponentiation Operator
    :PROPERTIES:
    :CUSTOM_ID: exponentiation-operator
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-26
     :END:

***** ExponentiationExpression 

      [[ExponentiationExpression][ExponentiationExpression]][Yield, Await]:
        [[UnaryExpression][UnaryExpression]][?Yield, ?Await]
        [[UpdateExpression][UpdateExpression]][?Yield, ?Await]**[[ExponentiationExpression][ExponentiationExpression]][?Yield, ?Await]


      #+begin_src gerbil :noweb-ref exponentiation-expression
        (defstruct (exponentiation-expression operator) () transparent: #t)
        (def ExponentiationExpression
          (Operator exponentiation-expression UnaryExpression "**"))

      #+end_src
**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-5
     :END:

   [[ExponentiationExpression][ExponentiationExpression]]:[[UpdateExpression][UpdateExpression]]**[[ExponentiationExpression][ExponentiationExpression]]

   1. Return false.

   <<sec-exp-operator-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-6
     :END:

   [[ExponentiationExpression][ExponentiationExpression]]:[[UpdateExpression][UpdateExpression]]**[[ExponentiationExpression][ExponentiationExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-26
     :END:

   [[ExponentiationExpression][ExponentiationExpression]]:[[UpdateExpression][UpdateExpression]]**[[ExponentiationExpression][ExponentiationExpression]]

   1. Let =left= be the result of evaluating
      [[UpdateExpression][UpdateExpression]].
   2. Let =leftValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=left=).
   3. Let =right= be the result of evaluating
      [[ExponentiationExpression][ExponentiationExpression]].
   4. Let =rightValue= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=right=).
   5. Let =base= be
      ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=leftValue=).
   6. Let =exponent= be
      ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rightValue=).
   7. If
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=base=)
      is different from
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=exponent=),
      throw a TypeError exception.
   8. Return
      ? [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=base=)::exponentiate(=base=,
      =exponent=).

*** Multiplicative Operators
    :PROPERTIES:
    :CUSTOM_ID: multiplicative-operators
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-27
     :END:

*****  MultiplicativeExpression
   
      [[MultiplicativeExpression][MultiplicativeExpression]][Yield, Await]:
       [[ExponentiationExpression][ExponentiationExpression]][?Yield, ?Await]
       [[MultiplicativeExpression][MultiplicativeExpression]][?Yield, ?Await][[MultiplicativeOperator][MultiplicativeOperator]][[ExponentiationExpression][ExponentiationExpression]][?Yield, ?Await]

      #+begin_src gerbil :noweb-ref multiplicative-expression
        (defstruct (multiplicative-expression operator) () transparent: #t)
        (def MultiplicativeExpression
          (Operator multiplicative-expression ExponentiationExpression MultiplicativeOperator))

      #+end_src
***** MultiplicativeOperator 

     [[MultiplicativeOperator][MultiplicativeOperator]]:
       one of*/%

       #+begin_src gerbil :noweb-ref multiplicative-operator
         (def MultiplicativeOperator (.or #\* #\/ #\%))
       #+end_src
**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-6
     :END:

   [[MultiplicativeExpression][MultiplicativeExpression]]:[[MultiplicativeExpression][MultiplicativeExpression]][[MultiplicativeOperator][MultiplicativeOperator]][[ExponentiationExpression][ExponentiationExpression]]

   1. Return false.

   <<sec-multiplicative-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-7
     :END:

   [[MultiplicativeExpression][MultiplicativeExpression]]:[[MultiplicativeExpression][MultiplicativeExpression]][[MultiplicativeOperator][MultiplicativeOperator]][[ExponentiationExpression][ExponentiationExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-27
     :END:

   [[MultiplicativeExpression][MultiplicativeExpression]]:[[MultiplicativeExpression][MultiplicativeExpression]][[MultiplicativeOperator][MultiplicativeOperator]][[ExponentiationExpression][ExponentiationExpression]]

   1.  Let =left= be the result of evaluating
       [[MultiplicativeExpression][MultiplicativeExpression]].
   2.  Let =leftValue= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=left=).
   3.  Let =right= be the result of evaluating
       [[ExponentiationExpression][ExponentiationExpression]].
   4.  Let =rightValue= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=right=).
   5.  Let =lnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=leftValue=).
   6.  Let =rnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rightValue=).
   7.  If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=)
       is different from
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rnum=),
       throw a TypeError exception.
   8.  Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=).
   9.  If
       [[MultiplicativeOperator][MultiplicativeOperator]]
       is =*=, return =T=::multiply(=lnum=, =rnum=).
   10. If
       [[MultiplicativeOperator][MultiplicativeOperator]]
       is =/=, return =T=::divide(=lnum=, =rnum=).
   11. Else,

       1. [[https://tc39.es/ecma262/#assert][Assert]]:
          [[MultiplicativeOperator][MultiplicativeOperator]]
          is =%=.
       2. Return =T=::remainder(=lnum=, =rnum=).

*** Additive Operators
    :PROPERTIES:
    :CUSTOM_ID: additive-operators
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-28
     :END:

***** AdditiveExpression

   [[AdditiveExpression][AdditiveExpression]][Yield, Await]:
     [[MultiplicativeExpression][MultiplicativeExpression]][?Yield, ?Await]
     [[AdditiveExpression][AdditiveExpression]][?Yield, ?Await]+[[MultiplicativeExpression][MultiplicativeExpression]][?Yield, ?Await]
     [[AdditiveExpression][AdditiveExpression]][?Yield, ?Await]-[[MultiplicativeExpression][MultiplicativeExpression]][?Yield, ?Await]



      #+begin_src gerbil :noweb-ref additive-expression
        (defstruct (additive-expression operator) () transparent: #t)
        (def AdditiveExpression
          (.or (Operator additive-expression MultiplicativeExpression "+")
               (Operator additive-expression MultiplicativeExpression "-")))

      #+end_src


**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-7
     :END:

   [[AdditiveExpression][AdditiveExpression]]:[[AdditiveExpression][AdditiveExpression]]+[[MultiplicativeExpression][MultiplicativeExpression]]
   [[AdditiveExpression][AdditiveExpression]]-[[MultiplicativeExpression][MultiplicativeExpression]]

   1. Return false.

   <<sec-additive-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-8
     :END:

   [[AdditiveExpression][AdditiveExpression]]:[[AdditiveExpression][AdditiveExpression]]+[[MultiplicativeExpression][MultiplicativeExpression]]
   [[AdditiveExpression][AdditiveExpression]]-[[MultiplicativeExpression][MultiplicativeExpression]]

   1. Return invalid.

**** The Addition Operator ( =+= )
     :PROPERTIES:
     :CUSTOM_ID: the-addition-operator
     :END:

   Note

   The addition operator either performs string concatenation or numeric
   addition.

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-28
      :END:

    [[AdditiveExpression][AdditiveExpression]]:[[AdditiveExpression][AdditiveExpression]]+[[MultiplicativeExpression][MultiplicativeExpression]]

    1.  Let =lref= be the result of evaluating
        [[AdditiveExpression][AdditiveExpression]].
    2.  Let =lval= be
        ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
    3.  Let =rref= be the result of evaluating
        [[MultiplicativeExpression][MultiplicativeExpression]].
    4.  Let =rval= be
        ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
    5.  Let =lprim= be
        ? [[https://tc39.es/ecma262/#sec-toprimitive][ToPrimitive]](=lval=).
    6.  Let =rprim= be
        ? [[https://tc39.es/ecma262/#sec-toprimitive][ToPrimitive]](=rval=).
    7.  If
        [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lprim=)
        is String or
        [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rprim=)
        is String, then

        1. Let =lstr= be
           ? [[https://tc39.es/ecma262/#sec-tostring][ToString]](=lprim=).
        2. Let =rstr= be
           ? [[https://tc39.es/ecma262/#sec-tostring][ToString]](=rprim=).
        3. Return the
           [[https://tc39.es/ecma262/#sec-ecmascript-language-types-string-type][string-concatenation]]
           of =lstr= and =rstr=.

    8.  Let =lnum= be
        ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=lprim=).
    9.  Let =rnum= be
        ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rprim=).
    10. If
        [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=)
        is different from
        [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rnum=),
        throw a TypeError exception.
    11. Let =T= be
        [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=).
    12. Return =T=::add(=lnum=, =rnum=).

    Note 1

    No hint is provided in the calls to
    [[https://tc39.es/ecma262/#sec-toprimitive][ToPrimitive]] in steps 5 and
    6. All standard objects except Date objects handle the absence of a hint
    as if the hint Number were given; Date objects handle the absence of a
    hint as if the hint String were given. Exotic objects may handle the
    absence of a hint in some other manner.

    Note 2

    Step 7 differs from step 3 of the
    [[https://tc39.es/ecma262/#sec-abstract-relational-comparison][Abstract
    Relational Comparison]] algorithm, by using the logical-or operation
    instead of the logical-and operation.

**** The Subtraction Operator ( =-= )
     :PROPERTIES:
     :CUSTOM_ID: the-subtraction-operator--
     :END:

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-29
      :END:

    [[AdditiveExpression][AdditiveExpression]]:[[AdditiveExpression][AdditiveExpression]]-[[MultiplicativeExpression][MultiplicativeExpression]]

    1. Let =lref= be the result of evaluating
       [[AdditiveExpression][AdditiveExpression]].
    2. Let =lval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
    3. Let =rref= be the result of evaluating
       [[MultiplicativeExpression][MultiplicativeExpression]].
    4. Let =rval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
    5. Let =lnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=lval=).
    6. Let =rnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rval=).
    7. If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=)
       is different from
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rnum=),
       throw a TypeError exception.
    8. Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=).
    9. Return =T=::subtract(=lnum=, =rnum=).

*** Bitwise Shift Operators
    :PROPERTIES:
    :CUSTOM_ID: bitwise-shift-operators
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-29
     :END:

***** ShiftExpression

   [[ShiftExpression][ShiftExpression]][Yield, Await]:
     [[AdditiveExpression][AdditiveExpression]][?Yield, ?Await]
     [[ShiftExpression][ShiftExpression]][?Yield, ?Await]<<[[AdditiveExpression][AdditiveExpression]][?Yield, ?Await]
     [[ShiftExpression][ShiftExpression]][?Yield, ?Await]>>[[AdditiveExpression][AdditiveExpression]][?Yield, ?Await]
     [[ShiftExpression][ShiftExpression]][?Yield, ?Await]>>>[[AdditiveExpression][AdditiveExpression]][?Yield, ?Await]


      #+begin_src gerbil :noweb-ref shift-expression
        (defstruct (shift-expression operator) () transparent: #t)
        (def ShiftExpression
          (.or (Operator shift-expression AdditiveExpression "<<")
               (Operator shift-expression AdditiveExpression ">>")
               (Operator shift-expression AdditiveExpression ">>>")))

      #+end_src
**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-8
     :END:

   [[ShiftExpression][ShiftExpression]]:[[ShiftExpression][ShiftExpression]]<<[[AdditiveExpression][AdditiveExpression]]
   [[ShiftExpression][ShiftExpression]]>>[[AdditiveExpression][AdditiveExpression]]
   [[ShiftExpression][ShiftExpression]]>>>[[AdditiveExpression][AdditiveExpression]]

   1. Return false.

   <<sec-bitwise-shift-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-9
     :END:

   [[ShiftExpression][ShiftExpression]]:[[ShiftExpression][ShiftExpression]]<<[[AdditiveExpression][AdditiveExpression]]
   [[ShiftExpression][ShiftExpression]]>>[[AdditiveExpression][AdditiveExpression]]
   [[ShiftExpression][ShiftExpression]]>>>[[AdditiveExpression][AdditiveExpression]]

   1. Return invalid.

**** The Left Shift Operator ( =<<= )
     :PROPERTIES:
     :CUSTOM_ID: the-left-shift-operator
     :END:

   Note

   Performs a bitwise left shift operation on the left operand by the
   amount specified by the right operand.

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-30
      :END:

    [[ShiftExpression][ShiftExpression]]:[[ShiftExpression][ShiftExpression]]<<[[AdditiveExpression][AdditiveExpression]]

    1. Let =lref= be the result of evaluating
       [[ShiftExpression][ShiftExpression]].
    2. Let =lval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
    3. Let =rref= be the result of evaluating
       [[AdditiveExpression][AdditiveExpression]].
    4. Let =rval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
    5. Let =lnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=lval=).
    6. Let =rnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rval=).
    7. If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=)
       is different from
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rnum=),
       throw a TypeError exception.
    8. Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=).
    9. Return =T=::leftShift(=lnum=, =rnum=).

**** The Signed Right Shift Operator ( =>>= )
     :PROPERTIES:
     :CUSTOM_ID: the-signed-right-shift-operator
     :END:

   Note

   Performs a sign-filling bitwise right shift operation on the left
   operand by the amount specified by the right operand.

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-31
      :END:

    [[ShiftExpression][ShiftExpression]]:[[ShiftExpression][ShiftExpression]]>>[[AdditiveExpression][AdditiveExpression]]

    1. Let =lref= be the result of evaluating
       [[ShiftExpression][ShiftExpression]].
    2. Let =lval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
    3. Let =rref= be the result of evaluating
       [[AdditiveExpression][AdditiveExpression]].
    4. Let =rval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
    5. Let =lnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=lval=).
    6. Let =rnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rval=).
    7. If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=)
       is different from
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rnum=),
       throw a TypeError exception.
    8. Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=).
    9. Return =T=::signedRightShift(=lnum=, =rnum=).

**** The Unsigned Right Shift Operator ( =>>>= )
     :PROPERTIES:
     :CUSTOM_ID: the-unsigned-right-shift-operator
     :END:

   Note

   Performs a zero-filling bitwise right shift operation on the left
   operand by the amount specified by the right operand.

***** Runtime Semantics: Evaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-evaluation-32
      :END:

    [[ShiftExpression][ShiftExpression]]:[[ShiftExpression][ShiftExpression]]>>>[[AdditiveExpression][AdditiveExpression]]

    1. Let =lref= be the result of evaluating
       [[ShiftExpression][ShiftExpression]].
    2. Let =lval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
    3. Let =rref= be the result of evaluating
       [[AdditiveExpression][AdditiveExpression]].
    4. Let =rval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
    5. Let =lnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=lval=).
    6. Let =rnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rval=).
    7. If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=)
       is different from
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rnum=),
       throw a TypeError exception.
    8. Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=).
    9. Return =T=::unsignedRightShift(=lnum=, =rnum=).

*** Relational Operators
    :PROPERTIES:
    :CUSTOM_ID: relational-operators
    :END:

  Note 1

  The result of evaluating a relational operator is always of type
  Boolean, reflecting whether the relationship named by the operator holds
  between its two operands.

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-30
     :END:

***** RelationalExpression 

   [[RelationalExpression][RelationalExpression]][In, Yield, Await]: 
    [[ShiftExpression][ShiftExpression]][?Yield, ?Await]
    [[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]<[[ShiftExpression][ShiftExpression]][?Yield, ?Await]
    [[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]>[[ShiftExpression][ShiftExpression]][?Yield, ?Await]
    [[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]<=[[ShiftExpression][ShiftExpression]][?Yield, ?Await]
    [[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]>=[[ShiftExpression][ShiftExpression]][?Yield, ?Await]
    [[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]instanceof[[ShiftExpression][ShiftExpression]][?Yield, ?Await]
    [+In][[RelationalExpression][RelationalExpression]][+In, ?Yield, ?Await]in[[ShiftExpression][ShiftExpression]][?Yield, ?Await] 


      #+begin_src gerbil :noweb-ref relational-expression
        (defstruct (relational-expression operator) () transparent: #t)
        (def RelationalExpression
          (.or (Operator relational-expression ShiftExpression "<")
               (Operator relational-expression ShiftExpression ">")
               (Operator relational-expression ShiftExpression "<=")
               (Operator relational-expression ShiftExpression ">=")
               (Operator relational-expression ShiftExpression "instanceof")
               (Operator relational-expression ShiftExpression "in")))

      #+end_src


    Note 2

   The _{[In]} grammar parameter is needed to avoid confusing the =in=
   operator in a relational expression with the =in= operator in a =for=
   statement.

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-9
     :END:

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]<[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]>[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]<=[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]>=[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]instanceof[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]in[[ShiftExpression][ShiftExpression]]

   1. Return false.

   <<sec-relational-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-10
     :END:

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]<[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]>[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]<=[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]>=[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]instanceof[[ShiftExpression][ShiftExpression]]
   [[RelationalExpression][RelationalExpression]]in[[ShiftExpression][ShiftExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-33
     :END:

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]<[[ShiftExpression][ShiftExpression]]

   1. Let =lref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[ShiftExpression][ShiftExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Let =r= be the result of performing
      [[https://tc39.es/ecma262/#sec-abstract-relational-comparison][Abstract
      Relational Comparison]] =lval= < =rval=.
   6. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=r=).
   7. If =r= is undefined, return false. Otherwise, return =r=.

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]>[[ShiftExpression][ShiftExpression]]

   1. Let =lref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[ShiftExpression][ShiftExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Let =r= be the result of performing
      [[https://tc39.es/ecma262/#sec-abstract-relational-comparison][Abstract
      Relational Comparison]] =rval= < =lval= with =LeftFirst= equal to
      false.
   6. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=r=).
   7. If =r= is undefined, return false. Otherwise, return =r=.

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]<=[[ShiftExpression][ShiftExpression]]

   1. Let =lref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[ShiftExpression][ShiftExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Let =r= be the result of performing
      [[https://tc39.es/ecma262/#sec-abstract-relational-comparison][Abstract
      Relational Comparison]] =rval= < =lval= with =LeftFirst= equal to
      false.
   6. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=r=).
   7. If =r= is true or undefined, return false. Otherwise, return true.

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]>=[[ShiftExpression][ShiftExpression]]

   1. Let =lref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[ShiftExpression][ShiftExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Let =r= be the result of performing
      [[https://tc39.es/ecma262/#sec-abstract-relational-comparison][Abstract
      Relational Comparison]] =lval= < =rval=.
   6. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=r=).
   7. If =r= is true or undefined, return false. Otherwise, return true.

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]instanceof[[ShiftExpression][ShiftExpression]]

   1. Let =lref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[ShiftExpression][ShiftExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Return
      ? [[https://tc39.es/ecma262/#sec-instanceofoperator][InstanceofOperator]](=lval=,
      =rval=).

   [[RelationalExpression][RelationalExpression]]:[[RelationalExpression][RelationalExpression]]in[[ShiftExpression][ShiftExpression]]

   1. Let =lref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[ShiftExpression][ShiftExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. If
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rval=)
      is not Object, throw a TypeError exception.
   6. Return
      ? [[https://tc39.es/ecma262/#sec-hasproperty][HasProperty]](=rval=,
      [[https://tc39.es/ecma262/#sec-topropertykey][ToPropertyKey]](=lval=)).

**** Runtime Semantics: InstanceofOperator ( =V=, =target= )
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-instanceofoperator-v-target
     :END:

   The abstract operation InstanceofOperator(=V=, =target=) implements the
   generic algorithm for determining if ECMAScript value =V= is an instance
   of object =target= either by consulting =target='s @@hasinstance method
   or, if absent, determining whether the value of =target='s "prototype"
   property is present in =V='s prototype chain. This abstract operation
   performs the following steps:

   1. If
      [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=target=)
      is not Object, throw a TypeError exception.
   2. Let =instOfHandler= be
      ? [[https://tc39.es/ecma262/#sec-getmethod][GetMethod]](=target=,
      @@hasInstance).
   3. If =instOfHandler= is not undefined, then

      1. Return ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](?
         [[https://tc39.es/ecma262/#sec-call][Call]](=instOfHandler=,
         =target=, « =V= »)).

   4. If [[https://tc39.es/ecma262/#sec-iscallable][IsCallable]](=target=)
      is false, throw a TypeError exception.
   5. Return
      ? [[https://tc39.es/ecma262/#sec-ordinaryhasinstance][OrdinaryHasInstance]](=target=,
      =V=).

   Note

   Steps 4 and 5 provide compatibility with previous editions of ECMAScript
   that did not use a @@hasInstance method to define the =instanceof=
   operator semantics. If an object does not define or inherit
   @@hasInstance it uses the default =instanceof= semantics.

*** Equality Operators
    :PROPERTIES:
    :CUSTOM_ID: equality-operators
    :END:

  Note

  The result of evaluating an equality operator is always of type Boolean,
  reflecting whether the relationship named by the operator holds between
  its two operands.

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-31
     :END:

***** EqualityExpression  

   [[EqualityExpression][EqualityExpression]][In, Yield, Await]:
     [[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]
     [[EqualityExpression][EqualityExpression]][?In, ?Yield, ?Await]==[[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]
     [[EqualityExpression][EqualityExpression]][?In, ?Yield, ?Await]!=[[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]
     [[EqualityExpression][EqualityExpression]][?In, ?Yield, ?Await]===[[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]
     [[EqualityExpression][EqualityExpression]][?In, ?Yield, ?Await]!==[[RelationalExpression][RelationalExpression]][?In, ?Yield, ?Await]
    
     #+begin_src gerbil :noweb-ref equality-expression
       (defstruct (equality-expression operator) () transparent: #t)
       (def EqualityExpression
         (.or (Operator equality-expression RelationalExpression "==")
              (Operator equality-expression RelationalExpression "!=")
              (Operator equality-expression RelationalExpression "===")
              (Operator equality-expression RelationalExpression "!==")))

     #+end_src
   
**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-10
     :END:

   [[EqualityExpression][EqualityExpression]]:[[EqualityExpression][EqualityExpression]]==[[RelationalExpression][RelationalExpression]]
   [[EqualityExpression][EqualityExpression]]!=[[RelationalExpression][RelationalExpression]]
   [[EqualityExpression][EqualityExpression]]===[[RelationalExpression][RelationalExpression]]
   [[EqualityExpression][EqualityExpression]]!==[[RelationalExpression][RelationalExpression]]

   1. Return false.

   <<sec-equality-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-11
     :END:

   [[EqualityExpression][EqualityExpression]]:[[EqualityExpression][EqualityExpression]]==[[RelationalExpression][RelationalExpression]]
   [[EqualityExpression][EqualityExpression]]!=[[RelationalExpression][RelationalExpression]]
   [[EqualityExpression][EqualityExpression]]===[[RelationalExpression][RelationalExpression]]
   [[EqualityExpression][EqualityExpression]]!==[[RelationalExpression][RelationalExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-34
     :END:

   [[EqualityExpression][EqualityExpression]]:[[EqualityExpression][EqualityExpression]]==[[RelationalExpression][RelationalExpression]]

   1. Let =lref= be the result of evaluating
      [[EqualityExpression][EqualityExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Return the result of performing
      [[https://tc39.es/ecma262/#sec-abstract-equality-comparison][Abstract
      Equality Comparison]] =rval= == =lval=.

   [[EqualityExpression][EqualityExpression]]:[[EqualityExpression][EqualityExpression]]!=[[RelationalExpression][RelationalExpression]]

   1. Let =lref= be the result of evaluating
      [[EqualityExpression][EqualityExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Let =r= be the result of performing
      [[https://tc39.es/ecma262/#sec-abstract-equality-comparison][Abstract
      Equality Comparison]] =rval= == =lval=.
   6. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=r=).
   7. If =r= is true, return false. Otherwise, return true.

   [[EqualityExpression][EqualityExpression]]:[[EqualityExpression][EqualityExpression]]===[[RelationalExpression][RelationalExpression]]

   1. Let =lref= be the result of evaluating
      [[EqualityExpression][EqualityExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Return the result of performing
      [[https://tc39.es/ecma262/#sec-strict-equality-comparison][Strict
      Equality Comparison]] =rval= === =lval=.

   [[EqualityExpression][EqualityExpression]]:[[EqualityExpression][EqualityExpression]]!==[[RelationalExpression][RelationalExpression]]

   1. Let =lref= be the result of evaluating
      [[EqualityExpression][EqualityExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[RelationalExpression][RelationalExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Let =r= be the result of performing
      [[https://tc39.es/ecma262/#sec-strict-equality-comparison][Strict
      Equality Comparison]] =rval= === =lval=.
   6. [[https://tc39.es/ecma262/#assert][Assert]]: =r= is a normal
      completion.
   7. If =r=.[[Value]] is true, return false. Otherwise, return true.

   Note 1

   Given the above definition of equality:

   - String comparison can be forced by: =`${a}` == `${b}`=.
   - Numeric comparison can be forced by: =+a == +b=.
   - Boolean comparison can be forced by: =!a == !b=.

   Note 2

   The equality operators maintain the following invariants:

   - =A != B= is equivalent to =!(A == B)=.
   - =A == B= is equivalent to =B == A=, except in the order of evaluation
     of =A= and =B=.

   Note 3

   The equality operator is not always transitive. For example, there might
   be two distinct String objects, each representing the same String value;
   each String object would be considered equal to the String value by the
   ==== operator, but the two String objects would not be equal to each
   other. For example:

   - =new String("a") == "a"= and ="a" == new String("a")= are both true.
   - =new String("a") == new String("a")= is false.

   Note 4

   Comparison of Strings uses a simple equality test on sequences of code
   unit values. There is no attempt to use the more complex, semantically
   oriented definitions of character or string equality and collating order
   defined in the Unicode specification. Therefore Strings values that are
   canonically equal according to the Unicode standard could test as
   unequal. In effect this algorithm assumes that both Strings are already
   in normalized form.

*** Binary Bitwise Operators
    :PROPERTIES:
    :CUSTOM_ID: binary-bitwise-operators
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-32
     :END:

***** BitwiseANDExpression

   [[BitwiseANDExpression][BitwiseANDExpression]][In, Yield, Await]:
     [[EqualityExpression][EqualityExpression]][?In, ?Yield, ?Await]
   [[BitwiseANDExpression][BitwiseANDExpression]][?In, ?Yield, ?Await]&[[EqualityExpression][EqualityExpression]][?In, ?Yield, ?Await]

  
   #+begin_src gerbil :noweb-ref bitwise-expression
     (defstruct (bitwise-and-expression operator) () transparent: #t)
     (def BitwiseANDExpression
       (Operator bitwise-and-expression EqualityExpression #\&))
   #+end_src
***** BitwiseXORExpression

    [[BitwiseXORExpression][BitwiseXORExpression]][In, Yield, Await]:
      [[BitwiseANDExpression][BitwiseANDExpression]][?In, ?Yield, ?Await]
    [[BitwiseXORExpression][BitwiseXORExpression]][?In, ?Yield, ?Await]^[[BitwiseANDExpression][BitwiseANDExpression]][?In, ?Yield, ?Await]

   #+begin_src gerbil :noweb-ref bitwise-expression
     (defstruct (bitwise-xor-expression operator) () transparent: #t)
     (def BitwiseXORExpression
       (Operator bitwise-xor-expression BitwiseANDExpression #\^))
   #+end_src

***** BitwiseORExpression 


   [[BitwiseORExpression][BitwiseORExpression]][In, Yield, Await]: 
     [[BitwiseXORExpression][BitwiseXORExpression]][?In, ?Yield, ?Await]
   [[BitwiseORExpression][BitwiseORExpression]][?In, ?Yield, ?Await]|[[BitwiseXORExpression][BitwiseXORExpression]][?In, ?Yield, ?Await]

   #+begin_src gerbil :noweb-ref bitwise-expression
     (defstruct (bitwise-or-expression operator) () transparent: #t)
     (def BitwiseORExpression
       (Operator bitwise-or-expression BitwiseXORExpression #\|))

   #+end_src
**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-11
     :END:

   [[BitwiseANDExpression][BitwiseANDExpression]]:[[BitwiseANDExpression][BitwiseANDExpression]]&[[EqualityExpression][EqualityExpression]]
   [[BitwiseXORExpression][BitwiseXORExpression]]:[[BitwiseXORExpression][BitwiseXORExpression]]^[[BitwiseANDExpression][BitwiseANDExpression]]
   [[BitwiseORExpression][BitwiseORExpression]]:[[BitwiseORExpression][BitwiseORExpression]]|[[BitwiseXORExpression][BitwiseXORExpression]]

   1. Return false.

   <<sec-binary-bitwise-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-12
     :END:

   [[BitwiseANDExpression][BitwiseANDExpression]]:[[BitwiseANDExpression][BitwiseANDExpression]]&[[EqualityExpression][EqualityExpression]]
   [[BitwiseXORExpression][BitwiseXORExpression]]:[[BitwiseXORExpression][BitwiseXORExpression]]^[[BitwiseANDExpression][BitwiseANDExpression]]
   [[BitwiseORExpression][BitwiseORExpression]]:[[BitwiseORExpression][BitwiseORExpression]]|[[BitwiseXORExpression][BitwiseXORExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-35
     :END:

   The production
   [[A][A]]:[[A][A]]@B
   , where @ is one of the bitwise operators in the productions above, is
   evaluated as follows:

   1.  Let =lref= be the result of evaluating =A=.
   2.  Let =lval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3.  Let =rref= be the result of evaluating =B=.
   4.  Let =rval= be
       ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5.  Let =lnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=lval=).
   6.  Let =rnum= be
       ? [[https://tc39.es/ecma262/#sec-tonumeric][ToNumeric]](=rval=).
   7.  If
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=)
       is different from
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=rnum=),
       throw a TypeError exception.
   8.  Let =T= be
       [[https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values][Type]](=lnum=).
   9.  If @ is =&=, return =T=::bitwiseAND(=lnum=, =rnum=).
   10. If @ is =|=, return =T=::bitwiseOR(=lnum=, =rnum=).
   11. Else,

       1. [[https://tc39.es/ecma262/#assert][Assert]]: @ is =^=.
       2. Return =T=::bitwiseXOR(=lnum=, =rnum=).

*** Binary Logical Operators
    :PROPERTIES:
    :CUSTOM_ID: binary-logical-operators
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-33
     :END:

***** LogicalANDExpression 

   [[LogicalANDExpression][LogicalANDExpression]][In, Yield, Await]:
      [[BitwiseORExpression][BitwiseORExpression]][?In, ?Yield, ?Await]
   [[LogicalANDExpression][LogicalANDExpression]][?In, ?Yield, ?Await]&&[[BitwiseORExpression][BitwiseORExpression]][?In, ?Yield, ?Await]

   #+begin_src gerbil :noweb-ref logical-and-expression
     (defstruct (logical-and-expression operator) () transparent: #t)
     (def LogicalANDExpression
       (Operator logical-and-expression BitwiseORExpression "&&"))
   #+end_src
***** LogicalORExpression

   [[LogicalORExpression][LogicalORExpression]][In, Yield, Await]: 
     [[LogicalANDExpression][LogicalANDExpression]][?In, ?Yield, ?Await]
   [[LogicalORExpression][LogicalORExpression]][?In, ?Yield, ?Await]||[[LogicalANDExpression][LogicalANDExpression]][?In, ?Yield, ?Await] Note

   The value produced by a =&&= or =||= operator is not necessarily of type
   Boolean. The value produced will always be the value of one of the two
   operand expressions.

   #+begin_src gerbil :noweb-ref logical-or-expression
     (defstruct (logical-or-expression operator) () transparent: #t)
     (def LogicalORExpression
       (Operator logical-or-expression LogicalANDExpression "||"))
   #+end_src

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-12
     :END:

   [[LogicalANDExpression][LogicalANDExpression]]:[[LogicalANDExpression][LogicalANDExpression]]&&[[BitwiseORExpression][BitwiseORExpression]]
   [[LogicalORExpression][LogicalORExpression]]:[[LogicalORExpression][LogicalORExpression]]||[[LogicalANDExpression][LogicalANDExpression]]

   1. Return false.

   <<sec-binary-logical-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-13
     :END:

   [[LogicalANDExpression][LogicalANDExpression]]:[[LogicalANDExpression][LogicalANDExpression]]&&[[BitwiseORExpression][BitwiseORExpression]]
   [[LogicalORExpression][LogicalORExpression]]:[[LogicalORExpression][LogicalORExpression]]||[[LogicalANDExpression][LogicalANDExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-36
     :END:

   [[LogicalANDExpression][LogicalANDExpression]]:[[LogicalANDExpression][LogicalANDExpression]]&&[[BitwiseORExpression][BitwiseORExpression]]

   1. Let =lref= be the result of evaluating
      [[LogicalANDExpression][LogicalANDExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =lbool= be
      ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](=lval=).
   4. If =lbool= is false, return =lval=.
   5. Let =rref= be the result of evaluating
      [[BitwiseORExpression][BitwiseORExpression]].
   6. Return ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).

   [[LogicalORExpression][LogicalORExpression]]:[[LogicalORExpression][LogicalORExpression]]||[[LogicalANDExpression][LogicalANDExpression]]

   1. Let =lref= be the result of evaluating
      [[LogicalORExpression][LogicalORExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =lbool= be
      ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](=lval=).
   4. If =lbool= is true, return =lval=.
   5. Let =rref= be the result of evaluating
      [[LogicalANDExpression][LogicalANDExpression]].
   6. Return ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).

*** Conditional Operator ( =? := )
    :PROPERTIES:
    :CUSTOM_ID: conditional-operator
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-34
     :END:

***** ConditionalExpression


   [[ConditionalExpression][ConditionalExpression]][In, Yield, Await]:
     [[LogicalORExpression][LogicalORExpression]][?In, ?Yield, ?Await]
   [[LogicalORExpression][LogicalORExpression]][?In, ?Yield, ?Await]?[[AssignmentExpression][AssignmentExpression]][+In, ?Yield, ?Await]:[[AssignmentExpression][AssignmentExpression]][?In,
   ?Yield, ?Await] Note

   #+begin_src gerbil :noweb-ref conditional-expression
     (def ConditionalExpression (.begin #t LogicalORExpression))
   #+end_src

   The grammar for a
   [[ConditionalExpression][ConditionalExpression]]
   in ECMAScript is slightly different from that in C and Java, which each
   allow the second subexpression to be an
   [[Expression][Expression]] but restrict
   the third expression to be a
   [[ConditionalExpression][ConditionalExpression]].
   The motivation for this difference in ECMAScript is to allow an
   assignment expression to be governed by either arm of a conditional and
   to eliminate the confusing and fairly useless case of a comma expression
   as the centre expression.

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-13
     :END:

   [[ConditionalExpression][ConditionalExpression]]:[[LogicalORExpression][LogicalORExpression]]?[[AssignmentExpression][AssignmentExpression]]:[[AssignmentExpression][AssignmentExpression]]

   1. Return false.

   <<sec-conditional-operator-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-14
     :END:

   [[ConditionalExpression][ConditionalExpression]]:[[LogicalORExpression][LogicalORExpression]]?[[AssignmentExpression][AssignmentExpression]]:[[AssignmentExpression][AssignmentExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-37
     :END:

   [[ConditionalExpression][ConditionalExpression]]:[[LogicalORExpression][LogicalORExpression]]?[[AssignmentExpression][AssignmentExpression]]:[[AssignmentExpression][AssignmentExpression]]

   1. Let =lref= be the result of evaluating
      [[LogicalORExpression][LogicalORExpression]].
   2. Let =lval= be
      ! [[https://tc39.es/ecma262/#sec-toboolean][ToBoolean]](?
      [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=)).
   3. If =lval= is true, then

      1. Let =trueRef= be the result of evaluating the first
         [[AssignmentExpression][AssignmentExpression]].
      2. Return
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=trueRef=).

   4. Else,

      1. Let =falseRef= be the result of evaluating the second
         [[AssignmentExpression][AssignmentExpression]].
      2. Return
         ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=falseRef=).

*** Assignment Operators
    :PROPERTIES:
    :CUSTOM_ID: assignment-operators
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-35
     :END:
    
******  AssignmentExpression

     #+begin_quote
    [[AssignmentExpression][AssignmentExpression]][In, Yield, Await]:
    [[ConditionalExpression][ConditionalExpression]][?In, ?Yield, ?Await]
    [+Yield][[YieldExpression][YieldExpression]][?In, ?Await]
    [[ArrowFunction][ArrowFunction]][?In, ?Yield, ?Await]
    [[AsyncArrowFunction][AsyncArrowFunction]][?In, ?Yield, ?Await]
    [[LeftHandSideExpression][LeftHandSideExpression]][?Yield, ?Await]=[[AssignmentExpression][AssignmentExpression]][?In, ?Yield, ?Await]
    [[LeftHandSideExpression][LeftHandSideExpression]][?Yield, ?Await][[AssignmentOperator][AssignmentOperator]][[AssignmentExpression][AssignmentExpression]][?In, ?Yield, ?Await]
       #+end_quote

       #+begin_src gerbil :noweb-ref assignment-expression 
         ;;; This is a very important parser, as, believe it or not, an
         ;;; AssigmentExpression is also what ends up leading to being able to parse a
         ;;; literal.

         ;;; ie: Assignment -> Conditional -> LogicalOr -> LogicalAnd ->
         ;;;  Bitwise(Or -> Xor -> And) -> Equality -> Relational -> Shift -> Add -> Mult
         ;;;  -> Exponential -> Unary -> Update -> LHS -> New -> Member -> Primary ->
         ;;;  Literal -> Numeric

         ;;; Holy fscknts.
         (defstruct (assignment-expression operator) () transparent: #t)
         (def AssignmentExpression
           (.begin
             #t ConditionalExpression))
       #+end_src

    [[AssignmentOperator][AssignmentOperator]]:one
    of*=/=%=+=-=<<=>>=>>>=&=^=|=**=
**** Static Semantics: Early Errors
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-early-errors-9
     :END:

   [[AssignmentExpression][AssignmentExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]=[[AssignmentExpression][AssignmentExpression]]

   - It is a Syntax Error if
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is either an
     [[ObjectLiteral][ObjectLiteral]] or an
     [[ArrayLiteral][ArrayLiteral]] and
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is not [[https://tc39.es/ecma262/#sec-syntactic-grammar][covering]] an
     [[AssignmentPattern][AssignmentPattern]].
   - It is an early Syntax Error if
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is neither an
     [[ObjectLiteral][ObjectLiteral]] nor an
     [[ArrayLiteral][ArrayLiteral]] and
     AssignmentTargetType of
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is not simple.

   [[AssignmentExpression][AssignmentExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]][[AssignmentOperator][AssignmentOperator]][[AssignmentExpression][AssignmentExpression]]

   - It is an early Syntax Error if AssignmentTargetType of
     [[LeftHandSideExpression][LeftHandSideExpression]]
     is not simple.

**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-14
     :END:

   [[AssignmentExpression][AssignmentExpression]]:[[ArrowFunction][ArrowFunction]]
   [[AsyncArrowFunction][AsyncArrowFunction]]

   1. Return true.

   [[AssignmentExpression][AssignmentExpression]]:[[YieldExpression][YieldExpression]]
   [[LeftHandSideExpression][LeftHandSideExpression]]=[[AssignmentExpression][AssignmentExpression]]
   [[LeftHandSideExpression][LeftHandSideExpression]][[AssignmentOperator][AssignmentOperator]][[AssignmentExpression][AssignmentExpression]]

   1. Return false.

   <<sec-assignment-operators-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-15
     :END:

   [[AssignmentExpression][AssignmentExpression]]:[[YieldExpression][YieldExpression]]
   [[ArrowFunction][ArrowFunction]]
   [[AsyncArrowFunction][AsyncArrowFunction]]
   [[LeftHandSideExpression][LeftHandSideExpression]]=[[AssignmentExpression][AssignmentExpression]]
   [[LeftHandSideExpression][LeftHandSideExpression]][[AssignmentOperator][AssignmentOperator]][[AssignmentExpression][AssignmentExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-38
     :END:

   [[AssignmentExpression][AssignmentExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]=[[AssignmentExpression][AssignmentExpression]]

   1. If
      [[LeftHandSideExpression][LeftHandSideExpression]]
      is neither an
      [[ObjectLiteral][ObjectLiteral]] nor an
      [[ArrayLiteral][ArrayLiteral]], then

      1. Let =lref= be the result of evaluating
         [[LeftHandSideExpression][LeftHandSideExpression]].
      2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=lref=).
      3. If
         [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[AssignmentExpression][AssignmentExpression]])
         and IsIdentifierRef of
         [[LeftHandSideExpression][LeftHandSideExpression]]
         are both true, then

         1. Let =rval= be NamedEvaluation of
            [[AssignmentExpression][AssignmentExpression]]
            with argument
            [[https://tc39.es/ecma262/#sec-getreferencedname][GetReferencedName]](=lref=).

      4. Else,

         1. Let =rref= be the result of evaluating
            [[AssignmentExpression][AssignmentExpression]].
         2. Let =rval= be
            ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).

      5. Perform
         ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lref=,
         =rval=).
      6. Return =rval=.

   2. Let =assignmentPattern= be the
      [[AssignmentPattern][AssignmentPattern]]
      that is [[https://tc39.es/ecma262/#sec-syntactic-grammar][covered]]
      by
      [[LeftHandSideExpression][LeftHandSideExpression]].
   3. Let =rref= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Perform ? DestructuringAssignmentEvaluation of =assignmentPattern=
      using =rval= as the argument.
   6. Return =rval=.

   [[AssignmentExpression][AssignmentExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]][[AssignmentOperator][AssignmentOperator]][[AssignmentExpression][AssignmentExpression]]

   1. Let =lref= be the result of evaluating
      [[LeftHandSideExpression][LeftHandSideExpression]].
   2. Let =lval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   4. Let =rval= be
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).
   5. Let =op= be the =@= where
      [[AssignmentOperator][AssignmentOperator]]
      is =@==.
   6. Let =r= be the result of applying =op= to =lval= and =rval= as if
      evaluating the expression =lval= =op= =rval=.
   7. Perform ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lref=,
      =r=).
   8. Return =r=.

   Note

   When an assignment occurs within
   [[https://tc39.es/ecma262/#sec-strict-mode-code][strict mode code]], it
   is a runtime error if =lref= in step 1.f of the first algorithm or step
   7 of the second algorithm it is an unresolvable reference. If it is, a
   ReferenceError exception is thrown. The
   [[LeftHandSideExpression][LeftHandSideExpression]]
   also may not be a reference to a
   [[https://tc39.es/ecma262/#sec-object-type][data property]] with the
   attribute value { [[Writable]]: false }, to an
   [[https://tc39.es/ecma262/#sec-object-type][accessor property]] with the
   attribute value { [[Set]]: undefined }, nor to a non-existent property
   of an object for which the
   [[https://tc39.es/ecma262/#sec-isextensible-o][IsExtensible]] predicate
   returns the value false. In these cases a TypeError exception is thrown.

**** Destructuring Assignment
     :PROPERTIES:
     :CUSTOM_ID: destructuring-assignment
     :END:

***** Supplemental Syntax
      :PROPERTIES:
      :CUSTOM_ID: supplemental-syntax-2
      :END:

   In certain circumstances when processing an instance of the production
   [[AssignmentExpression][AssignmentExpression]]:[[LeftHandSideExpression][LeftHandSideExpression]]=[[AssignmentExpression][AssignmentExpression]]
   the following grammar is used to refine the interpretation of
   [[LeftHandSideExpression][LeftHandSideExpression]].

   [[AssignmentPattern][AssignmentPattern]][Yield,
   Await]:[[ObjectAssignmentPattern][ObjectAssignmentPattern]][?Yield,
   ?Await]
   [[ArrayAssignmentPattern][ArrayAssignmentPattern]][?Yield,
   ?Await]
   [[ObjectAssignmentPattern][ObjectAssignmentPattern]][Yield,
   Await]:{}
   {[[AssignmentRestProperty][AssignmentRestProperty]][?Yield,
   ?Await]}
   {[[AssignmentPropertyList][AssignmentPropertyList]][?Yield,
   ?Await]}
   {[[AssignmentPropertyList][AssignmentPropertyList]][?Yield,
   ?Await],[[AssignmentRestProperty][AssignmentRestProperty]][?Yield,
   ?Await]opt}
   [[ArrayAssignmentPattern][ArrayAssignmentPattern]][Yield,
   Await]:[[[Elision][Elision]]opt[[AssignmentRestElement][AssignmentRestElement]][?Yield,
   ?Await]opt]
   [[[AssignmentElementList][AssignmentElementList]][?Yield,
   ?Await]]
   [[[AssignmentElementList][AssignmentElementList]][?Yield,
   ?Await],[[Elision][Elision]]opt[[AssignmentRestElement][AssignmentRestElement]][?Yield,
   ?Await]opt]
   [[AssignmentRestProperty][AssignmentRestProperty]][Yield,
   Await]:...[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]][?Yield,
   ?Await]
   [[AssignmentPropertyList][AssignmentPropertyList]][Yield,
   Await]:[[AssignmentProperty][AssignmentProperty]][?Yield,
   ?Await]
   [[AssignmentPropertyList][AssignmentPropertyList]][?Yield,
   ?Await],[[AssignmentProperty][AssignmentProperty]][?Yield,
   ?Await]
   [[AssignmentElementList][AssignmentElementList]][Yield,
   Await]:[[AssignmentElisionElement][AssignmentElisionElement]][?Yield,
   ?Await]
   [[AssignmentElementList][AssignmentElementList]][?Yield,
   ?Await],[[AssignmentElisionElement][AssignmentElisionElement]][?Yield,
   ?Await]
   [[AssignmentElisionElement][AssignmentElisionElement]][Yield,
   Await]:[[Elision][Elision]]opt[[AssignmentElement][AssignmentElement]][?Yield,
   ?Await]
   [[AssignmentProperty][AssignmentProperty]][Yield,
   Await]:[[IdentifierReference][IdentifierReference]][?Yield,
   ?Await][[Initializer][Initializer]][+In,
   ?Yield, ?Await]opt
   [[PropertyName][PropertyName]][?Yield,
   ?Await]:[[AssignmentElement][AssignmentElement]][?Yield,
   ?Await]
   [[AssignmentElement][AssignmentElement]][Yield,
   Await]:[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]][?Yield,
   ?Await][[Initializer][Initializer]][+In,
   ?Yield, ?Await]opt
   [[AssignmentRestElement][AssignmentRestElement]][Yield,
   Await]:...[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]][?Yield,
   ?Await]
   [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]][Yield,
   Await]:[[LeftHandSideExpression][LeftHandSideExpression]][?Yield,
   ?Await]
***** Static Semantics: Early Errors
      :PROPERTIES:
      :CUSTOM_ID: static-semantics-early-errors-10
      :END:

    [[AssignmentProperty][AssignmentProperty]]:[[IdentifierReference][IdentifierReference]][[Initializer][Initializer]]opt

    - It is a Syntax Error if AssignmentTargetType of
      [[IdentifierReference][IdentifierReference]]
      is not simple.

    [[AssignmentRestProperty][AssignmentRestProperty]]:...[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]

    - It is a Syntax Error if
      [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
      is an [[ArrayLiteral][ArrayLiteral]] or
      an [[ObjectLiteral][ObjectLiteral]].

    [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]:[[LeftHandSideExpression][LeftHandSideExpression]]

    - It is a Syntax Error if
      [[LeftHandSideExpression][LeftHandSideExpression]]
      is either an
      [[ObjectLiteral][ObjectLiteral]] or an
      [[ArrayLiteral][ArrayLiteral]] and if
      [[LeftHandSideExpression][LeftHandSideExpression]]
      is not [[https://tc39.es/ecma262/#sec-syntactic-grammar][covering]] an
      [[AssignmentPattern][AssignmentPattern]].
    - It is a Syntax Error if
      [[LeftHandSideExpression][LeftHandSideExpression]]
      is neither an
      [[ObjectLiteral][ObjectLiteral]] nor an
      [[ArrayLiteral][ArrayLiteral]] and
      AssignmentTargetType of
      [[LeftHandSideExpression][LeftHandSideExpression]]
      is not simple.

***** Runtime Semantics: DestructuringAssignmentEvaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-destructuringassignmentevaluation
      :END:

    With parameter =value=.

    [[ObjectAssignmentPattern][ObjectAssignmentPattern]]:{}

    1. Perform
       ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=value=).
    2. Return
       [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

    [[ObjectAssignmentPattern][ObjectAssignmentPattern]]:{[[AssignmentPropertyList][AssignmentPropertyList]]}
    {[[AssignmentPropertyList][AssignmentPropertyList]],}

    1. Perform
       ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=value=).
    2. Perform ? PropertyDestructuringAssignmentEvaluation for
       [[AssignmentPropertyList][AssignmentPropertyList]]
       using =value= as the argument.
    3. Return
       [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

    [[ArrayAssignmentPattern][ArrayAssignmentPattern]]:[]

    1. Let =iteratorRecord= be
       ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=value=).
    2. Return
       ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
       [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty)).

    [[ArrayAssignmentPattern][ArrayAssignmentPattern]]:[[[Elision][Elision]]]

    1. Let =iteratorRecord= be
       ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=value=).
    2. Let =result= be IteratorDestructuringAssignmentEvaluation of
       [[Elision][Elision]] with argument
       =iteratorRecord=.
    3. If =iteratorRecord=.[[Done]] is false, return
       ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
       =result=).
    4. Return =result=.

    [[ArrayAssignmentPattern][ArrayAssignmentPattern]]:[[[Elision][Elision]]opt[[AssignmentRestElement][AssignmentRestElement]]]

    1. Let =iteratorRecord= be
       ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=value=).
    2. If [[Elision][Elision]] is present,
       then

       1. Let =status= be IteratorDestructuringAssignmentEvaluation of
          [[Elision][Elision]] with argument
          =iteratorRecord=.
       2. If =status= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], then

          1. [[https://tc39.es/ecma262/#assert][Assert]]:
             =iteratorRecord=.[[Done]] is true.
          2. Return
             [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=status=).

    3. Let =result= be IteratorDestructuringAssignmentEvaluation of
       [[AssignmentRestElement][AssignmentRestElement]]
       with argument =iteratorRecord=.
    4. If =iteratorRecord=.[[Done]] is false, return
       ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
       =result=).
    5. Return =result=.

    [[ArrayAssignmentPattern][ArrayAssignmentPattern]]:[[[AssignmentElementList][AssignmentElementList]]]

    1. Let =iteratorRecord= be
       ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=value=).
    2. Let =result= be IteratorDestructuringAssignmentEvaluation of
       [[AssignmentElementList][AssignmentElementList]]
       with argument =iteratorRecord=.
    3. If =iteratorRecord=.[[Done]] is false, return
       ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
       =result=).
    4. Return =result=.

    [[ArrayAssignmentPattern][ArrayAssignmentPattern]]:[[[AssignmentElementList][AssignmentElementList]],[[Elision][Elision]]opt[[AssignmentRestElement][AssignmentRestElement]]opt]

    1. Let =iteratorRecord= be
       ? [[https://tc39.es/ecma262/#sec-getiterator][GetIterator]](=value=).
    2. Let =status= be IteratorDestructuringAssignmentEvaluation of
       [[AssignmentElementList][AssignmentElementList]]
       with argument =iteratorRecord=.
    3. If =status= is an
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
       completion]], then

       1. If =iteratorRecord=.[[Done]] is false, return
          ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
          =status=).
       2. Return
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=status=).

    4. If [[Elision][Elision]] is present,
       then

       1. Set =status= to the result of performing
          IteratorDestructuringAssignmentEvaluation of
          [[Elision][Elision]] with
          =iteratorRecord= as the argument.
       2. If =status= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], then

          1. [[https://tc39.es/ecma262/#assert][Assert]]:
             =iteratorRecord=.[[Done]] is true.
          2. Return
             [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=status=).

    5. If
       [[AssignmentRestElement][AssignmentRestElement]]
       is present, then

       1. Set =status= to the result of performing
          IteratorDestructuringAssignmentEvaluation of
          [[AssignmentRestElement][AssignmentRestElement]]
          with =iteratorRecord= as the argument.

    6. If =iteratorRecord=.[[Done]] is false, return
       ? [[https://tc39.es/ecma262/#sec-iteratorclose][IteratorClose]](=iteratorRecord=,
       =status=).
    7. Return
       [[https://tc39.es/ecma262/#sec-completion-record-specification-type][Completion]](=status=).

    [[ObjectAssignmentPattern][ObjectAssignmentPattern]]:{[[AssignmentRestProperty][AssignmentRestProperty]]}

    1. Perform
       ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=value=).
    2. Let =excludedNames= be a new empty
       [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]].
    3. Return the result of performing RestDestructuringAssignmentEvaluation
       of
       [[AssignmentRestProperty][AssignmentRestProperty]]
       with =value= and =excludedNames= as the arguments.

    [[ObjectAssignmentPattern][ObjectAssignmentPattern]]:{[[AssignmentPropertyList][AssignmentPropertyList]],[[AssignmentRestProperty][AssignmentRestProperty]]}

    1. Perform
       ? [[https://tc39.es/ecma262/#sec-requireobjectcoercible][RequireObjectCoercible]](=value=).
    2. Let =excludedNames= be ? PropertyDestructuringAssignmentEvaluation of
       [[AssignmentPropertyList][AssignmentPropertyList]]
       with argument =value=.
    3. Return the result of performing RestDestructuringAssignmentEvaluation
       of
       [[AssignmentRestProperty][AssignmentRestProperty]]
       with arguments =value= and =excludedNames=.

***** Runtime Semantics: PropertyDestructuringAssignmentEvaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-propertydestructuringassignmentevaluation
      :END:

    With parameter =value=.

    Note

    The following operations collect a list of all destructured property
    names.

    [[AssignmentPropertyList][AssignmentPropertyList]]:[[AssignmentPropertyList][AssignmentPropertyList]],[[AssignmentProperty][AssignmentProperty]]

    1. Let =propertyNames= be ? PropertyDestructuringAssignmentEvaluation of
       [[AssignmentPropertyList][AssignmentPropertyList]]
       with argument =value=.
    2. Let =nextNames= be ? PropertyDestructuringAssignmentEvaluation of
       [[AssignmentProperty][AssignmentProperty]]
       with argument =value=.
    3. Append each item in =nextNames= to the end of =propertyNames=.
    4. Return =propertyNames=.

    [[AssignmentProperty][AssignmentProperty]]:[[IdentifierReference][IdentifierReference]][[Initializer][Initializer]]opt

    1. Let =P= be StringValue of
       [[IdentifierReference][IdentifierReference]].
    2. Let =lref= be
       ? [[https://tc39.es/ecma262/#sec-resolvebinding][ResolveBinding]](=P=).
    3. Let =v= be ? [[https://tc39.es/ecma262/#sec-getv][GetV]](=value=,
       =P=).
    4. If [[Initializer][Initializer]]opt is
       present and =v= is undefined, then

       1. If
          [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Initializer][Initializer]])
          is true, then

          1. Set =v= to the result of performing NamedEvaluation for
             [[Initializer][Initializer]] with
             argument =P=.

       2. Else,

          1. Let =defaultValue= be the result of evaluating
             [[Initializer][Initializer]].
          2. Set =v= to
             ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=defaultValue=).

    5. Perform ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lref=,
       =v=).
    6. Return a new
       [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
       containing =P=.

    [[AssignmentProperty][AssignmentProperty]]:[[PropertyName][PropertyName]]:[[AssignmentElement][AssignmentElement]]

    1. Let =name= be the result of evaluating
       [[PropertyName][PropertyName]].
    2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=name=).
    3. Perform ? KeyedDestructuringAssignmentEvaluation of
       [[AssignmentElement][AssignmentElement]]
       with =value= and =name= as the arguments.
    4. Return a new
       [[https://tc39.es/ecma262/#sec-list-and-record-specification-type][List]]
       containing =name=.

***** Runtime Semantics: RestDestructuringAssignmentEvaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-restdestructuringassignmentevaluation
      :END:

    With parameters =value= and =excludedNames=.

    [[AssignmentRestProperty][AssignmentRestProperty]]:...[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]

    1. Let =lref= be the result of evaluating
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]].
    2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=lref=).
    3. Let =restObj= be
       [[https://tc39.es/ecma262/#sec-objectcreate][ObjectCreate]](%Object.prototype%).
    4. Perform
       ? [[https://tc39.es/ecma262/#sec-copydataproperties][CopyDataProperties]](=restObj=,
       =value=, =excludedNames=).
    5. Return [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lref=,
       =restObj=).

***** Runtime Semantics: IteratorDestructuringAssignmentEvaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-iteratordestructuringassignmentevaluation
      :END:

    With parameter =iteratorRecord=.

    [[AssignmentElementList][AssignmentElementList]]:[[AssignmentElisionElement][AssignmentElisionElement]]

    1. Return the result of performing
       IteratorDestructuringAssignmentEvaluation of
       [[AssignmentElisionElement][AssignmentElisionElement]]
       using =iteratorRecord= as the argument.

    [[AssignmentElementList][AssignmentElementList]]:[[AssignmentElementList][AssignmentElementList]],[[AssignmentElisionElement][AssignmentElisionElement]]

    1. Perform ? IteratorDestructuringAssignmentEvaluation of
       [[AssignmentElementList][AssignmentElementList]]
       using =iteratorRecord= as the argument.
    2. Return the result of performing
       IteratorDestructuringAssignmentEvaluation of
       [[AssignmentElisionElement][AssignmentElisionElement]]
       using =iteratorRecord= as the argument.

    [[AssignmentElisionElement][AssignmentElisionElement]]:[[AssignmentElement][AssignmentElement]]

    1. Return the result of performing
       IteratorDestructuringAssignmentEvaluation of
       [[AssignmentElement][AssignmentElement]]
       with =iteratorRecord= as the argument.

    [[AssignmentElisionElement][AssignmentElisionElement]]:[[Elision][Elision]][[AssignmentElement][AssignmentElement]]

    1. Perform ? IteratorDestructuringAssignmentEvaluation of
       [[Elision][Elision]] with
       =iteratorRecord= as the argument.
    2. Return the result of performing
       IteratorDestructuringAssignmentEvaluation of
       [[AssignmentElement][AssignmentElement]]
       with =iteratorRecord= as the argument.

    [[Elision][Elision]]:,

    1. If =iteratorRecord=.[[Done]] is false, then

       1. Let =next= be
          [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
       2. If =next= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], set =iteratorRecord=.[[Done]] to true.
       3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
       4. If =next= is false, set =iteratorRecord=.[[Done]] to true.

    2. Return
       [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

    [[Elision][Elision]]:[[Elision][Elision]],

    1. Perform ? IteratorDestructuringAssignmentEvaluation of
       [[Elision][Elision]] with
       =iteratorRecord= as the argument.
    2. If =iteratorRecord=.[[Done]] is false, then

       1. Let =next= be
          [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
       2. If =next= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], set =iteratorRecord=.[[Done]] to true.
       3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
       4. If =next= is false, set =iteratorRecord=.[[Done]] to true.

    3. Return
       [[https://tc39.es/ecma262/#sec-normalcompletion][NormalCompletion]](empty).

    [[AssignmentElement][AssignmentElement]]:[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]][[Initializer][Initializer]]opt

    1. If
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
       is neither an
       [[ObjectLiteral][ObjectLiteral]] nor an
       [[ArrayLiteral][ArrayLiteral]], then

       1. Let =lref= be the result of evaluating
          [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]].
       2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=lref=).

    2. If =iteratorRecord=.[[Done]] is false, then

       1. Let =next= be
          [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
       2. If =next= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], set =iteratorRecord=.[[Done]] to true.
       3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
       4. If =next= is false, set =iteratorRecord=.[[Done]] to true.
       5. Else,

          1. Let =value= be
             [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
          2. If =value= is an
             [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
             completion]], set =iteratorRecord=.[[Done]] to true.
          3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=value=).

    3. If =iteratorRecord=.[[Done]] is true, let =value= be undefined.
    4. If [[Initializer][Initializer]] is
       present and =value= is undefined, then

       1. If
          [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Initializer][Initializer]])
          and IsIdentifierRef of
          [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
          are both true, then

          1. Let =v= be NamedEvaluation of
             [[Initializer][Initializer]] with
             argument
             [[https://tc39.es/ecma262/#sec-getreferencedname][GetReferencedName]](=lref=).

       2. Else,

          1. Let =defaultValue= be the result of evaluating
             [[Initializer][Initializer]].
          2. Let =v= be
             ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=defaultValue=).

    5. Else, let =v= be =value=.
    6. If
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
       is an [[ObjectLiteral][ObjectLiteral]]
       or an [[ArrayLiteral][ArrayLiteral]],
       then

       1. Let =nestedAssignmentPattern= be the
          [[AssignmentPattern][AssignmentPattern]]
          that is
          [[https://tc39.es/ecma262/#sec-syntactic-grammar][covered]] by
          [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]].
       2. Return the result of performing DestructuringAssignmentEvaluation
          of =nestedAssignmentPattern= with =v= as the argument.

    7. Return ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lref=,
       =v=).

    Note

    Left to right evaluation order is maintained by evaluating a
    [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
    that is not a destructuring pattern prior to accessing the iterator or
    evaluating the
    [[Initializer][Initializer]].

    [[AssignmentRestElement][AssignmentRestElement]]:...[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]

    1. If
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
       is neither an
       [[ObjectLiteral][ObjectLiteral]] nor an
       [[ArrayLiteral][ArrayLiteral]], then

       1. Let =lref= be the result of evaluating
          [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]].
       2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=lref=).

    2. Let =A= be
       ! [[https://tc39.es/ecma262/#sec-arraycreate][ArrayCreate]](0).
    3. Let =n= be 0.
    4. Repeat, while =iteratorRecord=.[[Done]] is false,

       1. Let =next= be
          [[https://tc39.es/ecma262/#sec-iteratorstep][IteratorStep]](=iteratorRecord=).
       2. If =next= is an
          [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
          completion]], set =iteratorRecord=.[[Done]] to true.
       3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=next=).
       4. If =next= is false, set =iteratorRecord=.[[Done]] to true.
       5. Else,

          1. Let =nextValue= be
             [[https://tc39.es/ecma262/#sec-iteratorvalue][IteratorValue]](=next=).
          2. If =nextValue= is an
             [[https://tc39.es/ecma262/#sec-completion-record-specification-type][abrupt
             completion]], set =iteratorRecord=.[[Done]] to true.
          3. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=nextValue=).
          4. Perform
             ! [[https://tc39.es/ecma262/#sec-createdatapropertyorthrow][CreateDataPropertyOrThrow]](=A=,
             ! [[https://tc39.es/ecma262/#sec-tostring][ToString]](=n=),
             =nextValue=).
          5. Set =n= to =n= + 1.

    5. If
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
       is neither an
       [[ObjectLiteral][ObjectLiteral]] nor an
       [[ArrayLiteral][ArrayLiteral]], then

       1. Return
          ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lref=,
          =A=).

    6. Let =nestedAssignmentPattern= be the
       [[AssignmentPattern][AssignmentPattern]]
       that is [[https://tc39.es/ecma262/#sec-syntactic-grammar][covered]]
       by
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]].
    7. Return the result of performing DestructuringAssignmentEvaluation of
       =nestedAssignmentPattern= with =A= as the argument.

***** Runtime Semantics: KeyedDestructuringAssignmentEvaluation
      :PROPERTIES:
      :CUSTOM_ID: runtime-semantics-keyeddestructuringassignmentevaluation
      :END:

    With parameters =value= and =propertyName=.

    [[AssignmentElement][AssignmentElement]]:[[DestructuringAssignmentTarget][DestructuringAssignmentTarget]][[Initializer][Initializer]]opt

    1. If
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
       is neither an
       [[ObjectLiteral][ObjectLiteral]] nor an
       [[ArrayLiteral][ArrayLiteral]], then

       1. Let =lref= be the result of evaluating
          [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]].
       2. [[https://tc39.es/ecma262/#sec-returnifabrupt][ReturnIfAbrupt]](=lref=).

    2. Let =v= be ? [[https://tc39.es/ecma262/#sec-getv][GetV]](=value=,
       =propertyName=).
    3. If [[Initializer][Initializer]] is
       present and =v= is undefined, then

       1. If
          [[https://tc39.es/ecma262/#sec-isanonymousfunctiondefinition][IsAnonymousFunctionDefinition]]([[Initializer][Initializer]])
          and IsIdentifierRef of
          [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
          are both true, then

          1. Let =rhsValue= be NamedEvaluation of
             [[Initializer][Initializer]] with
             argument
             [[https://tc39.es/ecma262/#sec-getreferencedname][GetReferencedName]](=lref=).

       2. Else,

          1. Let =defaultValue= be the result of evaluating
             [[Initializer][Initializer]].
          2. Let =rhsValue= be
             ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=defaultValue=).

    4. Else, let =rhsValue= be =v=.
    5. If
       [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]]
       is an [[ObjectLiteral][ObjectLiteral]]
       or an [[ArrayLiteral][ArrayLiteral]],
       then

       1. Let =assignmentPattern= be the
          [[AssignmentPattern][AssignmentPattern]]
          that is
          [[https://tc39.es/ecma262/#sec-syntactic-grammar][covered]] by
          [[DestructuringAssignmentTarget][DestructuringAssignmentTarget]].
       2. Return the result of performing DestructuringAssignmentEvaluation
          of =assignmentPattern= with =rhsValue= as the argument.

    6. Return ? [[https://tc39.es/ecma262/#sec-putvalue][PutValue]](=lref=,
       =rhsValue=).

*** Comma Operator ( =,= )
    :PROPERTIES:
    :CUSTOM_ID: comma-operator
    :END:

**** Syntax
     :PROPERTIES:
     :CUSTOM_ID: syntax-36
     :END:

*****  Expression  
 
     [[Expression][Expression]][In, Yield, Await]:
      [[AssignmentExpression][AssignmentExpression]][?In, ?Yield, ?Await]
     [[Expression][Expression]][?In, ?Yield, ?Await],[[AssignmentExpression][AssignmentExpression]][?In, ?Yield, ?Await]

     #+begin_src gerbil :noweb-ref comma-operator-expression
       (defstruct (comma-operator expression) (expressions) transparent: #t)
       (def Expression
         (.begin #t (.let* (exps (sepby1 AssignmentExpression (tpv? #\,)))
                      (return (if (null? (cdr exps)) (car exps)
                                  (comma-operator exps))))))

     #+end_src
**** Static Semantics: IsFunctionDefinition
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-isfunctiondefinition-15
     :END:

   [[Expression][Expression]]:[[Expression][Expression]],[[AssignmentExpression][AssignmentExpression]]

   1. Return false.

   <<sec-comma-operator-static-semantics-isvalidsimpleassignmenttarget>>
**** Static Semantics: AssignmentTargetType
     :PROPERTIES:
     :CUSTOM_ID: static-semantics-assignmenttargettype-16
     :END:

   [[Expression][Expression]]:[[Expression][Expression]],[[AssignmentExpression][AssignmentExpression]]

   1. Return invalid.

**** Runtime Semantics: Evaluation
     :PROPERTIES:
     :CUSTOM_ID: runtime-semantics-evaluation-39
     :END:

   [[Expression][Expression]]:[[Expression][Expression]],[[AssignmentExpression][AssignmentExpression]]

   1. Let =lref= be the result of evaluating
      [[Expression][Expression]].
   2. Perform
      ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=lref=).
   3. Let =rref= be the result of evaluating
      [[AssignmentExpression][AssignmentExpression]].
   4. Return ? [[https://tc39.es/ecma262/#sec-getvalue][GetValue]](=rref=).

   Note

   [[https://tc39.es/ecma262/#sec-getvalue][GetValue]] must be called even
   though its value is not used because it may have observable
   side-effects.

